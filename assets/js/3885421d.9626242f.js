"use strict";(self.webpackChunkopen_ziti=self.webpackChunkopen_ziti||[]).push([[4647],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(n),m=o,f=d["".concat(c,".").concat(m)]||d[m]||u[m]||i;return n?r.createElement(f,a(a({ref:t},p),{},{components:n})):r.createElement(f,a({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7261:(e,t,n)=>{n.d(t,{ZP:()=>c});var r=n(7462),o=(n(7294),n(3905));const i={toc:[]};function a(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/openziti/desktop-edge-win/releases/latest"},"Windows")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://apps.apple.com/app/id1460484572"},"MacOS")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/openziti/ziti-tunnel-sdk-c/releases/latest/"},"Linux")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://apps.apple.com/app/id1460484353"},"iOS")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://play.google.com/store/apps/details?id=org.openziti.mobile"},"Android"))))}a.isMDXComponent=!0;const s={toc:[]};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"An OpenZiti Tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the OpenZiti Network."),(0,o.kt)(a,{mdxType:"TunnelerDlMd"}))}c.isMDXComponent=!0},3157:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>c,toc:()=>p});var r=n(7462),o=(n(7294),n(3905)),i=n(7261);const a={},s="Tunnelers",c={unversionedId:"core-concepts/clients/tunnelers/index",id:"core-concepts/clients/tunnelers/index",title:"Tunnelers",description:"",source:"@site/docs/core-concepts/clients/tunnelers/index.mdx",sourceDirName:"core-concepts/clients/tunnelers",slug:"/core-concepts/clients/tunnelers/",permalink:"/docs/core-concepts/clients/tunnelers/",draft:!1,editUrl:"https://github.com/openziti/ziti-doc/tree/main/docusaurus/docs/core-concepts/clients/tunnelers/index.mdx",tags:[],version:"current",frontMatter:{},sidebar:"rootSidebar",previous:{title:"SDKs",permalink:"/docs/core-concepts/clients/sdks"},next:{title:"Linux",permalink:"/docs/core-concepts/clients/tunnelers/linux"}},l={},p=[],u={toc:p};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"tunnelers"},"Tunnelers"),(0,o.kt)(i.ZP,{mdxType:"TunnelerOverviewMd"}),(0,o.kt)("p",null,"Each tunneller operates similarly. The goal is to have the tunneler intercecpt traffic destined for Ziti\nservices and forward that traffic over the Ziti overlay instead of the underlay network.  There are two basic modes a\ntunneler operate in: seamless and proxy. A seamless tunneler will transparently intercept traffic via IPv4 address or\nDNS whereas a tunneler in proxy mode works as a proxy. Seamless mode is transparent to existing services and\napplications. Proxy mode is not transparent at all. It requires applications to send traffic to the localhost proxy\nspecifically. This means when running in proxy mode it does not do any intercepting at all."))}d.isMDXComponent=!0}}]);