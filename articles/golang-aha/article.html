<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Golang Aha! Moments | Ziti </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Golang Aha! Moments | Ziti ">
    <meta name="generator" content="docfx 2.x">
    
    <link rel="shortcut icon" href="../../images/favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
    <!--span>this is text</span-->
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&amp;display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400&amp;display=swap" rel="stylesheet">
    <meta name="google-site-verification" content="jfzf3259Xh6i82RehhnKg4aAsHd02v1MB-jP43wEqHI">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-THVRRJ3GLE"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
  
      gtag('config', 'G-THVRRJ3GLE');
    </script>
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../images/ziti-logo-40.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div style="display: flex;">
                    <div class="form-group" style="valign: center;position: relative;">
                      <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                    </div>
                    <div style="position: relative">
                        &nbsp;
                    </div>
                    <div style="position: relative">
                        <a href="https://github.com/openziti">
                            <img src="../../images/github-white.svg" alt="Star us on GitHub" title="Star us on GitHub" height="34px">
                        </a>
                    </div>
                    <div style="position: relative">
                        <a href="https://openziti.discourse.group">
                            <img src="../../images/discourse_icon_halo.svg" alt="Start a conversation on Discourse" title="Start a conversation on Discourse" height="34px">
                        </a>
                    </div>
                    <div style="position: relative">
                        <a href="https://twitter.com/openziti">
                            <img src="../../images/twit.svg" alt="Follow us on Twitter" title="Follow us on Twitter" height="34px">
                        </a>
                    </div>
                    <div style="position: relative">
                        <a href="https://www.youtube.com/channel/UCAsrfQasdZmp2Gq07Ej_5cQ">
                            <img src="../../images/yt.svg" alt="Watch videos about OpenZiti" title="Watch videos about OpenZiti" height="34px">
                        </a>
                    </div>
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default" name="new">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
          <div style="display:flex; align-items: center; justify-content: center; flex-direction:row; position: relative; width: 100%; text-align: center;     background: rgb(0,104,247);
            background: linear-gradient(90deg, rgba(0,104,247,1) 0%, rgba(222,14,91,1) 100%);">
            <span style="margin-top: 5px; color: white; margin-right: 10px; height:25px">Star us on GitHub</span>
            <span style="margin-top: 5px;"><a class="github-button" href="https://github.com/openziti/ziti" data-icon="octicon-star" data-show-count="true" aria-label="Star openziti/ziti on GitHub">Star</a></span>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="golang-aha-moments">Golang Aha! Moments</h1>

<h2 id="introduction">Introduction</h2>
<p>As we (the OpenZiti team) progressed on our Go journey, we&#39;ve stumbed on various
obstacles, settled on some best practices and hopefully gotten better at writing Go
code. This document is meant to share some of the &#39;Aha!&#39; moments where we overcame 
stumbling blocks and found solutions that sparked joy. 
This is intended both for new team members and for anyone in the go community who 
might be interested. We&#39;d be very happy to hear from others about their own &#39;aha&#39;
moments and also how the solutions presented strike your sensibilities.</p>
<h2 id="channels">Channels</h2>
<p>Channels are a core feature of go. As is typical of go, the channel API is small and
simple, but provides a lot of power. </p>
<p>If you haven&#39;t read it yet, Dave Cheney&#39;s <a href="https://dave.cheney.net/2014/03/19/channel-axioms">Channel Axioms</a>
 is worth a look.</p>
<h2 id="closing-channels">Closing Channels</h2>
<p>Closing channels can be complicated. On the reader side things are generally uncomplicated.
A closed channel read will return immediately with the zero value and flag indicating that 
it is closed.</p>
<pre><code>func main() {
    ch := make(chan interface{}, 1)
    ch &lt;- &quot;hello&quot;
    val, ok := &lt;- ch
    fmt.Printf(&quot;%v, %v\n&quot;, val, ok) // prints hello, true
    close(ch)
    val, ok = &lt;- ch
    fmt.Printf(&quot;%v, %v\n&quot;, val, ok) // prints &lt;nil&gt;, false
}
</code></pre><p>On the writer side, things can be more complicated. If you only have a single writer, 
it can be responsible for closing the channel. This notifies any blocker readers that
the channel is closed. However, if there are multiple writers, this won&#39;t work. Writing
to a closed channel will cause a panic. Closing an already closed channel will also 
cause a panic. So, what do we do?</p>
<p>The main thing is to realize that we don&#39;t have to close the channel. We only have to
make sure the readers and writers are safely notified that they should stop trying to
use the channel. For this, we can use a second channel.</p>
<pre><code>package main

import (
    &quot;github.com/openziti/foundation/util/concurrenz&quot;
    &quot;github.com/pkg/errors&quot;
)

type Queue struct {
    ch          chan int
    closeNotify chan struct{}
    closed      concurrenz.AtomicBoolean
}

func (self *Queue) Push(val int) error {
    select {
    case self.ch &lt;- val:
        return nil
    case &lt;-self.closeNotify:
        return errors.New(&quot;queue closed&quot;)
    }
}

func (self *Queue) Pop() (int, error) {
    select {
    case val := &lt;-self.ch:
        return val, nil
    case &lt;-self.closeNotify:
        return 0, errors.New(&quot;queue closed&quot;)
    }
}

func (self *Queue) Close() {
    if self.closed.CompareAndSwap(false, true) {
        close(self.closeNotify)
    }
}
</code></pre><p>If there are several entities which all need to shutdown together, they can even
share a <code>closeNotify</code> channel.</p>
<p>A variation on this would let readers drain the channel once it&#39;s closed. Because 
select case evaluation is random, we may not read a val from the channel once
the close notify channel is closed. We can ensure that we return a value if it&#39;s 
available by modifying <code>Pop()</code> as follows:</p>
<pre><code>func (self *Queue) Pop() (int, error) {
    select {
    case val := &lt;-self.ch:
        return val, nil
    case &lt;-self.closeNotify:
        select {
        case val := &lt;-self.ch:
            return val, nil
        default:
            return 0, errors.New(&quot;queue closed&quot;)
        }
    }
}
</code></pre><p>Places used:</p>
<ul>
<li><a href="https://github.com/openziti/channel/blob/main/impl.go">https://github.com/openziti/channel/blob/main/impl.go</a> (see rxer, txer)</li>
</ul>
<h2 id="other-channel-uses">Other Channel Uses</h2>
<p>Let&#39;s look at how we can use channels in a few other ways.</p>
<h3 id="semaphores-and-pools">Semaphores and Pools</h3>
<p>Because channels have a sized buffer and have well defined blocking behavior, 
creating a semaphore implementation is very straightforward. We can create a
channel with a buffer of the size we want our semaphore to have. We can then
read and write from the channel to acquire and release the semaphore. </p>
<pre><code>package concurrenz

import &quot;time&quot;

type Semaphore interface {
    Acquire()
    AcquireWithTimeout(t time.Duration) bool
    TryAcquire() bool
    Release() bool
}

func NewSemaphore(size int) Semaphore {
    result := &amp;semaphoreImpl{
        c: make(chan struct{}, size),
    }
    for result.Release() {
    }
    return result
}

type semaphoreImpl struct {
    c chan struct{}
}

func (self *semaphoreImpl) Acquire() {
    &lt;-self.c
}

func (self *semaphoreImpl) AcquireWithTimeout(t time.Duration) bool {
    select {
    case &lt;-self.c:
        return true
    case &lt;-time.After(t):
        return false
    }
}

func (self *semaphoreImpl) TryAcquire() bool {
    select {
    case &lt;-self.c:
        return true
    default:
        return false
    }
}

func (self *semaphoreImpl) Release() bool {
    select {
    case self.c &lt;- struct{}{}:
        return true
    default:
        return false
    }
}
</code></pre><p>We could use mostly the same implementation for a resource pool. Instead of
a channel of struct{}, we could have a channel of connections or buffers 
that are acquired and released.</p>
<h3 id="signal">Signal</h3>
<p>We can use channels as signals. In this example we have something running
periodically, but we want to be able to trigger it to run sooner. With a 
single element channel, we can notify a goroutine. By using <code>select</code> with
<code>default</code>, we can ensure that signalling code doesn&#39;t block and that the
receiving side only gets a single signal per loop.</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;github.com/openziti/foundation/util/concurrenz&quot;
    &quot;time&quot;
)

func NewWorker() *Worker {
    w := &amp;Worker{
        signal:  make(chan struct{}, 1),
    }
    go w.run()
    return w
}

type Worker struct {
    signal chan struct{}
    stopped concurrenz.AtomicBoolean
}

func (self *Worker) run() {
    ticker := time.NewTicker(time.Minute)
    defer ticker.Stop()

    for !self.stopped.Get() {
        select {
        case &lt;-ticker.C:
            self.work()
        case &lt;-self.signal:
            self.work()
        }
    }
}

func (self *Worker) work() {
    if !self.stopped.Get() {
        fmt.Println(&quot;working hard&quot;)
    }
}

func (self *Worker) RunNow() {
    select {
    case self.signal &lt;- struct{}{}:
    default:
    }
}
</code></pre><h3 id="channel-loops-and-event-handler">Channel Loops and Event Handler</h3>
<p>We often have a loop which is processing inputs from one or channel. Often we have a set of data
we want to keep local to a single goroutine, so we don&#39;t have to use any synchronization or worry
about cpu cache effects. We use channels to feed data to the goroutine and/or to trigger different
kinds of processing. A for with select loop can handle channels of different types. YOu can have
a channel per type of work, or per type of data. Sometimes it can be convenient to consolidate things 
on a single channel, using an event API.</p>
<p>Here&#39;s a simple example where the processor is maintaining some cached data which can be updated 
externally. Presumably the processor would be doing something with the cached data, but we&#39;ve left
that out to focus on the pattern itself.</p>
<pre><code>type Event interface {
    // events are passed the processor so they don&#39;t each have to include it
    Handle(*Processor)
}

type Processor struct {
    ch          chan Event
    closeNotify chan struct{}
    cache map[string]string
}

func (self *Processor) run() {
    for {
        select {
        case event := &lt;-self.ch:
            event.Handle(self)
        case &lt;-self.closeNotify:
            return
        }
    }
}

func (self *Processor) queueEvent(evt Event) {
    select {
    case self.ch &lt;- evt:
    case &lt;-self.closeNotify:
        return
    }
}

func (self *Processor) UpdateCache(k, v string) {
    self.queueEvent(&amp;updateCache{key: k, value: v})
}

func (self *Processor) Invalidate(k string) {
    self.queueEvent(invalidate(k))
}

type updateCache struct {
    key string
    value string
}

func (self *updateCache) Handle(p *Processor) {
    p.cache[self.key] = self.value
}

type invalidate string

func (self invalidate) Handle(p *Processor) {
    delete(p.cache, string(self))
}
</code></pre><h2 id="type-aliases">Type Aliases</h2>
<p>As we demonstrated in the previous example we can alias a type and add functions to it, usually
to satify some interface.</p>
<pre><code>type invalidate string

func (self invalidate) Handle(p *Processor) {
        delete(p.cache, string(self))
}
</code></pre><p>This can be useful if we only have a single piece of data. Rather than wrapping it in a struct, 
we can just alias it and add our own funcs. </p>
<p>The main downside to this approach is that you have to unalias the data inside your functions
which can lead to code that is less clear. See for example this method from an <code>AtomicBoolean</code>
implementation:</p>
<pre><code>type AtomicBoolean int32

func (ab *AtomicBoolean) Set(val bool) {
    atomic.StoreInt32((*int32)(ab), boolToInt(val))
}
</code></pre><h3 id="function-type-aliases">Function Type Aliases</h3>
<p>A go feature which can surprise developers is the ability to add function definitions to funcs.
The Event API in the Processor example above could be extended as follows:</p>
<pre><code>type Event interface {
    Handle(*Processor)
}

type EventF func(*Processor)

func (self EventF) Handle(p *Processor) {
    self(p)
}
</code></pre><p>The <code>Invalidate</code> code could now be written as:</p>
<pre><code>func (self *Processor) Invalidate(k string) {
    self.queueEvent(EventF(func(processor *Processor) {
        delete(processor.cache, k)
    }))
}
</code></pre><p>The need for an <code>EventF</code> cast could be removed by adding a helper function.</p>
<pre><code>func (self *Processor) queueEventF(evt EventF) {
    self.queueEvent(evt)
}

func (self *Processor) UpdateCache(k, v string) {
    self.queueEventF(func(processor *Processor) {
        processor.cache[k] = v
    })
}
</code></pre><p>I first encountered this style in the go http library where handlers can be defined
as structs implementing <code>Handler</code> or as functions matching <code>HandlerFunc</code>. This is
most useful when you may have both heavy implementations which carry a lot of state
as well as very simple implementations which make more sense as a function.</p>
<p>The processor event channel could also be implemented in terms of pure functions, if
all event implementations are lightweight.</p>
<h2 id="interfaces">Interfaces</h2>
<p>A golang limitation that often trips people up is that packages cannot have circular
dependencies. There are a few ways to work around this, but the most common is to 
introduce interfaces in the more independent of the packages.</p>
<h2 id="errors">Errors</h2>
<p>In some situations, go&#39;s error handling can be excessively verbose. Especially in 
cases where you&#39;re doing a series of I/O operations, your code can look something
like:</p>
<pre><code>func WriteExample(w io.Writer) error {
    if _, err := w.Write([]byte(&quot;one&quot;)); err != nil {
        return err
    }
    if _, err := w.Write([]byte(&quot;two&quot;)); err != nil {
        return err
    }
    if _, err := w.Write([]byte(&quot;three&quot;)); err != nil {
        return err
    }
    if _, err := w.Write([]byte(&quot;four&quot;)); err != nil {
        return err
    }
    return nil
}
</code></pre><p>One way to clean this up is to wrap the error in the operation and only check it at 
the end.</p>
<pre><code>type WriterErr struct {
    err error
    w io.Writer
}

func (self *WriterErr) Write(s string) {
    if self.err == nil {
        _, self.err = self.w.Write([]byte(s))
    }
}

func (self *WriterErr) Error() error {
    return self.err
}

func WriteExample2(w io.Writer) error {
    writer := &amp;WriterErr{w: w}
    writer.Write(&quot;one&quot;)
    writer.Write(&quot;two&quot;)
    writer.Write(&quot;three&quot;)
    writer.Write(&quot;four&quot;)
    return writer.Error()
}
</code></pre><p>See also: </p>
<ul>
<li><a href="https://go.dev/blog/errors-are-values">https://go.dev/blog/errors-are-values</a></li>
<li><a href="https://dave.cheney.net/2019/01/27/eliminate-error-handling-by-eliminating-errors">https://dave.cheney.net/2019/01/27/eliminate-error-handling-by-eliminating-errors</a></li>
</ul>
<p>Note: This pattern is could be viewed as an error monad implementation</p>
<h2 id="gotchas">Gotchas</h2>
<h3 id="loop-variablescam">Loop Variables[^cam]</h3>
<p>Like many other languages, it&#39;s possible to get into trouble when capturing loop variables,
both via pointer references and via closures.</p>
<p>The following snippet will print out <code>world world</code> since the loop variable
remains constant throughout loop iteration.</p>
<pre><code>func main() {
    var list []*string
    for _, v := range []string {&quot;hello&quot;, &quot;world&quot;} {
        list = append(list, &amp;v)
    }
    for _, v := range list {
        fmt.Printf(&quot;%v &quot;, *v)
    }
    fmt.Println()
}
</code></pre><p>Similarly, the following will output <code>second second</code>:</p>
<pre><code>func main() {
    for _, v := range []string {&quot;first&quot;, &quot;second&quot;} {
        go func() {
            time.Sleep(100 * time.Millisecond)
            fmt.Printf(&quot;%v &quot;, v)
        }()
    }
    time.Sleep(200 *time.Millisecond)
    fmt.Println()
}
</code></pre><h3 id="common-deadlock-causes">Common Deadlock Causes</h3>
<h4 id="non-reentrant-mutexes">Non-reentrant Mutexes</h4>
<p>Unlike in some other languages, the mutexes provide in the sync package are non-reentrant. So if your code
grabs a lock and ends up calling back into something which gets the same lock, the goroutine will deadlock.
Typically, if you have to call back in, you&#39;d either need an indicator that the lock is already acquired,
or do the work in a new go-routine, depending on how independent the second access was.</p>
<h4 id="channel-deadlocks">Channel Deadlocks</h4>
<p>If you have a goroutine processing events from a channel, if the event submits an event back onto the channel,
that can cause a deadlock, if the channel is not buffered, or if the buffer is full.</p>
<p>Fixes include:</p>
<ul>
<li>Running the next event in-line, if you can detect that you&#39;re already in the event processing context</li>
<li>Ensure the channel is buffer is big enough that it will never block</li>
<li>Handing the new event submission off to a new go-routine</li>
</ul>
<p>One benefit to keeping your channel buffers at zero, is that you will detect these deadlocks very quickly.
If you have a small buffer, then the deadlock may not be caught until the system is under load.</p>
<p>[^cam]: Suggested by Cameron Otts</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/openziti/ziti-doc/blob/master/docfx_project/articles/golang-aha/article.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span class='pull-left'><span><a href='https://netfoundry.io'>©NetFoundry Inc.</a></span>&nbsp;&nbsp;<span><a href='https://www.netfoundry.io/privacy-policy'>Privacy Policy</a></span>&nbsp;&nbsp;<span><a href='https://www.netfoundry.io/legal-items'>Legal</a></span>&nbsp;&nbsp;<span><a href='https://netfoundry.zendesk.com/hc/en-us'>Support</a></span>&nbsp;&nbsp;</span><span class='pull-right'><span><a href='https://www.facebook.com/NetFoundry/' target='_blank'><img height='25' src='/images/fb.svg'></a></span>&nbsp;<span><a href='https://twitter.com/openziti' target='_blank'><img height='25' src='/images/twit.svg'></a></span>&nbsp;<span><a href='https://www.linkedin.com/company/netfoundry/' target='_blank'><img height='25' src='/images/li.svg'></a></span>&nbsp;<span><a href='https://www.youtube.com/channel/UCAsrfQasdZmp2Gq07Ej_5cQ' target='_blank'><img height='25' src='/images/yt.svg'></a></span>&nbsp;&nbsp;&nbsp;</span><br>
<!-- Place this tag in your head or just before your close body tag. -->
<script async="" defer="" src="https://buttons.github.io/buttons.js"></script>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
