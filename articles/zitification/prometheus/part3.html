<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Scraping Anything, Anywhere in Action | Ziti </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Scraping Anything, Anywhere in Action | Ziti ">
    <meta name="generator" content="docfx 2.x">
    
    <link rel="shortcut icon" href="../../../images/favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    <meta property="docfx:rel" content="../../../">
    
    <!--span>this is text</span-->
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&amp;display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400&amp;display=swap" rel="stylesheet">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../images/ziti-logo-40.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div style="display: flex;">
                    <div class="form-group" style="valign: center;position: relative;">
                      <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                    </div>
                    <div style="position: relative">
                        &nbsp;
                    </div>
                    <div style="position: relative">
                        <a href="https://github.com/openziti">
                            <img src="../../../images/github-white.svg" alt="Star us on GitHub" title="Star us on GitHub" height="34px">
                        </a>
                    </div>
                    <div style="position: relative">
                        <a href="https://openziti.discourse.group">
                            <img src="../../../images/discourse_icon_halo.svg" alt="Start a conversation on Discourse" title="Start a conversation on Discourse" height="34px">
                        </a>
                    </div>
                    <div style="position: relative">
                        <a href="https://twitter.com/openziti">
                            <img src="../../../images/twit.svg" alt="Follow us on Twitter" title="Follow us on Twitter" height="34px">
                        </a>
                    </div>
                    <div style="position: relative">
                        <a href="https://www.youtube.com/channel/UCAsrfQasdZmp2Gq07Ej_5cQ">
                            <img src="../../../images/yt.svg" alt="Watch videos about OpenZiti" title="Watch videos about OpenZiti" height="34px">
                        </a>
                    </div>
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default" name="new">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
          <div style="display:flex; align-items: center; justify-content: center; flex-direction:row; position: relative; width: 100%; text-align: center;     background: rgb(0,104,247);
            background: linear-gradient(90deg, rgba(0,104,247,1) 0%, rgba(222,14,91,1) 100%);">
            <span style="margin-top: 5px; color: white; margin-right: 10px; height:25px">Star us on GitHub</span>
            <span style="margin-top: 5px;"><a class="github-button" href="https://github.com/openziti/ziti" data-icon="octicon-star" data-show-count="true" aria-label="Star openziti/ziti on GitHub">Star</a></span>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="scraping-anything-anywhere-in-action">Scraping Anything, Anywhere in Action</h1>

<style>
.flr {
  float: right;
}
</style>

<p><em>This is part three of a three-part article. This article builds on the previous two articles. Here we will take a look at what we built 
and use it to explore the power of a zitified Prometheus. See <a href="part1.html">part one</a> for the necessary background about the series. See 
<a href="part2.html">part two</a> for detailed instructions covering how to setup the environment you&#39;re about to explore</em></p>
<h2 id="the-payoff">The Payoff</h2>
<p>Ok. Here it is. We are at the end of the series and here is where we&#39;ll put it all together and really start to understand the sort of 
innovations you can create when you zitify an application. As a reminder, we are working with <a href="https://prometheus.io/">Prometheus</a>, a 
CNCF project which we will use to monitor a workload deployed in two separate <a href="https://kubernetes.io">Kubernetes</a> clusters. To save you 
from flipping back to a previous article, here is what that solution looks like.</p>
<p><img src="kubernetes-prometheus-after.svg" alt="overview"></p>
<p>Now we are ready to start using our Prometheus servers. We&#39;ll use our OpenZiti overlay network to connect to a workload which will 
generate a metric we want to display in Prometheus. We&#39;ll then configure Prometheus to scrape the workload and put it on a graph to 
prove it works. Once that&#39;s complete, we&#39;ll play around with the setup and see if we really can scrape anything, anywhere. Let&#39;s begin.</p>
<h2 id="developer-access">Developer Access</h2>
<p>In the <a href="part2.html">previous article</a>, we established our entire solution using the OpenZiti overlay, <code>kubectl</code> and <code>helm</code>. We saw 
everything get installed and it all &quot;seems to work&quot;. But how do we <strong>know</strong> it works?  Let&#39;s provision an identity for yourself now and 
let&#39;s enroll it in your local tunneling app and find out. Go out and get <a href="../../../ziti/clients/which-client.html">a tunneling client</a> running 
locally. Once you have that installed, provision an identity and enroll it with your tunneling client. </p>
<pre><code class="lang-text">ziti edge create identity user dev.client -a &quot;prometheus-clients&quot;,&quot;reflectz-clients&quot;
</code></pre><p>You should have access to six total services when this identity is enrolled:</p>
<pre><code class="lang-text">Service Name: kubeA.prometheus.svc
   Intercept: kubeA.prometheus.svc:80
Service Name: kubeA.reflect.svc
   Intercept: kubeA.reflect.svc.ziti:80
Service Name: kubeA.reflect.scrape.svc
   Intercept: kubeA.reflect.scrape.svc.ziti:80

Service Name: kubeB.prometheus.svc
   Intercept: kubeB.prometheus.svc:80
Service Name: kubeB.reflect.svc
   Intercept: kubeB.reflect.svc.ziti:80
Service Name: kubeB.reflect.scrape.svc
   Intercept: kubeB.reflect.scrape.svc.ziti:80
</code></pre><h2 id="clustera">ClusterA</h2>
<p>With your developer access you should be able to navigate your browser to <a href="http://kubea.prometheus.svc/targets">http://kubea.prometheus.svc/targets</a>. </p>
<div class="NOTE"><h5>Note</h5><p>We won&#39;t dwell on this for long in this article but notice that this is showing off another superpower of OpenZiti, private DNS. 
Notice that you were able to browse to a totally fictious domain name: kubea.prometheus.svc. &quot;.svc&quot; is <strong>not</strong> a legitimate top level 
domain. 
<a href="https://en.wikipedia.org/wiki/List_of_Internet_top-level_domains#S">Look at the full list of top level domains starting with S</a>. You 
won&#39;t find &quot;.svc&quot; on that list at this time</p>
</div>
<p><img src="kubea.prom.init.png" class="flr" style="height: 300px;"></p>
<p>You should see the following. You might have noticed that the chart deployed has a few other containers we have not discussed yet. We&#39;ll 
not go into those containers in this article. What&#39;s important is that this Prometheus server has a few targets already for us to access. 
Neat, but this isn&#39;t what we want to actually monitor.</p>
<p>What we really want to monitor is the workload we deployed: <code>reflectz</code>. We can do this by editing the Prometheus configmap using 
<code>kubectl</code>. Let&#39;s go ahead and do this now:</p>
<pre><code class="lang-text">kubectl edit cm prometheuz-prometheus-server
</code></pre><p>This will open an editor in your terminal and allow you to update the config map for the pod. Once the editor is open, find the section 
labeled &quot;scrape_config&quot; and add the following entry:</p>
<pre><code class="lang-text">    - job_name: &#39;kubeA.reflectz&#39;
      scrape_interval: 5s
      honor_labels: true
      scheme: &#39;ziti&#39;
      params:
        &#39;match[]&#39;:
          - &#39;{job!=&quot;&quot;}&#39;
        &#39;ziti-config&#39;:
          - &#39;/etc/prometheus/scrape.json&#39;
      static_configs:
        - targets:
          - &#39;kubeA.reflect.scrape.svc-kubeA.reflect.id&#39;
</code></pre><p>This is yaml and yaml is sensitive to spaces. The block above is properly indented for the config that the helm chart installs. You 
should be able to simply copy it and add it under the scrape_config. Remember, there is a <code>configmap-reload</code> container in 
the pod which monitors the configmap. On successful edit, this container will notice and will issue a web hook to the 
<code>prometheus-server</code> container. The trigger is not immediate, don&#39;t worry if it takes a while. It can take around a minute for the 
trigger to fire. </p>
<p>While we wait for the trigger, let&#39;s explain what this is doing. This is informing the Prometheus server to monitor a workload which can 
be found at the provided target of <code>kubeA.reflect.scrape.svc-kubeA.reflect.id</code>. Notice that no port is included in this target, and also 
notice that this is a very strange looking FQDN. That&#39;s because this is a zitified version of Prometheus. We have extended Prometheus to 
understand a &quot;scheme&quot; of <code>ziti</code>. When we configure this job with a scheme of ziti, we can then supply targets to the job which represent 
an OpenZiti service.  We need to supply the <code>ziti-config</code> node with the path to the identity we want Prometheus to use to issue the 
scrape. This will always be <code>/etc/prometheus/scrape.json</code> at this time. Should the community desire it, we can look into changing the 
location of the identity.</p>
<p>If you would like to tail the <code>configmap-reloadz</code> container, you can issue this one liner. This will instruct <code>kubectl</code> to tail the logs 
from <code>configmap-reloadz</code>. </p>
<pre><code class="lang-text">pod=$(kubectl get pods | grep server | cut -d &quot; &quot; -f1); echo POD: $pod; kubectl logs -f &quot;$pod&quot; prometheus-server-configmap-reload
</code></pre><p>When the trigger happens for ClusterA you will see a message like the one below. Notice that <code>configmap-reloadz</code> is using the underlay 
network: <code>http://127.0.0.1:9090/-/reload</code></p>
<pre><code class="lang-text">2022/04/23 20:01:23 config map updated
2022/04/23 20:01:23 performing webhook request (1/1/http://127.0.0.1:9090/-/reload)
2022/04/23 20:01:23 successfully triggered reload
</code></pre><h3 id="config-reloaded">Config Reloaded</h3>
<p>Once you&#39;ve correctly updated the configmap, and <code>configmap-reloadz</code> detected the change and told Prometheus to reload. You&#39;ll see a new 
target has been reported by Prometheus at <a href="http://kubea.prometheus.svc/targets">http://kubea.prometheus.svc/targets</a>. You should now see &quot;kubeA.reflectz (1/1 up)&quot; showing. 
Congratulations! You have just successfully scraped a target from zitified Prometheus! Remember this workload does not listen on the 
Kubernetes underlay network. It&#39;s only accessible from the OpenZiti overlay. </p>
<p><img src="kubea.target1.png" alt="kubea.target1.png"></p>
<h3 id="lets-graph-it">Let&#39;s Graph It!</h3>
<p>Cool, we have a target. The target can be scraped by Prometheus over the OpenZiti overlay. We&#39;re also able to securely access the 
Prometheus UI over the same OpenZiti overlay. Let&#39;s use the Prometheus UI to graph the data point we want to see, the
<code>reflect_total_connections</code> metric. </p>
<ol>
<li>Navigate to <a href="http://kubea.prometheus.svc/graph">http://kubea.prometheus.svc/graph</a></li>
<li>enter <code>reflect_total_connections</code></li>
<li>click Graph (notice I changed my time to &#39;10s&#39;, located just under Graph)</li>
<li>click Execute</li>
<li>Notice there are no connections (0)</li>
</ol>
<p><img src="kubea.graph.png" alt="grpah it"></p>
<h3 id="generate-some-data">Generate Some Data</h3>
<p>Now let&#39;s change that graph of <code>reflect_total_connections</code> from 0 to 1 (or more). One of the services you will have access to will 
intercept <code>kubeA.reflect.svc.ziti:80</code>. </p>
<div class="NOTE"><h5>Note</h5><p>If you are using Windows and Windows Subsystem for Linux (WSL) as I am, you <strong>might</strong> need to understand how get WSL to use your Ziti 
Desktop Edge for Windows as your DNS resolver when inside WSL. Generally speaking this is as easy as editing /etc/resolv.conf and 
adding the IP as the first nameserver: <code>nameserver 100.64.0.1</code> (or whatever the DNS IP is). Try it first, depending on how you setup 
WSL it might &#39;just work&#39; for you. You can also just use cygwin or any other netcat tool from Windows (not WSL) too.</p>
</div>
<p>Now we can use netcat to open a connection through this intercept a few times. The metric tracks the total number of connections to the 
reflect service. Connect, send some text, the use ctrl-c to disconnect. Do that a few times then click &#39;execute&#39; again on the graph page.
You can see I did this over a minute and moved my total count on kubeA to 8, shown below.</p>
<pre><code class="lang-text">/tmp/prometheus$ nc kubeA.reflect.svc.ziti 80
kubeA reflect test
you sent me: kubeA reflect test
^C
/tmp/prometheus$ nc kubeA.reflect.svc.ziti 80
another reflect test
you sent me: another reflect test
^C
/tmp/prometheus$ nc kubeA.reflect.svc.ziti 80
another reflect test
you sent me: another reflect test
^C
</code></pre><p><img src="kubea.more.total.conn.png" alt="kubea.more.total.conn.png"></p>
<h3 id="scrape-something-else">Scrape Something Else</h3>
<p>Hopefully you agree with me that this is pretty neat. Well what if we take it to the next level? What if we tried to scrape the 
workload we deployed to ClusterB? Could we get that to work? Recall from above how we enabled the job named &#39;kubeA.reflectz&#39;. What if we 
simply copied/pasted that into the configmap changing kubeA --&gt; kubeB. Would it work? Let&#39;s see. </p>
<pre><code class="lang-text"># edit the configmap on ClusterA:
kubectl edit cm prometheuz-prometheus-server

#add the job - and wait for the configmap to reload

    - job_name: &#39;kubeB.reflectz&#39;
      scrape_interval: 5s
      honor_labels: true
      scheme: &#39;ziti&#39;
      params:
        &#39;match[]&#39;:
          - &#39;{job!=&quot;&quot;}&#39;
        &#39;ziti-config&#39;:
          - &#39;/etc/prometheus/scrape.json&#39;
      static_configs:
        - targets:
          - &#39;kubeB.reflect.scrape.svc-kubeB.reflect.id&#39;
</code></pre><p>After watching the logs from <code>configmap-reloadz</code> on ClusterA and seeing the webhook trigger. Just go back to the Prometheus server in 
the browser. You should be at the &#39;graph&#39; url but if not navigate back and execute another graph for <code>reflect_total_connections</code>. When 
we do that it probably doesn&#39;t look much different but... Wait a second? In the legend? Can it be? That&#39;s right. From Kubernetes 
ClusterA, we have just scraped a workload from Kubernetes ClusterB, entirely over the OpenZiti overlay.</p>
<p><img src="kubeA-and-kubeB.png" alt="kubeA-and-kubeB.png"></p>
<p>Generate some data like you did before by running a few netcat connection/disconnects and click &#39;Execute&#39; again. Don&#39;t forget to send 
the connection request to kubeB though!</p>
<pre><code class="lang-text">nc kubeB.reflect.svc.ziti 80
this is kubeb
you sent me: this is kubeb
^C
nc kubeB.reflect.svc.ziti 80
another to kube b
you sent me: another to kube b
^C
nc kubeB.reflect.svc.ziti 80
one more for fun and profit
you sent me: one more for fun and profit
^C
</code></pre><p><img src="kubeB-from-kubeA.png" alt="kubeB from kubeA"></p>
<h2 id="scraping-all-the-things">Scraping All the Things!</h2>
<p>By now, you are probably starting to get the idea just how powerful this is for Prometheus. A zitified Prometheus can scrape things 
easily and natively by just deploying a <code>Prometheuz</code> instance into the location you want to scrape. Or, you can just enable a scrape 
target using a tunneling app, or in Kubernetes using the <code>ziti-host</code> helm chart.  Let&#39;s complete our vision now and stand up a 
Prometheus server on our local workstation using Docker.</p>
<p>When we run <code>Prometheuz</code> locally using docker we&#39;ll need a config file to give to docker using a volume mount. We also provide the 
identity used to connect to the OpenZiti overlay in the same fashion. Let&#39;s start up a docker container locally and see if we can grab 
data from our two Prometheus instances using a locally deployed <code>Prometheuz</code> via docker.</p>
<p>GitHub has a sample Prometheus <a href="https://raw.githubusercontent.com/openziti/ziti-doc/main/docfx_project/articles/zitification/prometheus/scripts/local.prometheus.yml">file you can download</a>.
Below, I used curl to download it and put it into the expected location.</p>
<pre><code class="lang-text">curl -s https://raw.githubusercontent.com/openziti/ziti-doc/main/docfx_project/articles/zitification/prometheus/scripts/local.prometheus.yml &gt; /tmp/prometheus/prometheus.config.yml

ziti edge create identity user local.prometheus.id -o /tmp/prometheus/local.prometheus.id.jwt -a &quot;reflectz-clients&quot;,&quot;prometheus-clients&quot;
ziti edge enroll /tmp/prometheus/local.prometheus.id.jwt -o /tmp/prometheus/local.prometheus.id.json

docker run \
  -v /tmp/prometheus/local.prometheus.id.json:/etc/prometheus/ziti.id.json \
  -v /tmp/prometheus/prometheus.config.yml:/etc/prometheus/prometheus.yml \
  -p 9090:9090 \
  openziti/prometheuz
</code></pre><p><img src="local-docker-targets.png" alt="local-docker-targets.png"></p>
<p>Look at what we&#39;ve just done. We have started a Prometheus instance locally, and used it to connect to four Prometheus targets via 
scrape configurations when all four targets are hidden entirely from my local computer (and any computer) unless the computer has an 
OpenZiti identity. I personally think that is incredibly cool!</p>
<h2 id="taking-it-to-11">Taking it to 11</h2>
<p>But wait, I&#39;m not done. That docker instance is listening on an underlay network. It&#39;s exposed to attack by anything on my local network.
I want to fix that too. Let&#39;s start this docker container up listening only on the OpenZiti overlay. Just like in <a href="part2.html">part 2</a> 
we will make a config, a service and two policies to enable identities on the OpenZiti overlay.</p>
<pre><code class="lang-text">curl -s https://raw.githubusercontent.com/openziti/ziti-doc/main/docfx_project/articles/zitification/prometheus/scripts/local.prometheus.yml &gt; /tmp/prometheus/prometheus.config.yml

# create the config and service for the local prometheus server
ziti edge create config &quot;local.prometheus.svc-intercept.v1&quot; intercept.v1 \
  &#39;{&quot;protocols&quot;:[&quot;tcp&quot;],&quot;addresses&quot;:[&quot;local.prometheus.svc&quot;],&quot;portRanges&quot;:[{&quot;low&quot;:80, &quot;high&quot;:80}], &quot;dialOptions&quot;: {&quot;identity&quot;:&quot;local.prometheus.id&quot;}}&#39;

ziti edge create service &quot;local.prometheus.svc&quot; \
  --configs &quot;local.prometheus.svc-intercept.v1&quot;

# grant the prometheus clients the ability to dial the service and the local.prometheus.id the ability to bind
ziti edge create service-policy &quot;local.prometheus.svc.dial&quot; Dial \
  --service-roles &quot;@local.prometheus.svc&quot; \
  --identity-roles &quot;#prometheus-clients&quot;
ziti edge create service-policy &quot;local.prometheus.svc.bind&quot; Bind \
  --service-roles &quot;@local.prometheus.svc&quot; \
  --identity-roles &quot;@local.prometheus.id&quot;
</code></pre><p>Once that&#39;s done - let&#39;s see if we can start the docker container. The helm charts are configured to translate the <code>--set</code> flags 
provided into &quot;container friendly&quot; settings like environment variables, volumes and mounts etc. In docker we need to provide those. If 
you&#39;re familiar with docker these will probably all make sense. The most important part of the command below is the <strong>lack</strong> of a <code>-p</code> 
flag. The <code>-p</code> flag is used to expose a port from inside docker, outside docker. Look at the previous docker sample and you&#39;ll find we 
were mapping local underlay port 9090 to port 9090 in the docker container. In this example, <strong>we will do no such thing</strong>! :)</p>
<pre><code class="lang-text">docker run \
    -e ZITI_LISTENER_SERVICE_NAME=local.prometheus.svc \
    -e ZITI_LISTENER_IDENTITY_FILE=/etc/prometheus/ziti.server.json \
    -e ZITI_LISTENER_IDENTITY_NAME=local.prometheus.id \
    -v /tmp/prometheus/prometheus.config.yml:/etc/prometheus/prometheus.yml \
    -v /tmp/prometheus/local.prometheus.id.json:/etc/prometheus/ziti.id.json \
    -v /tmp/prometheus/local.prometheus.id.json:/etc/prometheus/ziti.server.json \
    openziti/prometheuz
</code></pre><h3 id="but---does-it-work">But - Does It Work?</h3>
<p>After configuring the OpenZiti overlay, we just need to open a browser and navigate to <a href="http://local.prometheus.svc/targets">http://local.prometheus.svc/targets</a>. SUCCESS!</p>
<p><img src="local-docker-targets-no-listener.png" alt="local-docker-targets-no-listener.png"></p>
<h3 id="success">SUCCESS!</h3>
<p><img src="local-docker-graph-no-listener.png" alt="local-docker-graph-no-listener.png"></p>
<h2 id="wrap-up">Wrap Up</h2>
<p>This was quite the journey and a lot of fun. We have taken a wildly popular open source project and brought OpenZiti to it with really 
not much code at all. Then using OpenZiti we were able to give Prometheus superpowers and enable it to scrape any target regardless of 
where that target is or what network it is on. </p>
<p>Think of the possibilities here. Are you a cloud provider looking to monitor your client&#39;s services which are deployed on-prem? That&#39;s 
so easy with OpenZiti and without sacrificing security <strong>at all</strong>. In fact, using OpenZiti like this provides amazing reach while 
<strong>strengthening</strong> the security posture of the solution because you&#39;re now using the concepts of
<a href="https://en.wikipedia.org/wiki/Zero_trust_security_model">zero trust networking principles</a> and applying them to your alerting and 
monitoring solution.</p>
<p>What do you think? Was this series interesting? Do you think OpenZiti is cool and you are looking to try it out? What are you going to 
zitify? Tell us on twitter or on discourse! Both links are included in this page. Let us know what you think! Go star the 
<a href="http://github.com/openziti/ziti">openziti/ziti</a> repo and help us spread the word of OpenZiti to the world!</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/openziti/ziti-doc/blob/master/docfx_project/articles/zitification/prometheus/part3.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span class='pull-left'><span><a href='https://netfoundry.io'>©NetFoundry Inc.</a></span>&nbsp;&nbsp;<span><a href='https://www.netfoundry.io/privacy-policy'>Privacy Policy</a></span>&nbsp;&nbsp;<span><a href='https://www.netfoundry.io/legal-items'>Legal</a></span>&nbsp;&nbsp;<span><a href='https://netfoundry.zendesk.com/hc/en-us'>Support</a></span>&nbsp;&nbsp;</span><span class='pull-right'><span><a href='https://www.facebook.com/NetFoundry/' target='_blank'><img height='25' src='/images/fb.svg'></a></span>&nbsp;<span><a href='https://twitter.com/openziti' target='_blank'><img height='25' src='/images/twit.svg'></a></span>&nbsp;<span><a href='https://www.linkedin.com/company/netfoundry/' target='_blank'><img height='25' src='/images/li.svg'></a></span>&nbsp;<span><a href='https://www.youtube.com/channel/UCAsrfQasdZmp2Gq07Ej_5cQ' target='_blank'><img height='25' src='/images/yt.svg'></a></span>&nbsp;&nbsp;&nbsp;</span><br>
<!-- Place this tag in your head or just before your close body tag. -->
<script async="" defer="" src="https://buttons.github.io/buttons.js"></script>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
