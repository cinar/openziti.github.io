{
  "api/clang.html": {
    "href": "api/clang.html",
    "title": "| Ziti",
    "keywords": "This is the c# sdk"
  },
  "api/clang/index.html": {
    "href": "api/clang/index.html",
    "title": "C SDK | Ziti",
    "keywords": "C SDK This is the c sdk landing page - you should be redirected to the API doc immediately. If not click here"
  },
  "api/csharp.html": {
    "href": "api/csharp.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "api/csharp/NetFoundry.html": {
    "href": "api/csharp/NetFoundry.html",
    "title": "Namespace NetFoundry | Ziti",
    "keywords": "Namespace NetFoundry Classes Ziti A collection of static helper methods and properties for Ziti. ZitiConnection Represents a connection through the Ziti network. Supports both use-cases as well as callback-based. ZitiException Represents a Ziti-specific exception ZitiIdentity Represents an enrolled identity ZitiStream A representation of a standard which utilizes the NetFoundry network Enums ZitiStatus An enum representing the outcome of the given Ziti operation. Delegates ZitiConnection.OnConnected A delegate that represents the work to be done after a Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) operation. The result of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) may NOT be successful. It is important to verify the result by checking status ZitiConnection.OnDataReceived A delegate that represents the work to be done when data is recieved over the Ziti network. Only invoked after a successful Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) . Each time data is received it is important to verify the status is still OK ZitiConnection.OnDataWritten A delegate that is invoked after data has been put into the event loop. If there are any expensive resources held this is the callback to release those resources. Only needed when not using Ziti as a (callback based Ziti)"
  },
  "api/csharp/NetFoundry.Ziti.html": {
    "href": "api/csharp/NetFoundry.Ziti.html",
    "title": "Class Ziti | Ziti",
    "keywords": "Class Ziti A collection of static helper methods and properties for Ziti. Inheritance System.Object Ziti Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class Ziti : object Properties | Improve this Doc View Source OutputDebugInformation A property which controls whether or not output is sent to the output stream. This is a global flag - when toggled all debug messages will show across any connection. Declaration public static bool OutputDebugInformation { get; set; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source Debug(String) A helper method to output messages helpful during debugging Ziti-related issues. Declaration public static void Debug(string msg) Parameters Type Name Description System.String msg"
  },
  "api/csharp/NetFoundry.ZitiConnection.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.html",
    "title": "Class ZitiConnection | Ziti",
    "keywords": "Class ZitiConnection Represents a connection through the Ziti network. Supports both use-cases as well as callback-based. Inheritance System.Object ZitiConnection Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiConnection : IDisposable Methods | Improve this Doc View Source Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) Establishes the necessary connecctivity and callbacks to send data through the NetFoundry network Declaration public void Dial(ZitiConnection.OnConnected onConnected, ZitiConnection.OnDataReceived onDataReceived) Parameters Type Name Description ZitiConnection.OnConnected onConnected Once the connection is established this callback is called ZitiConnection.OnDataReceived onDataReceived Called each time data is received over the NetFoundry network | Improve this Doc View Source Dispose() Closes the ZitiConnection and cleans up as needed Declaration public void Dispose() | Improve this Doc View Source Write(Byte[], Int32, ZitiConnection.OnDataWritten, Object) Writes the provided data over the NetFoundry network Declaration public void Write(byte[] data, int count, ZitiConnection.OnDataWritten onDataWritten, object context) Parameters Type Name Description System.Byte [] data A buffer holding the information to be sent over the NetFoundry network System.Int32 count How many bytes of the buffer (starting at position 0) to write ZitiConnection.OnDataWritten onDataWritten A callback to be invoked after the data is written to the NetFoundry network System.Object context Any object, provided back to the caller of this functionin the onDataWritten callback"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnConnected.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnConnected.html",
    "title": "Delegate ZitiConnection.OnConnected | Ziti",
    "keywords": "Delegate ZitiConnection.OnConnected A delegate that represents the work to be done after a Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) operation. The result of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) may NOT be successful. It is important to verify the result by checking status Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnConnected(ZitiConnection zitiConnection, ZitiStatus status); Parameters Type Name Description ZitiConnection zitiConnection The ZitiConnection which as passed to the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) method ZitiStatus status The ZitiStatus representing the outcome of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived)"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnDataReceived.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnDataReceived.html",
    "title": "Delegate ZitiConnection.OnDataReceived | Ziti",
    "keywords": "Delegate ZitiConnection.OnDataReceived A delegate that represents the work to be done when data is recieved over the Ziti network. Only invoked after a successful Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) . Each time data is received it is important to verify the status is still OK Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnDataReceived(ZitiStatus status, byte[] data, int count); Parameters Type Name Description ZitiStatus status The ZitiStatus representing the outcome of the write operation. System.Byte [] data A buffer representing the data that was received over the Ziti network. Data will always start at postiion 0. System.Int32 count The number of bytes received in this interation. Data will always start at postiion 0."
  },
  "api/csharp/NetFoundry.ZitiConnection.OnDataWritten.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnDataWritten.html",
    "title": "Delegate ZitiConnection.OnDataWritten | Ziti",
    "keywords": "Delegate ZitiConnection.OnDataWritten A delegate that is invoked after data has been put into the event loop. If there are any expensive resources held this is the callback to release those resources. Only needed when not using Ziti as a (callback based Ziti) Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnDataWritten(ZitiStatus status, int bytesWritten, object context); Parameters Type Name Description ZitiStatus status A ZitiStatus that represents the state of the connection which initiated this callback. If NOT OK appropriate actions should be taken System.Int32 bytesWritten A count of how many bytes were able to be written. System.Object context The context that was supplied during the Write(Byte[], Int32, ZitiConnection.OnDataWritten, Object) invocation"
  },
  "api/csharp/NetFoundry.ZitiException.html": {
    "href": "api/csharp/NetFoundry.ZitiException.html",
    "title": "Class ZitiException | Ziti",
    "keywords": "Class ZitiException Represents a Ziti-specific exception Inheritance System.Object ZitiException Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiException : Exception Constructors | Improve this Doc View Source ZitiException(String) The basic constructor for creating a ZitiException Declaration public ZitiException(string message) Parameters Type Name Description System.String message The message"
  },
  "api/csharp/NetFoundry.ZitiIdentity.html": {
    "href": "api/csharp/NetFoundry.ZitiIdentity.html",
    "title": "Class ZitiIdentity | Ziti",
    "keywords": "Class ZitiIdentity Represents an enrolled identity Inheritance System.Object ZitiIdentity Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiIdentity : object Constructors | Improve this Doc View Source ZitiIdentity(String) Creates a new ZitiIdentity using the provided path. The path must point at a file is the result of the enrollment process. Declaration public ZitiIdentity(string path) Parameters Type Name Description System.String path The path to the enrolled Ziti identity | Improve this Doc View Source ZitiIdentity(String, Int32) Creates a new ZitiIdentity with the provided timeout (ms) using the provided path. The path must point at a file is the result of the enrollment process. Declaration public ZitiIdentity(string path, int timeOutInMillis) Parameters Type Name Description System.String path The path to the enrolled ziti identity System.Int32 timeOutInMillis timeout in milliseconds Properties | Improve this Doc View Source PathToConfigFile The path to the enrolled identity Declaration public string PathToConfigFile { get; } Property Value Type Description System.String Methods | Improve this Doc View Source Dump() Dumps debug information to standard out. Only used when debugging Declaration public void Dump() | Improve this Doc View Source InitializeAndRun() Initializes this identity with the NetFoundry network Declaration public void InitializeAndRun() | Improve this Doc View Source NewConnection(String) Creates a new ZitiConnection for this identity Declaration public ZitiConnection NewConnection(string serviceName) Parameters Type Name Description System.String serviceName The service name to create a ZitiConnection for Returns Type Description ZitiConnection A ZitiConnection that is ready to be Dialed or converted to a stream via AsStream() Exceptions Type Condition ZitiException Thrown when the serviceName provided does not exist | Improve this Doc View Source ServiceAvailable(String) Determines if the provided serviceName is available for this identity Declaration public bool ServiceAvailable(string serviceName) Parameters Type Name Description System.String serviceName The service name to verify Returns Type Description System.Boolean If the service exists - true, false if not | Improve this Doc View Source Shutdown() instructs this identity to disconnect from the NetFoundry network Declaration public void Shutdown()"
  },
  "api/csharp/NetFoundry.ZitiStatus.html": {
    "href": "api/csharp/NetFoundry.ZitiStatus.html",
    "title": "Enum ZitiStatus | Ziti",
    "keywords": "Enum ZitiStatus An enum representing the outcome of the given Ziti operation. Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public enum ZitiStatus : int Fields Name Description CONFIG_NOT_FOUND A user error indicating the provided configuration file was not found. CONNABORT An exceptional situation indicating the connection between the client and the Ziti Network Gateway was interrupted CONTROLLER_UNAVAILABLE A network error indicating the Ziti Network Controller was not able to be contacted. EOF A normal status indicating the connection is closed. GATEWAY_UNAVAILABLE A network error indicating the Ziti Network Gateway was not able to be contacted. NOT_AUTHORIZED A user error indicating the identity from the provided configuration file is not authorized to perform the action. OK Indicates a successful outcome SERVICE_UNAVALABLE A user error indicating the service name provided was not available. Either it does not exist or the provided identity does not have sufficient rights to the service. TIMEOUT An exceptional status indicating the operation did not complete within the specified timeout"
  },
  "api/csharp/NetFoundry.ZitiStream.html": {
    "href": "api/csharp/NetFoundry.ZitiStream.html",
    "title": "Class ZitiStream | Ziti",
    "keywords": "Class ZitiStream A representation of a standard which utilizes the NetFoundry network Inheritance System.Object ZitiStream Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiStream : Stream Constructors | Improve this Doc View Source ZitiStream(ZitiConnection) Creates a ZitiStream from the provided ZitiConnection Declaration public ZitiStream(ZitiConnection conn) Parameters Type Name Description ZitiConnection conn The ZitiConnection to create a ZitiStream from Properties | Improve this Doc View Source CanRead Indicates if the stream can be read from Declaration public override bool CanRead { get; } Property Value Type Description System.Boolean | Improve this Doc View Source CanSeek Seeking is not supported Declaration public override bool CanSeek { get; } Property Value Type Description System.Boolean | Improve this Doc View Source CanWrite indicates if the stream is ready for writing Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean | Improve this Doc View Source Length unsupported - always returns 0 Declaration public override long Length { get; } Property Value Type Description System.Int64 | Improve this Doc View Source Position unsupported - always returns 0 Declaration public override long Position { get; set; } Property Value Type Description System.Int64 Methods | Improve this Doc View Source Dispose(Boolean) Disposes of the ZitiStream , cleaning up any retained resources Declaration protected override void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing | Improve this Doc View Source Flush() Flushes bytes Declaration public override void Flush() | Improve this Doc View Source PumpAsync(Stream) Asynchronously pumps this ZitiStream to/from the destination Declaration public Task PumpAsync(Stream destination) Parameters Type Name Description Stream destination Returns Type Description Task | Improve this Doc View Source PumpAsync(Stream, Stream) Asynchronously pumps data between the input and destination Declaration public static Task PumpAsync(Stream input, Stream destination) Parameters Type Name Description Stream input The input stream Stream destination The destination stream Returns Type Description Task A which is awaitable | Improve this Doc View Source Read(Byte[], Int32, Int32) Reads data into the provided buffer Declaration public override int Read(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer The buffer to read data into System.Int32 offset The position in the bufer to begin appending data System.Int32 count The number of bytes to append Returns Type Description System.Int32 Returns the number of bytes read | Improve this Doc View Source Seek(Int64, SeekOrigin) unsupported Declaration public override long Seek(long offset, SeekOrigin origin) Parameters Type Name Description System.Int64 offset SeekOrigin origin Returns Type Description System.Int64 | Improve this Doc View Source SetLength(Int64) unsupported Declaration public override void SetLength(long value) Parameters Type Name Description System.Int64 value | Improve this Doc View Source Write(Byte[], Int32, Int32) Writes the provided buffer over the ZitiNetwork Declaration public override void Write(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer The buffer containing data to write System.Int32 offset The position in the buffer to read from System.Int32 count The number of bytes to write from the buffer"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "| Ziti",
    "keywords": "Here you will find the information necessary to successfully use a Ziti SDK to create an application. If there is a term which is not familiar please refer to the glossary . Each SDK has certain syntax unique to the particular language the SDK is targetting. Each SDK presents an api which is as idomatic as possible to present a consistent look and feel for the language or runtime being used."
  },
  "api/rest/create-ca-json.html": {
    "href": "api/rest/create-ca-json.html",
    "title": "| Ziti",
    "keywords": "Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" }"
  },
  "api/rest/create-service-rest.html": {
    "href": "api/rest/create-service-rest.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "api/rest/index.html": {
    "href": "api/rest/index.html",
    "title": "| Ziti",
    "keywords": "this is the landing page for rest"
  },
  "api/swift/index.html": {
    "href": "api/swift/index.html",
    "title": "Swift (with Objective-C interoperability) | Ziti",
    "keywords": "Swift (with Objective-C interoperability) empty index to be replaced by the unzipped docs fetched from s3 during build"
  },
  "articles/c-sdk-on-beaglebone.html": {
    "href": "articles/c-sdk-on-beaglebone.html",
    "title": "Building the Ziti C SDK and Sample Apps for arm (BeagleBone) | Ziti",
    "keywords": "Building the Ziti C SDK and Sample Apps for arm (BeagleBone) This article walks you through building the Ziti C SDK for Linux-arm and running the wttr sample application on a BeagleBone SanCloud . Configure the Host System This article uses an Ubuntu 19.10 virtual machine as a development host because it's relatively easy to install a functional toolchain that targets arm-linux. devbox$ sudo apt-get install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf \\ binutils-arm-linux-gnueabihf gdb-multiarch cmake git Build the SDK and Sample Applications devbox$ git clone --recurse-submodules https://github.com/netfoundry/ziti-sdk-c.git Cloning into 'ziti-sdk-c'... remote: Enumerating objects: 77, done. remote: Counting objects: 100% (77/77), done. remote: Compressing objects: 100% (50/50), done. remote: Total 1287 (delta 35), reused 51 (delta 24), pack-reused 1210 Receiving objects: 100% (1287/1287), 475.44 KiB | 4.85 MiB/s, done. ... devbox$ cd ziti-sdk-c devbox$ mkdir build-Linux-arm devbox$ cd build-Linux-arm devbox$ cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/Linux-arm.cmake .. project version: 0.9.2.1 (derived from git) -- The C compiler identification is GNU 9.2.1 -- The CXX compiler identification is GNU 9.2.1 -- Check for working C compiler: /usr/bin/arm-linux-gnueabihf-gcc ... $ make [ 1%] Building C object deps/uv-mbed/deps/libuv/CMakeFiles/uv_a.dir/src/fs-poll.c.o [ 1%] Building C object deps/uv-mbed/deps/libuv/CMakeFiles/uv_a.dir/src/idna.c.o [ 2%] Building C object deps/uv-mbed/deps/libuv/CMakeFiles/uv_a.dir/src/inet.c.o [ 2%] Building C object deps/uv-mbed/deps/libuv/CMakeFiles/uv_a.dir/src/random.c.o ... [ 99%] Building C object programs/sample_wttr/CMakeFiles/sample_wttr.dir/sample_wttr.c.o [ 99%] Linking C executable sample_wttr [ 99%] Built target sample_wttr [100%] Built target sample-host When make completes, you'll have statically linked binaries for the SDK's sample applications. Set up a Ziti Network For this article we'll use a Ziti Edge Developer Edition to run our network. Follow the Ziti Network Quickstart . Create the \"demo-weather\" Service The sample_wttr application accesses a service named \"demo-weather\", so we'll create that service now. Log in to your Ziti Edge Developer Edition web UI and follow the steps: On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Enter \"demo-weather\" Choose Router \"ziti-gw01\" For Endpoint Service choose: protocol = tcp host = wttr.in port = 80 Click save Upload the Artifacts to Your BeagleBone At this point we have created all of the artifacts that are needed for running the sample application: The \"sample_wttr\" executable The Ziti identity json file (e.g. \"NewUser.json\") Now we need to upload these artifacts to the BeagleBone. The scp command shown here assumes that: You are in the build-Linux-arm subdirectory where the make command was executed above. Your BeagleBone is running sshd and has an IP address of 192.168.2.2 which can be reached from your development host The Ziti identity json file that was created when you followed the Ziti Network Quickstart was downloaded to your ~/Downloads directory. devbox$ scp ./programs/sample_wttr/sample_wttr root@192.168.2.2:. $ scp ~/Downloads/NewUser.json ./programs/sample_wttr/sample_wttr debian@192.168.2.2:. NewUser.json 100% 6204 2.5MB/s 00:00 sample_wttr 100% 2434KB 5.4MB/s 00:00 Run the Application Now we're ready to log into the BeagleBone and run the sample application. Let's go! ubuntu@beaglebone:~$ ./sample_wttr ./NewUser.json [ 0.000] INFO library/ziti.c:173 NF_init(): ZitiSDK version 0.9.2.1-local @de37e6f(wttr-sample-shutdown-cleanup) starting at (2019-09-05T22:35:12.259) [ 0.000] INFO library/ziti.c:195 NF_init_with_tls(): ZitiSDK version 0.9.2.1-local @de37e6f(wttr-sample-shutdown-cleanup) /home/scarey/repos/github.com/netfoundry/ziti-sdk-c/deps/uv-mbed/src/http.c:315 ERR TLS handshake error /home/scarey/repos/github.com/netfoundry/ziti-sdk-c/deps/uv-mbed/src/http.c:153 WARN received -103 (software caused connection abort) [ 0.210] ERROR library/ziti.c:433 version_cb(): failed to get controller version from ec2-54-164-120-24.compute-1.amazonaws.com:1280 CONTROLLER_UNAVAILABLE(software caused connection abort) [ 0.210] WARN library/ziti_ctrl.c:49 code_to_error(): unmapped error code: CONTROLLER_UNAVAILABLE [ 0.210] ERROR library/ziti.c:419 session_cb(): failed to login: CONTROLLER_UNAVAILABLE[-11](software caused connection abort) ERROR: status => WTF: programming error ubuntu@beaglebone:~# Oops. Actually The Ziti SDK verifies the certificate from the Ziti Edge Controller, so we need to set the clock on the BeagleBone to a time/date that is within the valid range of the certificate. Might as well set the clock to the current time: ubuntu@beaglebone:~# sudo rdate time.nist.gov Wed Mar 18 15:46:56 2020 And now we are ready to run the application: ubuntu@beaglebone:~$ ./sample_wttr ./NewUser.json [ 0.000] INFO library/ziti.c:173 NF_init(): ZitiSDK version 0.9.2.1-local @de37e6f(wttr-sample-shutdown-cleanup) starting at (2020-03-18T15:46:57.536) [ 0.000] INFO library/ziti.c:195 NF_init_with_tls(): ZitiSDK version 0.9.2.1-local @de37e6f(wttr-sample-shutdown-cleanup) [ 0.554] INFO library/ziti.c:438 version_cb(): connected to controller ec2-54-164-120-24.compute-1.amazonaws.com:1280 version v0.9.0(ea556fc18740 2020-02-11 16:09:08) [ 0.696] INFO library/connect.c:180 connect_get_service_cb(): got service[demo-weather] id[cc90410f-1017-4d23-977a-3695cb58f4e8] [ 0.810] INFO library/connect.c:209 connect_get_net_session_cb(): got session[d89bfdd8-c7e5-42ff-a39f-63056eeb3a82] for service[demo-weather] [ 0.810] INFO library/channel.c:148 ziti_channel_connect(): opening new channel for ingress[tls://ec2-54-164-120-24.compute-1.amazonaws.com:3022] ch[0] sending HTTP request request success: 99 bytes sent HTTP/1.1 200 OK Server: nginx/1.10.3 Date: Wed, 18 Mar 2020 15:47:00 GMT Content-Type: text/plain; charset=utf-8 Content-Length: 8662 Connection: close Weather report: Rochester \\ / Sunny .-. 39 °F ― ( ) ― ↖ 0 mph `-’ 9 mi / \\ 0.0 in ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Wed 18 Mar ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ Overcast │ Overcast │ Cloudy │ Overcast │ │ .--. 32..35 °F │ .--. 35..41 °F │ .--. 39..44 °F │ .--. 37..42 °F │ │ .-( ). ↖ 3-4 mph │ .-( ). ← 6-8 mph │ .-( ). ← 9-16 mph │ .-( ). ↖ 9-17 mph │ │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Thu 19 Mar ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Partly cloudy │ Cloudy │ \\ / Partly cloudy │ _`/\"\".-. Patchy light d…│ │ _ /\"\".-. 41..44 °F │ .--. 50 °F │ _ /\"\".-. 53..55 °F │ ,\\_( ). 50..53 °F │ │ \\_( ). ← 4-7 mph │ .-( ). ← 4-6 mph │ \\_( ). ↖ 6-11 mph │ /(___(__) ↖ 10-19 mph │ │ /(___(__) 3 mi │ (___.__)__) 6 mi │ /(___(__) 6 mi │ ‘ ‘ ‘ ‘ 4 mi │ │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ ‘ ‘ ‘ ‘ 0.0 in | 20% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Fri 20 Mar ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ _`/\"\".-. Light rain sho…│ \\ / Partly cloudy │ \\ / Partly cloudy │ Cloudy │ │ ,\\_( ). 62 °F │ _ /\"\".-. 66 °F │ _ /\"\".-. 48..51 °F │ .--. 46 °F │ │ /(___(__) ↑ 14-27 mph │ \\_( ). ↗ 26-41 mph │ \\_( ). → 24-36 mph │ .-( ). → 22-30 mph │ │ ‘ ‘ ‘ ‘ 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ (___.__)__) 6 mi │ │ ‘ ‘ ‘ ‘ 0.0 in | 29% │ 0.0 in | 59% │ 0.0 in | 41% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ Location: Rochester, Monroe County, New York, United States of America [43.157285,-77.6152139] Follow @igor_chubin for wttr.in updates request completed: Connection closed [ 3.714] INFO library/ziti.c:238 NF_shutdown(): Ziti is shutting down ========================"
  },
  "articles/index.html": {
    "href": "articles/index.html",
    "title": "Articles | Ziti",
    "keywords": "Articles Here you'll find articles that cover various topics related to developing applications with Ziti. Ziti Up and Running on BeagleBone"
  },
  "glossary/glossary.html": {
    "href": "glossary/glossary.html",
    "title": "Glossary | Ziti",
    "keywords": "Glossary Here you will find a list of terms you may come across as you are using Ziti. Network Overlay, Overlay A Ziti network is implemented as an \"overlay\". A network overlay abstracts away the layers beneath it, providing a new set of abstractions for designing and implementing software and systems. Good programming abstractions allow developers to focus on the rules implemented by those abstractions without being concerned with the layers below the abstraction. Ziti's overlay allows developers to focus on connectivity between components without having to be concerned with low-level details of how that connectivity is managed. Service Definition A service definition is used to \"bind\" a service to a specific underlay network expression, through one or more nodes on a Ziti overlay network. A service definition usually includes a terminating router (or routers) and one or more SDK or underlay network endpoints where the service can be reached. Session A session is an \"instance\" of a service on behalf of an initiating endpoint, which is connected to a terminating endpoint. A session has strong identity and security between the initiating endpoint, terminating endpoint, and throughout the links between. A session selects a specific set of routers to traverse between the endpoints, and that path can change dynamically due to network performance. Initiating Router, Terminating Router An initiating router is the router which initiates a request for a session on behalf of a connected endpoint. A terminating router is the router which provides access to the service associated with the session request. Every session links an initiating endpoint (through an initiating router), with a terminating endpoint (through a terminating router). Initiating Endpoint, Terminating Endpoint See \"initiating router\" and \"terminating router\" above. The initiating endpoint is the endpoint responsible for requesting connectivity to a service. The terminating endpoint is the endpoint that provides the service. Path The path is the set of Ziti Routers traversed by a session from an initiating router to a terminating router. Ziti aggressively optimizes the path for throughput and reliability, and so it may change during the session. Underlay We refer to lower-level network concerns as \"underlay\". IP networking would be an example of an underlay concept. Xgress (Xctrl, Xmgmt), Ziti Fabric SDK Xgress is a set of extension components for the Ziti fabric, which enable overlay applications to participate in the overlay network. Xgress focuses on extending the data plane, providing interfaces for creating initiating and terminating endpoints. Xctrl and Xmgmt focus on extending the control and management planes of the fabric. Xgress is the core of the Ziti Fabric SDK. Ziti Controller, Controller A Ziti Controller is a process that is installed on a host, which allows it to coordinate a Ziti network. The Ziti Controller is designed to be extensible through Ziti fabric extension mechanisms (Xctrl, Xmgmt), which means that it is capable of hosting extensions to the fabric control and management planes. Ziti Edge, Edge The Ziti Edge implements the zero trust connectivity framework as an overlay application on top of the Ziti Fabric. The Ziti Edge provides connectivity implementations for a number of important endpoint types, including applications that embed Ziti connectivity through the Ziti Edge SDK. The Ziti Edge provides fallback connectivity solutions for non-Ziti applications using components like the Ziti tunnelers, and the Ziti proxy. Ziti Enabled Application A Ziti Enabled Application is an application that embeds the Ziti Endpoint SDK, such that it can participate on a Ziti network to either access or host services. Ziti Endpoint SDK, Endpoint SDK, SDK The Ziti Endpoint SDK provides software components that are designed to be embedded into customer applications so that they can participate natively in a Ziti network. The SDK targets golang, Swift, C, C#, and potentially other programming languages, allowing programs in those languages to work with idioms and concepts native to those environments. The SDK provides support for both accessing and hosting services that are available on a Ziti network. Ziti Fabric, Fabric The Ziti Fabric provides the core of the network overlay. The Ziti Fabric implements a routable mesh network, which can provide reliable connectivity between any two points on the network. The fabric provides software extension mechanisms that allow the overlay to be embedded into new overlay applications. The Ziti Edge is an example of an overlay application implemented on top of Ziti Fabric extension mechanisms (Xgress, Xctrl, Xmgmt). Ziti Network, Ziti Ziti is a modern, programmable network overlay with associated edge components, for application-embedded, zero trust network connectivity, written by developers for developers. Ziti is NetFoundry's next-generation programmable networking product. Ziti is used to create Ziti Networks. Ziti Router, Router A Ziti Router is a process that is installed on a host, which allows it to participate in a Ziti Fabric. The router is designed to be extensible through Ziti fabric extension mechanisms (Xgress), which means that it is capable of \"hosting\" overlay network applications like the Ziti Edge. Ziti Service, Service A Ziti network is primarily concerned with providing access to \"services\". A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A Ziti Service is defined by a strong, extensible identity, rather than by an expression of an underlay concept. This means that services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti service would be defined by a name and/or a certificate, rather than by a DNS name or an IP address (underlay concepts). Ziti Service, Service - Hosted Similar to a Ziti Service however the destination is not described as an IP address and port but rather it is expressed as a Ziti Identity. When used with a Ziti SDK it is possible to create a truly zero-trust application. Ziti Tunneler, Tunneler A Ziti Tunneler provides connectivity for applications that are not Ziti enabled. Our tunneler implementations provide an underlay connectivity component (TUN, tproxy, etc.), and then use the Ziti Endpoint SDK such that they can bridge connectivity onto the Ziti network."
  },
  "samples/clang.html": {
    "href": "samples/clang.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "samples/csharp.html": {
    "href": "samples/csharp.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "samples/index.html": {
    "href": "samples/index.html",
    "title": "SDK Sample Usage | Ziti",
    "keywords": "SDK Sample Usage Here you'll find the samples we have produced to try to illustrate how to use the SDKs. Demo Weather C C# C example is available here: https://github.com/nf-dev/ziti-sdk-c/tree/master/programs/sample_wttr/ /* Copyright 2019-2020 NetFoundry, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ #include <ziti/ziti.h> #include <string.h> #include <stdlib.h> #include <stdio.h> #include <uv.h> #define DIE(v) do { \\ int code = (v);\\ if (code != ZITI_OK) {\\ fprintf(stderr, \"ERROR: \" #v \" => %s\\n\", ziti_errorstr(code));\\ exit(code);\\ }} while(0) static size_t total; static ziti_context ziti; ssize_t on_data(ziti_connection c, uint8_t *buf, ssize_t len) { if (len == ZITI_EOF) { printf(\"request completed: %s\\n\", ziti_errorstr(len)); ziti_close(&c); ziti_shutdown(ziti); } else if (len < 0) { fprintf(stderr, \"unexpected error: %s\\n\", ziti_errorstr(len)); ziti_close(&c); ziti_shutdown(ziti); } else { total += len; printf(\"%.*s\", (int)len, buf); } return len; } static void on_write(ziti_connection conn, ssize_t status, void *ctx) { if (status < 0) { fprintf(stderr, \"request failed to submit status[%zd]: %s\\n\", status, ziti_errorstr((int) status)); } else { printf(\"request success: %zd bytes sent\\n\", status); } } void on_connect(ziti_connection conn, int status) { DIE(status); printf(\"sending HTTP request\\n\"); uint8_t *req = \"GET /Rochester HTTP/1.0\\r\\n\" \"Accept: */*\\r\\n\" \"Connection: close\\r\\n\" \"Host: wttr.in\\r\\n\" \"User-Agent: curl/7.59.0\\r\\n\" \"\\r\\n\"; DIE(ziti_write(conn, req, strlen(req), on_write, NULL)); } void on_ziti_init(ziti_context ztx, int status, void *ctx) { DIE(status); ziti = ztx; ziti_connection conn; DIE(ziti_conn_init(ziti, &conn, NULL)); DIE(ziti_dial(conn, \"demo-weather\", on_connect, on_data)); } int main(int argc, char** argv) { #if _WIN32 //changes the output to UTF-8 so that the windows output looks correct and not all jumbly SetConsoleOutputCP(65001); #endif uv_loop_t *loop = uv_default_loop(); DIE(ziti_init(argv[1], loop, on_ziti_init, NULL)); // loop will finish after the request is complete and ziti_shutdown is called uv_run(loop, UV_RUN_DEFAULT); printf(\"========================\\n\"); ziti_shutdown(ziti); } C# Example is available here: https://github.com/nf-dev/ziti-sdk-csharp/tree/initial_commit/Ziti.Core.Console using System; using System.IO; using System.Text; using System.Threading.Tasks; using NetFoundry; namespace Ziti.Core.Example { class Program { static async Task Main(string[] args) { byte[] wttrRequestAsBytes = Encoding.UTF8.GetBytes(\"GET / HTTP/1.0\\r\\n\" + \"Accept: *-/*\\r\\n\" + \"Connection: close\\r\\n\" + \"User-Agent: curl/7.59.0\\r\\n\" + \"Host: wttr.in\\r\\n\" + \"\\r\\n\"); string path = @\"c:/path/to/enrolled.id.json\"; //makes the output pretty - and not jumbly Console.OutputEncoding = Encoding.UTF8; /* Only needed when debugging Environment.SetEnvironmentVariable(\"ZITI_LOG\", \"6\"); NetFoundry.Ziti.OutputDebugInformation = true; */ ZitiIdentity id = new ZitiIdentity(path); id.InitializeAndRun(); //connect to the Ziti network //make a new stream using the identity ZitiStream zitiStream = new ZitiStream(id.NewConnection(\"demo-weather\")); //send the reqeust await zitiStream.WriteAsync(wttrRequestAsBytes, 0, wttrRequestAsBytes.Length); using (MemoryStream ms = new MemoryStream()) using (StreamReader sr = new StreamReader(ms)) { //display the bytes by reading from the stream and writing to the console await LocalPumpAsync(zitiStream, System.Console.OpenStandardOutput()); string output = sr.ReadToEnd(); System.Diagnostics.Debug.WriteLine(output); } } private const int DefaultStreamPumpBufferSize = 64 * 1024; public static async Task LocalPumpAsync(Stream input, Stream destination) { int count = DefaultStreamPumpBufferSize; byte[] buffer = new byte[count]; int numRead = await input.ReadAsync(buffer, 0, count).ConfigureAwait(false); while (numRead > 0) { destination.Write(buffer, 0, numRead); //writes are synchronous for now - without syncronous writes there's a lock that's //not freeing up //await destination.WriteAsync(buffer, 0, numRead).ConfigureAwait(false); numRead = await input.ReadAsync(buffer, 0, count).ConfigureAwait(false); } } } }"
  },
  "test.html": {
    "href": "test.html",
    "title": "this is a markdown test | Ziti",
    "keywords": "this is a markdown test"
  },
  "ziti/clients/android.html": {
    "href": "ziti/clients/android.html",
    "title": "Android | Ziti",
    "keywords": "Android The Android tunneler is currently in an open beta. Find the app in the Play store here"
  },
  "ziti/clients/how-to-choose.html": {
    "href": "ziti/clients/how-to-choose.html",
    "title": "Choosing a Ziti Client | Ziti",
    "keywords": "Choosing a Ziti Client After creating a Ziti Network you will quickly find the need for a client that can connect directly to the overlay. There are two types of clients for Ziti Networks: SDK-based and Tunneler-based. Which client is right for you is a relatively straightforward question to answer."
  },
  "ziti/clients/iOS.html": {
    "href": "ziti/clients/iOS.html",
    "title": "iOS | Ziti",
    "keywords": "iOS The iOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/clients/linux.html": {
    "href": "ziti/clients/linux.html",
    "title": "Linux | Ziti",
    "keywords": "Linux The linux tunneler is capable of operating in both transparent and proxy modes. In transparent mode the tunneler will interact with the operating system to establish intercept points. These intercept points correspond directly to the service definitions in place. ziti-tunnel supports several intercept modes, which are specified with a sub-command. Typically you will run ziti-tunnel with the run sub-command, which determines the preferred intercept mode based on the kernel drivers that are available on the host. $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33641 [ 0.006] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tproxy interceptor ... When started on a host that lacks iptables , the tproxy intercept mode initializer fails and ziti-tunnel attempts to use the tun intercept mode: $ sudo ziti-tunnel run ziti.json [ 0.001] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:37313 [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.009] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tun interceptor ziti-tunnel fails to start if no intercept modes can be successfully initialized: $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tun initialization failed: failed to open tun interface (name='', mtu=0): ioctl failed with 'invalid argument' [ 0.001] FATAL ziti/tunnel/cmd/ziti-tunnel/subcmd.run: failed to initialize an interceptor Intercept Modes tproxy tproxy is the preferred intercept mode when running on a Linux kernel that has the ip_tables kernel module installed. $ lsmod | grep ip_tables ip_tables 32768 5 iptable_filter,iptable_security,iptable_raw,iptable_nat,iptable_mangle ziti-tunnel manipulates routing tables and firewall rules when using the tproxy intercept mode. The NET_ADMIN Linux capability is required for these actions. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tproxy [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33355 [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.018] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.018] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.033] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.096] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.290] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.570] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding local.io = 169.254.1.1 to resolver The tproxy intercept mode creates a network listener that accepts connections at a randomly selected port on the loopback interface. Intercepted ziti service traffic directed to the listener by two mechanisms: Firewall Rules (iptables) The TPROXY iptables target is the primary intercept mechanism used by the tproxy intercept mode. The TPROXY target essentially sends packets to a local listener without actually modifying the packet's destination address fields. See https://www.kernel.org/doc/Documentation/networking/tproxy.txt and iptables-extensions(8) for more details on the TPROXY target. First, the tproxy interceptor links a new iptables chain to the PREROUTING chain: $ sudo iptables -nt mangle -L PREROUTING | grep NF-INTERCEPT NF-INTERCEPT all -- 0.0.0.0/0 0.0.0.0/0 Then it creates rules in the new chain for each intercepted service. You can view the tproxy rules in play: $ sudo iptables -nt mangle -L NF-INTERCEPT Chain NF-INTERCEPT (1 references) target prot opt source destination TPROXY tcp -- 0.0.0.0/0 5.9.243.187 /* wttr.in */ tcp dpt:443 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 169.254.1.1 /* ssh-local */ tcp dpt:22 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 1.2.3.4 /* netcat */ tcp dpt:22169 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 Packets with a destination address that matches the intercept address of a Ziti service are directed to ziti-tunnel's network listener (127.0.0.1:33355 in the examples above). This effectively enables ziti-tunnel to capture packets that are destined for any address using a single listener (and a single port). NOTE: netfilter rules were considered when implementing ziti-tunnel's tproxy intercept mode. netfilter is a slightly more modern than iptables and has a supported netlink API for manipulating rules without \"shelling out\" to the iptables command line utility. netfilter was ultimately abandoned because netfilter tproxy support requires kernel configuration options ( CONFIG_NFT_TPROXY , CONFIG_NFT_SOCKET ) that are not enabled in the default kernels of many common Linux distributions. Local Routes The TPROXY target is only valid in the PREROUTING iptables chain, which is traversed by incoming packets that were routed to the host over the network. A local route is necessary in order to get locally generated packets to traverse the PREROUTING chain: $ ip route show table local local 1.2.3.4 dev lo proto kernel scope host src 1.2.3.4 local 5.9.243.187 dev lo proto kernel scope host src 5.9.243.187 local 169.254.1.1 dev lo proto kernel scope host src 169.254.1.1 tun The tun intercept mode creates an ephemeral tun interface and configures it with the IP addresses of the services that are being proxied. ziti-tunnel manipulates network interfaces when using the tun intercept mode, which requires the NET_ADMIN Linux capability. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tun [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.012] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.012] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.031] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.089] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.280] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.502] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding myhost.io = 169.254.1.2 to resolver [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service ssh-local not hostable [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service netcat [ 2.506] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service netcat not hostable ... The addresses that ziti-tunnel adds to the tun interface are point-to-point addresses: $ ip addr show dev tun0 10: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 65535 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 169.254.1.1/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 5.9.243.187/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 169.254.1.2/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 1.2.3.4/32 scope host tun0 valid_lft forever preferred_lft forever The tun interface itself is assigned a link-local address, 169.254.1.1 in this case, and each intercepted service is represented by a point-to-point address with the remote address matching the intercept IP of the Ziti service. The tun intercept mode uses point-to-point addresses instead of local routes because local routes would result in the Linux networking stack receiving the packets that are routed to the tun interface. The point-to-point addresses ensure that the packets are delivered \"to the wire\", which mean that, for a tun interface, the packets will be picked up by ziti-tunnel when it reads data from the tun interface. proxy The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN DNS Server ziti-tunnel runs an internal DNS server by default. The DNS server must be first in the host's resolver configuration (e.g. resolve.conf). A self-test is performed when ziti-tunnel starts to ensure that its internal DNS server is configured in the system resolver: INFO[0002] dns server started on 127.0.0.1:53 INFO[0002] adding ziti-tunnel.resolver.test -> 19.65.28.94 to resolver INFO[0002] removing ziti-tunnel.resolver.test from resolver The test involves inserting a known hostname/IP address into the internal DNS server, and using the system resolver to retrieve the address of the hostname. ziti-tunnel will exit if the DNS self-test fails. Linux distributions typically manage the contents of /etc/resolv.conf, so simply editing the file will only work for a short time until /etc/resolv.conf is overwritten by the managing process. Resolver configuration changes must survive restarts of the Linux name resolution manager. Linux distrubutions use one of several name resolution managers. The simplest way to determine which name resolution manager is being used by your Linux distrubtion is to look at /etc/resolv.conf: $ ls -l /etc/resolv.conf If /etc/resolv.conf is a regular file, then it is most likely being managed by dhclient . If /etc/resolv.conf is a symlink to a file in /run/systemd/resolve, then it is being managed by systemd-resolved dhclient If your Linux distribution uses dhclient, you can configure the system resolver to use ziti-tunnel's internal DNS server first by adding the following to /etc/dhcp/dhclient.conf: prepend domain-name-servers 127.0.0.1; Then restart network manager. Unless you know the name of the NetworkManager systemd service on your Linux distrubtion, it's probably easiest to reboot the host. systemd-resolved $ sudo ln -sf /run/systemd/resolve/resolv.conf /etc $ echo -e \"[Resolve]\\nDNS=127.0.0.1\" | sudo tee /etc/systemd/resolved.conf.d/ziti-tunnel.conf $ sudo systemctl restart systemd-resolved If you are unable to control the resolver on your operating system, ziti-tunnel can use/update a hosts file for any hostnames that it tunnels: ziti-tunnel run --resolver file:///etc/hosts \"${HOME}/ziti.json\" IP Address Assignment If the service specifies a hostname for its address, ziti-tunnel resolves the hostname and adds the result to its internal DNS server: [0127] INFO adding myservice.mydomain.com -> 45.60.32.165 to resolver If the service hostname does not resolve, ziti-tunnel will find an unused link-local address and assign it to the route for the service: [0012] INFO adding bogushost.net -> 169.254.1.4 to resolver [0012] INFO ziti/tunnel/protocols/tcp.Listen: Accepting on 169.254.1.4:25 service=telnet"
  },
  "ziti/clients/macos.html": {
    "href": "ziti/clients/macos.html",
    "title": "MacOS | Ziti",
    "keywords": "MacOS The MacOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/clients/overview.html": {
    "href": "ziti/clients/overview.html",
    "title": "Clients overview | Ziti",
    "keywords": "Clients overview"
  },
  "ziti/clients/proxy-example.html": {
    "href": "ziti/clients/proxy-example.html",
    "title": "| Ziti",
    "keywords": "The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN"
  },
  "ziti/clients/sdk-quickinfo.html": {
    "href": "ziti/clients/sdk-quickinfo.html",
    "title": "| Ziti",
    "keywords": "If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/sdks.html": {
    "href": "ziti/clients/sdks.html",
    "title": "Ziti SDKs | Ziti",
    "keywords": "Ziti SDKs If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/tunneler.html": {
    "href": "ziti/clients/tunneler.html",
    "title": "Tunnelers | Ziti",
    "keywords": "Tunnelers A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux Each tunneller operates similarly. The goal is to have the tunneler intercecpt traffic destined for Ziti services and forward that traffic over the Ziti overlay instead of the underlay network. There are two basic modes a tunneler operate in: seamless and proxy. A seamless tunneler will transparently intercept traffic via IPv4 address or DNS whereas a tunneler in proxy mode works as a proxy. Seamless mode is transparent to existing services and applications. Proxy mode is not as transparent at all. It requires applications to send traffic to the localhost proxy specifically. This means when running in proxy mode - it does not do any intercepting at all. Here you can learn about the ways each tunneler operates and see the similarities as well as any differences. Linux The linux tunneler is capable of operating in both transparent and proxy modes. In transparent mode the tunneler will interact with the operating system to establish intercept points. These intercept points correspond directly to the service definitions in place. ziti-tunnel supports several intercept modes, which are specified with a sub-command. Typically you will run ziti-tunnel with the run sub-command, which determines the preferred intercept mode based on the kernel drivers that are available on the host. $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33641 [ 0.006] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tproxy interceptor ... When started on a host that lacks iptables , the tproxy intercept mode initializer fails and ziti-tunnel attempts to use the tun intercept mode: $ sudo ziti-tunnel run ziti.json [ 0.001] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:37313 [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.009] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tun interceptor ziti-tunnel fails to start if no intercept modes can be successfully initialized: $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tun initialization failed: failed to open tun interface (name='', mtu=0): ioctl failed with 'invalid argument' [ 0.001] FATAL ziti/tunnel/cmd/ziti-tunnel/subcmd.run: failed to initialize an interceptor Intercept Modes tproxy tproxy is the preferred intercept mode when running on a Linux kernel that has the ip_tables kernel module installed. $ lsmod | grep ip_tables ip_tables 32768 5 iptable_filter,iptable_security,iptable_raw,iptable_nat,iptable_mangle ziti-tunnel manipulates routing tables and firewall rules when using the tproxy intercept mode. The NET_ADMIN Linux capability is required for these actions. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tproxy [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33355 [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.018] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.018] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.033] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.096] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.290] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.570] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding local.io = 169.254.1.1 to resolver The tproxy intercept mode creates a network listener that accepts connections at a randomly selected port on the loopback interface. Intercepted ziti service traffic directed to the listener by two mechanisms: Firewall Rules (iptables) The TPROXY iptables target is the primary intercept mechanism used by the tproxy intercept mode. The TPROXY target essentially sends packets to a local listener without actually modifying the packet's destination address fields. See https://www.kernel.org/doc/Documentation/networking/tproxy.txt and iptables-extensions(8) for more details on the TPROXY target. First, the tproxy interceptor links a new iptables chain to the PREROUTING chain: $ sudo iptables -nt mangle -L PREROUTING | grep NF-INTERCEPT NF-INTERCEPT all -- 0.0.0.0/0 0.0.0.0/0 Then it creates rules in the new chain for each intercepted service. You can view the tproxy rules in play: $ sudo iptables -nt mangle -L NF-INTERCEPT Chain NF-INTERCEPT (1 references) target prot opt source destination TPROXY tcp -- 0.0.0.0/0 5.9.243.187 /* wttr.in */ tcp dpt:443 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 169.254.1.1 /* ssh-local */ tcp dpt:22 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 1.2.3.4 /* netcat */ tcp dpt:22169 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 Packets with a destination address that matches the intercept address of a Ziti service are directed to ziti-tunnel's network listener (127.0.0.1:33355 in the examples above). This effectively enables ziti-tunnel to capture packets that are destined for any address using a single listener (and a single port). NOTE: netfilter rules were considered when implementing ziti-tunnel's tproxy intercept mode. netfilter is a slightly more modern than iptables and has a supported netlink API for manipulating rules without \"shelling out\" to the iptables command line utility. netfilter was ultimately abandoned because netfilter tproxy support requires kernel configuration options ( CONFIG_NFT_TPROXY , CONFIG_NFT_SOCKET ) that are not enabled in the default kernels of many common Linux distributions. Local Routes The TPROXY target is only valid in the PREROUTING iptables chain, which is traversed by incoming packets that were routed to the host over the network. A local route is necessary in order to get locally generated packets to traverse the PREROUTING chain: $ ip route show table local local 1.2.3.4 dev lo proto kernel scope host src 1.2.3.4 local 5.9.243.187 dev lo proto kernel scope host src 5.9.243.187 local 169.254.1.1 dev lo proto kernel scope host src 169.254.1.1 tun The tun intercept mode creates an ephemeral tun interface and configures it with the IP addresses of the services that are being proxied. ziti-tunnel manipulates network interfaces when using the tun intercept mode, which requires the NET_ADMIN Linux capability. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tun [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.012] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.012] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.031] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.089] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.280] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.502] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding myhost.io = 169.254.1.2 to resolver [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service ssh-local not hostable [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service netcat [ 2.506] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service netcat not hostable ... The addresses that ziti-tunnel adds to the tun interface are point-to-point addresses: $ ip addr show dev tun0 10: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 65535 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 169.254.1.1/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 5.9.243.187/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 169.254.1.2/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 1.2.3.4/32 scope host tun0 valid_lft forever preferred_lft forever The tun interface itself is assigned a link-local address, 169.254.1.1 in this case, and each intercepted service is represented by a point-to-point address with the remote address matching the intercept IP of the Ziti service. The tun intercept mode uses point-to-point addresses instead of local routes because local routes would result in the Linux networking stack receiving the packets that are routed to the tun interface. The point-to-point addresses ensure that the packets are delivered \"to the wire\", which mean that, for a tun interface, the packets will be picked up by ziti-tunnel when it reads data from the tun interface. proxy The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN DNS Server ziti-tunnel runs an internal DNS server by default. The DNS server must be first in the host's resolver configuration (e.g. resolve.conf). A self-test is performed when ziti-tunnel starts to ensure that its internal DNS server is configured in the system resolver: INFO[0002] dns server started on 127.0.0.1:53 INFO[0002] adding ziti-tunnel.resolver.test -> 19.65.28.94 to resolver INFO[0002] removing ziti-tunnel.resolver.test from resolver The test involves inserting a known hostname/IP address into the internal DNS server, and using the system resolver to retrieve the address of the hostname. ziti-tunnel will exit if the DNS self-test fails. Linux distributions typically manage the contents of /etc/resolv.conf, so simply editing the file will only work for a short time until /etc/resolv.conf is overwritten by the managing process. Resolver configuration changes must survive restarts of the Linux name resolution manager. Linux distrubutions use one of several name resolution managers. The simplest way to determine which name resolution manager is being used by your Linux distrubtion is to look at /etc/resolv.conf: $ ls -l /etc/resolv.conf If /etc/resolv.conf is a regular file, then it is most likely being managed by dhclient . If /etc/resolv.conf is a symlink to a file in /run/systemd/resolve, then it is being managed by systemd-resolved dhclient If your Linux distribution uses dhclient, you can configure the system resolver to use ziti-tunnel's internal DNS server first by adding the following to /etc/dhcp/dhclient.conf: prepend domain-name-servers 127.0.0.1; Then restart network manager. Unless you know the name of the NetworkManager systemd service on your Linux distrubtion, it's probably easiest to reboot the host. systemd-resolved $ sudo ln -sf /run/systemd/resolve/resolv.conf /etc $ echo -e \"[Resolve]\\nDNS=127.0.0.1\" | sudo tee /etc/systemd/resolved.conf.d/ziti-tunnel.conf $ sudo systemctl restart systemd-resolved If you are unable to control the resolver on your operating system, ziti-tunnel can use/update a hosts file for any hostnames that it tunnels: ziti-tunnel run --resolver file:///etc/hosts \"${HOME}/ziti.json\" IP Address Assignment If the service specifies a hostname for its address, ziti-tunnel resolves the hostname and adds the result to its internal DNS server: [0127] INFO adding myservice.mydomain.com -> 45.60.32.165 to resolver If the service hostname does not resolve, ziti-tunnel will find an unused link-local address and assign it to the route for the service: [0012] INFO adding bogushost.net -> 169.254.1.4 to resolver [0012] INFO ziti/tunnel/protocols/tcp.Listen: Accepting on 169.254.1.4:25 service=telnet Windows The Windows tunneler currently supports proxy mode and cannot yet seamlessly intercept IPv4 traffic/DNS requests. The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN Android The Android tunneler is currently in an open beta. Find the app in the Play store here iOS The iOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months. MacOS The MacOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/clients/tunneler-overview.html": {
    "href": "ziti/clients/tunneler-overview.html",
    "title": "| Ziti",
    "keywords": "A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux"
  },
  "ziti/clients/which-client.html": {
    "href": "ziti/clients/which-client.html",
    "title": "Choosing a client | Ziti",
    "keywords": "Choosing a client Once you have a Ziti Network - you are going to require a Ziti-aware client in order to access the network. There are two types of clients and depending on your needs you'll choose to either use a tunneler or you will use an SDK to securely access the Ziti Network. Choosing which type of client you will use to connect to a Ziti Network is a straightfoward process and comes down to a single question. If you are you installing Ziti in front of an existing application which has already been developed and deployed you need to use a tunneler . If you are developing a new product, starting from scratch and you want to take advantage of a fully zero-trust solution you will probably want to use an SDK. Tunnelers A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux Read more on using tunnelers here SDK If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/windows.html": {
    "href": "ziti/clients/windows.html",
    "title": "Windows | Ziti",
    "keywords": "Windows The Windows tunneler currently supports proxy mode and cannot yet seamlessly intercept IPv4 traffic/DNS requests. The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN"
  },
  "ziti/cli-snippets/login.html": {
    "href": "ziti/cli-snippets/login.html",
    "title": "| Ziti",
    "keywords": "#load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert"
  },
  "ziti/config-store/consuming.html": {
    "href": "ziti/config-store/consuming.html",
    "title": "Consuming Configuration Data | Ziti",
    "keywords": "Consuming Configuration Data Configuration data can be retrieved directly, but it will usually be consumed by applications via the SDK. When an SDK authenticates, it will indicate which configuration types it can process. Then, when listing services, the SDK will recieve configuation data in-line. This can be done from the CLI as well. If we've set up a service ssh as follows: $ ziti edge controller create config ssh-client my-app \\ '{ \"hostname\" : \"ssh.company.com\", \"port\" : 22 }' $ ziti edge controller create service ssh --configs ssh The SDKs will present this configuration in language specific ways. You can see the data the SDK are working with from the SDK, by specifying configuration types when listing services. NOTES You can specify all to see all the configuration data. In addition to the config block which has the embedded configuration data there's also a configs section which lists all the associated configurations by ID. All associated configurations will always be listed here, regardless of which configuration types are requested. $ ziti edge controller list services -j --config-types my-app 'name=\"ssh\"' { \"meta\": { \"filterableFields\": [ \"id\", \"createdAt\", \"updatedAt\", \"name\" ], \"pagination\": { \"limit\": 10, \"offset\": 0, \"totalCount\": 1 } }, \"data\": [ { \"id\": \"5d802b56-2ce2-4d28-b95c-01c968948ecc\", \"createdAt\": \"2020-06-01T14:36:36.856984972Z\", \"updatedAt\": \"2020-06-01T14:36:36.856984972Z\", \"_links\": { \"configs\": { \"href\": \"./services/5d802b56-2ce2-4d28-b95c-01c968948ecc/configs\" }, \"self\": { \"href\": \"./services/5d802b56-2ce2-4d28-b95c-01c968948ecc\" }, \"service-edge-router-policies\": { \"href\": \"./services/5d802b56-2ce2-4d28-b95c-01c968948ecc/service-edge-router-policies\" }, \"service-policies\": { \"href\": \"./services/5d802b56-2ce2-4d28-b95c-01c968948ecc/service-policies\" }, \"terminators\": { \"href\": \"./services/5d802b56-2ce2-4d28-b95c-01c968948ecc/terminators\" } }, \"tags\": {}, \"name\": \"ssh\", \"terminatorStrategy\": \"smartrouting\", \"roleAttributes\": null, \"permissions\": [ \"Bind\", \"Dial\" ], \"configs\": [ \"e471379b-3f40-4ddf-8bae-621491127543\" ], \"config\": { \"my-app\": { \"hostname\": \"ssh.company.com\", \"port\": 22 } } } ] }"
  },
  "ziti/config-store/managing.html": {
    "href": "ziti/config-store/managing.html",
    "title": "Managing Configurations | Ziti",
    "keywords": "Managing Configurations Here is a JSON schema, modeled on the tunneler client configuration. { \"$id\": \"http://myapp.company.com/schemas/myapp.v1.config.json\", \"additionalProperties\": false, \"properties\": { \"hostname\": { \"type\": \"string\" }, \"port\": { \"maximum\": 65535, \"minimum\": 0, \"type\": \"integer\" } }, \"required\": [ \"hostname\", \"port\" ], \"type\": \"object\" } Put the schema in a file named example-config-type.json , and you can create a configuration type named my-app with it. $ ziti edge controller create config-type my-app --schema-file example-config-type.json You can now create a configuration of this type $ ziti edge controller create config ssh-client my-app \\ '{ \"hostname\" : \"ssh.company.com\", \"port\" : 22 }' Finally, you can reference this when creating a service. $ ziti edge controller create service ssh --configs ssh If a particular site wanted SSH on a different port, you could create a different configuration $ ziti edge controller create config scranton-office-ssh-client my-app \\ '{ \"hostname\" : \"ssh.company.com\", \"port\" : 2222 }' The identity corresponding to a tunneler at that site could then be configured to use that configuration. $ ziti edge controller create identity service scranton-office $ ziti edge controller update identity-configs scranton-office ssh scranton-office-ssh-client $ ziti edge controller list identity service-configs scranton-office service: ssh config: scranton-office-ssh-client results: 1-1 of 1 Overrides can be removed as well, if they are no longer needed. $ ziti edge controller update identity-configs scranton-office ssh scranton-office-ssh-client --remove $ ziti edge controller list identity service-configs scranton-office results: none"
  },
  "ziti/config-store/overview.html": {
    "href": "ziti/config-store/overview.html",
    "title": "Configuration | Ziti",
    "keywords": "Configuration Ziti has the capability to define a configuration schema for an application and provide service configuration for those applications which need additional metadata. Why Centralized Configuration? One might ask why have this feature in Ziti when applications can store configuration data in local configuration files. While this approach works, centralized management makes deployments much easier. It can be difficult or impossible to update a file on a device out in the field, whereas updating the configuration in Ziti is easy, and running clients will quickly be notified of service changes. The Ziti tunneler applicatons provide an example how configuration data can be used. Tunnelers need to know what ip/dns and port(s) to intercept for services they are proxying on the client side Tunnelers need to know where to reach out to applications they are proxying on the server side Overview The configuration store has four components: Configuration types Configuration types define a type of configuration, including an optional JSON schema that the configuration data must conform to. Configuration types have the following attributes: A name An optional JSON schema to validate configurations of the type Standard edge attributes: id, tags, createdAt, updatedAt Configurations Configurations have the following attributes: A name The configuration data, which is arbitrary JSON data, so long as it conforms to the type schema (if specified) Standard edge attributes: id, tags, createdAt, updatedAt Services Each service can be linked to multiple configuration. Services can have one configuration linked for each configuration type. Identities An identity can have a configuration specified for a given service and configuration type. This will override any configuration for the service for that type This configuration model has the following properties: Different applications can their own configuration for the same service Applications can have multiple configuration types for themselves where it makes sense Ziti tunnelers have one type for the client side and one for the server side, since they have different properties and not every service with use both Since an application can support multiple configuration types, applications can version their configuration types as their needs change"
  },
  "ziti/docker-quickstart.html": {
    "href": "ziti/docker-quickstart.html",
    "title": "Ziti Quickstart | Ziti",
    "keywords": "Ziti Quickstart This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant ziti concepts refer to the overview . This guide will utilize docker to stand up a full and complete network. If you are unfamiliar with docker take a moment and follow along with the steps for installing and running an application on your operating system. Once you feel comfortable, proceed to the steps below. From Nothing to Network Obtain the software necessary to run a Ziti network. You will need"
  },
  "ziti/downloads/enroller.html": {
    "href": "ziti/downloads/enroller.html",
    "title": "| Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/downloads/enroller-lts.html": {
    "href": "ziti/downloads/enroller-lts.html",
    "title": "| Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/downloads/overview.html": {
    "href": "ziti/downloads/overview.html",
    "title": "Ziti Related Downloads | Ziti",
    "keywords": "Ziti Related Downloads Here you'll find links to the various binaries needed to make a Ziti network or client work. Current Enroller Windows MacOS Linux Tunneler Windows MacOS Linux Previous Enroller Windows MacOS Linux Tunneler Windows MacOS Linux"
  },
  "ziti/downloads/tunneler.html": {
    "href": "ziti/downloads/tunneler.html",
    "title": "| Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/downloads/tunneler-lts.html": {
    "href": "ziti/downloads/tunneler-lts.html",
    "title": "| Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/hello-ziti.html": {
    "href": "ziti/hello-ziti.html",
    "title": "| Ziti",
    "keywords": "If you are seeing this - you have successfully connected to a Ziti network!"
  },
  "ziti/identities/create-identity-cli.html": {
    "href": "ziti/identities/create-identity-cli.html",
    "title": "| Ziti",
    "keywords": "#creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt"
  },
  "ziti/identities/creating.html": {
    "href": "ziti/identities/creating.html",
    "title": "Creating an Identity | Ziti",
    "keywords": "Creating an Identity The mechanism for creating identities is influenced by how your Ziti network is setup, specifically how the PKI is established. Identities are itegrally linked to the PKI configured in a given Ziti network and directly affects how identites are created. There are generally three groups of identities which can be created: One Time Token (ott) identites using the configured PKI One Time Token (ott) identites using a 3rd Party CA 3rd Party auto-enrolled identities Choosing an Identity Type Choosing which type of identity you are creating comes down to whether you are using a 3rd Party CA or not. If the network does not have a 3rd Party Certificate configured the only option is to use the One Time Token identity. If one or more 3rd Party CA is installed you will need to understand the intention of each 3rd Party certificate. Each of the types of identities are secure it just depends on your actual network setup as to which type to choose. If you don't know - just use the one time token identity. The identity can always be recreated at a later date and replaced if necessary. One Time Token (OTT) One time token identities are the type of identities available to all Ziti networks. A one time token identity will have a token generated at the time of the identity's creation. This token is then submitted at some point in the future as part of the enrollment process. Once an identity is successfully enrolled - the one time token is no longer valid and cannot be used to enroll the same identity again. One time tokens are delivered from the Ziti Controller as a jwt and the token expires 24 hours after the identity is created. The token is downloadable via the basic UI provided in the Ziti Edge - Developer Edition . After you create a user you can go to the Identities page and click the icon that looks like a certificate to download the .jwt file. You can also create a one time token identity using the ziti cli tool available on the path of the Ziti Edge - Developer Edition . This command will create a new identity and output the jwt to the selected path. You can then transfer the .jwt file to its intended destination. #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt 3rd Party CA - Overview The Ziti Controller is capable of using an existing PKI for authentication and authorization rather than to PKI configured in the Ziti Controller. Certificates that are not controlled by the Ziti Controller are referred to as \"3rd party\". If you have an existing PKI setup you wish to reuse or if you are just interested in learning how to use a 3rd Party CA this section is for you. Note Reusing a PKI is not a simple topic and managing and maintaining a PKI is out of the scope of this guide. A 3rd Party CA will need to be created and the public certificate uploaded into the Ziti Controller. After using an existing PKI to reuse/generate a certificate, the Ziti Controller will be to create identities which will be expected to present a certificate during the connection process that is valid per the provided certificate. Adding a 3rd Party CA to the Ziti Controller Adding a certifate to the Ziti Controller is easy using the Ziti Console provided in the Ziti Edge - Developer Edition . New CA via UI New CA via REST On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" } 3rd Party CA - One Time Token 3rd Party CA OTT enrollment is closely related to OTT Enrollment . The main difference is the utilization of a 3rd party CA certificate rather than the configured Ziti Edge CA and PKI. In this method, the system does not have access to the 3rd party CA private key and thus cannot provide CSR fulfillment capabilities. Instead it is assumed that the enrolling device has a separate process to acquire signed certificates. Rather than submitting a CSR the client uses an already acquired signed certificate as its client certificate for the enrollment request. The client certificate is validated against the CA certificate tied to the one time token. Similar to the OTT Enrollment process, identities must be provisioned ahead of enrollment in order to generate one time token required and to creat the jwt that can be delivered to enrolling devices. This means that the provisioning of the Ziti Edge identities and the client certificates must be coordinated. Identities can be enrolled with a one time token flow similar to the one time token flow . 3rd Party CA - Auto Enrolled CA Auto Enrollment is useful in situations where devices are provisioned with certificates en-mass that need to be able to register as identities within Ziti Edge. This enrollment method allows for device provisioning processes to skip the manual configuration of Ziti Edge and instead allow clients to present a signed client certificate to generate an identity during the enrollment process. The identity will grant the client access to authenticate only - any authorization will need to be done after the device identities have been created. A certificate can only be used for one identity. The Ziti Edge system does not allow the same certificate to be used for multiple identities. An enrollment request is comprised of a special enrollment URL used to perform an HTTP POST request using the signed client certificate as the TLS client certificate and an optional JSON payload that allows the client to specify the devices display name and internal username. See enrollment for more details on enrolling. New Identity via UI New Identity via UI On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt"
  },
  "ziti/identities/enrolling.html": {
    "href": "ziti/identities/enrolling.html",
    "title": "Enrolling an Identity | Ziti",
    "keywords": "Enrolling an Identity All connections made to the Ziti network leverage mutual TLS which means every client needs a valid X509 certificate which it will present to the Ziti network during the connection process. The process of obtaining a key/certificate pair and presenting it securely to the Ziti Controller is called \"Enrollment\". Overview All identities need to be enrolled with the Ziti Controller so the Ziti Controller can authenticate the incoming connection. This process is slightly different for each type of identity. NetFoundry has created a tool to aid the enrollment process named ziti-enroller . It is recommended that you use ziti-enroller to complete the enrollment as the process itself complex. Enrollers are available here: Windows MacOS Linux One Time Token Enrollment - Internal PKI Perhaps the easiest path to an enrolled identity is by using the one time token enrollment flow. This flow leverages the PKI configured in the Ziti Controller. Using the one time token flow - the ziti-enroller will generate a private key and a certificate signing request for the Ziti Controller to sign. Follow these steps to enroll a one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system: Example Usage: ziti-enroller --jwt ${jwt_file} Important The output from the ziti-enroller is a json file which must be kept secure. This file contains within it the private key used to generate a certificate request which was sent to the Ziti Controller and signed. This file should not be transferred or shared and should not be moved from the machine unless you are confident you understand the risks involved in doing so. 3rd Party CA - One Time Token This process is similar to the One Time Token flow from above. This flow expects that a private key and certificate have already been created on or distributed to the machine that is about to enroll and that the certificate presented is signed by a third party CA already validated in the Ziti Controller. Follow these steps to enroll a 3rd Pary CA - one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system. Notice you can provide the name of the identity : Example Usage: ziti-enroller -v --jwt ${jwt_file} --cert ${identity_path_to_cert} --key ${identity_path_to_key} --idname ${identity_name} 3rd Party CA - Auto When using a third party CA identity creation process in the Ziti Controller is automatic. The act of enrolling the identity will create it. Like \"3rd Party CA - One Time Token\" - this flow expects that a private key and certificate have already been created on or distributed to the machine that is about to enroll. The certificate presented to the Ziti Controller must be signed by a third party CA already uploaded and validated in the Ziti Controller with the isAutoCaEnrollmentEnabled property set to true. Using the ziti-enroller will also require the use of a jwt specifically created for the enrollment process. The jwt can be downloaded from the Ziti Controller from: ${controller_uri}/cas/${id}/jwt where ${controller_uri} represents the fully qualified address of the Ziti Controller api and ${id} represents the identifier for the given third party CA. Example Usage: ziti-enroller --jwt ${jwt_file} --cert ${identity_path_to_cert} --key ${identity_path_to_key} --idname ${identity_name} If supplied the idname will be used as the name for the identity created. If not supplied the common name will be used as the name of the identity within the Ziti Controller."
  },
  "ziti/identities/overview.html": {
    "href": "ziti/identities/overview.html",
    "title": "Ziti Identities | Ziti",
    "keywords": "Ziti Identities Ziti is built on the foundation of zero-trust. A solid pillar of that foundation requires that all connections in a Ziti-enabled network are authenticated. Identities are the basis for Ziti authentication. All devices connecting to a Ziti network will have an Identity which is presented at the time of a connection being established by both the device initiating the connection and the device receiving the incoming connection. Ziti implements mutual TLS in order to authenticate both sides of a connection. Conceptually an identity can be thought of as congruent to a user account. Identities are logical entities stored inside the Ziti Controller which map an X509 certifcate to a particular named identity. Identities exist not only to authenticate connections but are also used to authorize identities within Ziti. See Policies for more information on authoriziation of identities. 3rd Party Certificates The certificate a Ziti Edge client presents can be generated by the Ziti Controller using the configured PKI or this certificate can come from a existing PKI not controlled by the Ziti Controller. Certificates which are not created by the Ziti Controller are referred to as \"3rd Party\" because from the perspective of the Ziti Controller the certificates are not from the configured PKI. Creating an Identity The mechanism for creating identities is influenced by how your Ziti network is setup, specifically how the PKI is established. Identities are itegrally linked to the PKI configured in a given Ziti network and directly affects how identites are created. There are generally three groups of identities which can be created: One Time Token (ott) identites using the configured PKI One Time Token (ott) identites using a 3rd Party CA 3rd Party auto-enrolled identities Choosing an Identity Type Choosing which type of identity you are creating comes down to whether you are using a 3rd Party CA or not. If the network does not have a 3rd Party Certificate configured the only option is to use the One Time Token identity. If one or more 3rd Party CA is installed you will need to understand the intention of each 3rd Party certificate. Each of the types of identities are secure it just depends on your actual network setup as to which type to choose. If you don't know - just use the one time token identity. The identity can always be recreated at a later date and replaced if necessary. One Time Token (OTT) One time token identities are the type of identities available to all Ziti networks. A one time token identity will have a token generated at the time of the identity's creation. This token is then submitted at some point in the future as part of the enrollment process. Once an identity is successfully enrolled - the one time token is no longer valid and cannot be used to enroll the same identity again. One time tokens are delivered from the Ziti Controller as a jwt and the token expires 24 hours after the identity is created. The token is downloadable via the basic UI provided in the Ziti Edge - Developer Edition . After you create a user you can go to the Identities page and click the icon that looks like a certificate to download the .jwt file. You can also create a one time token identity using the ziti cli tool available on the path of the Ziti Edge - Developer Edition . This command will create a new identity and output the jwt to the selected path. You can then transfer the .jwt file to its intended destination. #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt 3rd Party CA - Overview The Ziti Controller is capable of using an existing PKI for authentication and authorization rather than to PKI configured in the Ziti Controller. Certificates that are not controlled by the Ziti Controller are referred to as \"3rd party\". If you have an existing PKI setup you wish to reuse or if you are just interested in learning how to use a 3rd Party CA this section is for you. Note Reusing a PKI is not a simple topic and managing and maintaining a PKI is out of the scope of this guide. A 3rd Party CA will need to be created and the public certificate uploaded into the Ziti Controller. After using an existing PKI to reuse/generate a certificate, the Ziti Controller will be to create identities which will be expected to present a certificate during the connection process that is valid per the provided certificate. Adding a 3rd Party CA to the Ziti Controller Adding a certifate to the Ziti Controller is easy using the Ziti Console provided in the Ziti Edge - Developer Edition . New CA via UI New CA via REST On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" } 3rd Party CA - One Time Token 3rd Party CA OTT enrollment is closely related to OTT Enrollment . The main difference is the utilization of a 3rd party CA certificate rather than the configured Ziti Edge CA and PKI. In this method, the system does not have access to the 3rd party CA private key and thus cannot provide CSR fulfillment capabilities. Instead it is assumed that the enrolling device has a separate process to acquire signed certificates. Rather than submitting a CSR the client uses an already acquired signed certificate as its client certificate for the enrollment request. The client certificate is validated against the CA certificate tied to the one time token. Similar to the OTT Enrollment process, identities must be provisioned ahead of enrollment in order to generate one time token required and to creat the jwt that can be delivered to enrolling devices. This means that the provisioning of the Ziti Edge identities and the client certificates must be coordinated. Identities can be enrolled with a one time token flow similar to the one time token flow . 3rd Party CA - Auto Enrolled CA Auto Enrollment is useful in situations where devices are provisioned with certificates en-mass that need to be able to register as identities within Ziti Edge. This enrollment method allows for device provisioning processes to skip the manual configuration of Ziti Edge and instead allow clients to present a signed client certificate to generate an identity during the enrollment process. The identity will grant the client access to authenticate only - any authorization will need to be done after the device identities have been created. A certificate can only be used for one identity. The Ziti Edge system does not allow the same certificate to be used for multiple identities. An enrollment request is comprised of a special enrollment URL used to perform an HTTP POST request using the signed client certificate as the TLS client certificate and an optional JSON payload that allows the client to specify the devices display name and internal username. See enrollment for more details on enrolling. New Identity via UI New Identity via UI On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enrolling an Identity All connections made to the Ziti network leverage mutual TLS which means every client needs a valid X509 certificate which it will present to the Ziti network during the connection process. The process of obtaining a key/certificate pair and presenting it securely to the Ziti Controller is called \"Enrollment\". Overview All identities need to be enrolled with the Ziti Controller so the Ziti Controller can authenticate the incoming connection. This process is slightly different for each type of identity. NetFoundry has created a tool to aid the enrollment process named ziti-enroller . It is recommended that you use ziti-enroller to complete the enrollment as the process itself complex. Enrollers are available here: Windows MacOS Linux One Time Token Enrollment - Internal PKI Perhaps the easiest path to an enrolled identity is by using the one time token enrollment flow. This flow leverages the PKI configured in the Ziti Controller. Using the one time token flow - the ziti-enroller will generate a private key and a certificate signing request for the Ziti Controller to sign. Follow these steps to enroll a one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system: Example Usage: ziti-enroller --jwt ${jwt_file} Important The output from the ziti-enroller is a json file which must be kept secure. This file contains within it the private key used to generate a certificate request which was sent to the Ziti Controller and signed. This file should not be transferred or shared and should not be moved from the machine unless you are confident you understand the risks involved in doing so. 3rd Party CA - One Time Token This process is similar to the One Time Token flow from above. This flow expects that a private key and certificate have already been created on or distributed to the machine that is about to enroll and that the certificate presented is signed by a third party CA already validated in the Ziti Controller. Follow these steps to enroll a 3rd Pary CA - one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system. Notice you can provide the name of the identity : Example Usage: ziti-enroller -v --jwt ${jwt_file} --cert ${identity_path_to_cert} --key ${identity_path_to_key} --idname ${identity_name} 3rd Party CA - Auto When using a third party CA identity creation process in the Ziti Controller is automatic. The act of enrolling the identity will create it. Like \"3rd Party CA - One Time Token\" - this flow expects that a private key and certificate have already been created on or distributed to the machine that is about to enroll. The certificate presented to the Ziti Controller must be signed by a third party CA already uploaded and validated in the Ziti Controller with the isAutoCaEnrollmentEnabled property set to true. Using the ziti-enroller will also require the use of a jwt specifically created for the enrollment process. The jwt can be downloaded from the Ziti Controller from: ${controller_uri}/cas/${id}/jwt where ${controller_uri} represents the fully qualified address of the Ziti Controller api and ${id} represents the identifier for the given third party CA. Example Usage: ziti-enroller --jwt ${jwt_file} --cert ${identity_path_to_cert} --key ${identity_path_to_key} --idname ${identity_name} If supplied the idname will be used as the name for the identity created. If not supplied the common name will be used as the name of the identity within the Ziti Controller."
  },
  "ziti/install/controller.html": {
    "href": "ziti/install/controller.html",
    "title": "| Ziti",
    "keywords": "UNUSED Hi from the controller file configuration: what does the version mean in config file configuration: why is there a 'db' in the config and why isn't it postgres configuration: logging explain - level/format control section:"
  },
  "ziti/install/edge-router.html": {
    "href": "ziti/install/edge-router.html",
    "title": "| Ziti",
    "keywords": "UNUSED # Edge Router The Edge Router is responsible for the"
  },
  "ziti/install/overview.html": {
    "href": "ziti/install/overview.html",
    "title": "| Ziti",
    "keywords": "UNUSED this is the install/overview.md"
  },
  "ziti/install/pki.html": {
    "href": "ziti/install/pki.html",
    "title": "| Ziti",
    "keywords": "UNUSED this is install/pki - unreferenced"
  },
  "ziti/manage/controller.html": {
    "href": "ziti/manage/controller.html",
    "title": "Ziti Controller | Ziti",
    "keywords": "Ziti Controller The Ziti Controller is the process that coordinates a Ziti network. It is responsible for authenticating incoming connections from identities and authorizing identities to services and provides a RESTful API for other processes to interact with it. Prerequisite - Database There are a few prerequisites necessary before being able to deploy your first Ziti Controller. The first thing you will need is a database. At this time the Ziti Controller is using a Postgres instance. Setting up and managing a Postgres database is a complex task beyond the scope of this guide. This guide is intended to be illustrative of installing and managing the Ziti Controller and not maintaining a Postgres installation. Refer to the documentation from Postgres for asistance setting up a Postgres database. Prerequisite - PKI Public Key Infrastructure (PKI) is a complex topic. See the pki page for additional details about the sort of needs and considerations relevant to the Ziti Controller. Sizing Guidelines The Ziti Controller and Ziti Routers are still in the process of being stress tested. We recommend starting with a small scale deployment until key performance indicators start to hint that the server requires more resources. A Ziti network will have two important metrics: CPU and network capacity. Modest sized networks require minimal investments in infrastructure. Start with small machines and increase as needed. Configuration The Ziti Controller is configured using a yaml file. An example configuration file can be found here . Each section is annotated and should provide you enough information to modify a given setting. Most of the fields are straight-forward. The pki-related fields are the ones you will need to pay particular attention to. See the pki page for relevant information on pki settings. Logging The Ziti components log all output to standard output. Logging to standard out, instead of to configurable files, etc., is a \"lighter\" approach to logging that is more easily integrated into more different kinds of environments. Logging to files and implementing feautres like file rotation is a solved problem and not one that the Ziti components try to solve. Instead look to alternatives which are capable of watching standard out and aggregating the results for you. There are many solutions available to collect, aggregate and display logs. Search for and implement a solution that works for you and your needs. Log Format The output from Ziti components comes in three distinct styles. Choose the style of logging that is right for you. pfxlog - a human-readible format leveraging ascii escape codes to display colorized log level json - a machine-readible format targetting automated processes for log aggregation/searching text - a human-readible format using plain text (no ascii escape codes) Log Levels By default the Ziti components will log at the INFO level. This means that log messages INFO, WARNING, ERROR and FATAL will all be captured and output. Ziti components all support verbose logging by adding --verbose or -v to the command being executed. Verbose mode will add DEBUG log messages and as the name implies this log level is much more verbose. Often when debugging adding verbose mode will aid in identifying issues."
  },
  "ziti/manage/edge-router.html": {
    "href": "ziti/manage/edge-router.html",
    "title": "Edge Router | Ziti",
    "keywords": "Edge Router The Edge Router is the entry point for Ziti-based clients. It is responsible for authenticating incoming connections by verifying the connecting client has a valid network session. It also routes traffic to whatever the destination is for the given service. In simple deployments - a single edge router might be deployed. This is the case with the Ziti Edge - Developer Edition . In the coming months it will be possible to produce complicated deployments having multiple Edge Routers deployed in a myriad of locations. Sizing Guidelines The Ziti Controller and Ziti Routers are still in the process of being stress tested. We recommend starting with a small scale deployment until key performance indicators start to hint that the server requires more resources. A Ziti network will have two important metrics: CPU and network capacity. Modest sized networks require minimal investments in infrastructure. Start with small machines and increase as needed. Configuration The Edge Router is configured using a yaml file. An example configuration file can be found here . Each section is annotated and should provide enough information to modify a given setting. Most of the fields are straight-forward. Edge Router Identity The pki-related fields in the identity section are important to understand and pay particular attention to. The files specified here are generated durring the process of enrolling the edge router. As is also stated in the configuration file these files do not need to exist before enrollment. These files will be written to during the enrollment process. This means the process running the enrollment will need the correct privledges grated to it in order to write - or overwrite those files. If the key specified in the identity section already exists - it will not be overwritten. Instead it will be used during the enrollment process. Logging The Ziti components log all output to standard output. Logging to standard out, instead of to configurable files, etc., is a \"lighter\" approach to logging that is more easily integrated into more different kinds of environments. Logging to files and implementing feautres like file rotation is a solved problem and not one that the Ziti components try to solve. Instead look to alternatives which are capable of watching standard out and aggregating the results for you. There are many solutions available to collect, aggregate and display logs. Search for and implement a solution that works for you and your needs. Log Format The output from Ziti components comes in three distinct styles. Choose the style of logging that is right for you. pfxlog - a human-readible format leveraging ascii escape codes to display colorized log level json - a machine-readible format targetting automated processes for log aggregation/searching text - a human-readible format using plain text (no ascii escape codes) Log Levels By default the Ziti components will log at the INFO level. This means that log messages INFO, WARNING, ERROR and FATAL will all be captured and output. Ziti components all support verbose logging by adding --verbose or -v to the command being executed. Verbose mode will add DEBUG log messages and as the name implies this log level is much more verbose. Often when debugging adding verbose mode will aid in identifying issues. Enrollment Enrollment is the process of securely generating information used to identify a given client. All endpoints need to be enrolled in one way or another. The Edge Router is a client of a Ziti Network and thus it too must be enrolled before it will be able to participate in a Ziti network. An Edge Router is enrolled using the ziti-router enroll command and sub-command. Running ziti-router enroll In order to enroll the Edge Router a valid configuration file is needed. After creating a valid configuration the jwt for the Edge Router also needs to be obtained from the Ziti Controller. The jwt can be retrieved from the Ziti Controller via the Ziti Controller's REST API at https://${controller-name}:${controller-port}/edge-routers. With a valid configuration file and jwt the router can now be enrolled using: ziti-router enroller [path to configuration file] --jwt [path to jwt] ."
  },
  "ziti/manage/fabric-router.html": {
    "href": "ziti/manage/fabric-router.html",
    "title": "Edge Router | Ziti",
    "keywords": "Edge Router The Edge Router is responsible for the"
  },
  "ziti/manage/logging-snippet.html": {
    "href": "ziti/manage/logging-snippet.html",
    "title": "Logging | Ziti",
    "keywords": "Logging The Ziti components log all output to standard output. Logging to standard out, instead of to configurable files, etc., is a \"lighter\" approach to logging that is more easily integrated into more different kinds of environments. Logging to files and implementing feautres like file rotation is a solved problem and not one that the Ziti components try to solve. Instead look to alternatives which are capable of watching standard out and aggregating the results for you. There are many solutions available to collect, aggregate and display logs. Search for and implement a solution that works for you and your needs. Log Format The output from Ziti components comes in three distinct styles. Choose the style of logging that is right for you. pfxlog - a human-readible format leveraging ascii escape codes to display colorized log level json - a machine-readible format targetting automated processes for log aggregation/searching text - a human-readible format using plain text (no ascii escape codes) Log Levels By default the Ziti components will log at the INFO level. This means that log messages INFO, WARNING, ERROR and FATAL will all be captured and output. Ziti components all support verbose logging by adding --verbose or -v to the command being executed. Verbose mode will add DEBUG log messages and as the name implies this log level is much more verbose. Often when debugging adding verbose mode will aid in identifying issues."
  },
  "ziti/manage/manage.html": {
    "href": "ziti/manage/manage.html",
    "title": "Managing Ziti | Ziti",
    "keywords": "Managing Ziti Ziti management needs to be hands off. The only times one should be expected to be concerned with managing a Ziti instance is during the initial installation and when trying to expand the Ziti footprint. Installation Ziti Edge - Developer Edition An initial, simple installation of Ziti is already provided for you when using the Ziti Edge - Developer Edition . The installation will contain a Ziti Controller , a Ziti Edge Router and corresponding PKI . See the corresponding sections for additional details. Ziti Installation - the long way At its most simple, a basic Ziti Network is composed of only two (or three depending on whether you count the database) components. The Ziti Controller and a Ziti Edge Router . (Note: these executables are not currently available for separate download but will be coming in the months ahead.) Expanding Ziti At this time Ziti is only offered as the Ziti Edge - Developer Edition which is not expandable beyond a single node at this time. As you would exepct, allowing Ziti to be expanded past the developer experience is planned. Check back in the coming months for more information."
  },
  "ziti/manage/pki.html": {
    "href": "ziti/manage/pki.html",
    "title": "Public Key Infrastructure (PKI) | Ziti",
    "keywords": "Public Key Infrastructure (PKI) All Ziti Networks leverage Public Key Infrastructure (PKI) to provide secure network connections. This page is not intended to be a comprehensive guide. What it is, is a set of rules that must be followed to properly configure a Ziti Network. If there are issues when connecting any portion of a Ziti Network to another - this page should serve as a starting point of understanding. Note PKI is a complex topic and it is recommended to be familiar with what is a PKI as well as how to properly use and configure a one before making any decisions about the PKI the Ziti Network uses. The Ziti Network allows the operator to declare any trust anchors as valid. This means Ziti does not need to be configured with a full chain of certificates which link fully back to a root CA. A configuration using a full chain back to a root CA is of course supported but it is not explicitly required. This allows the operator to configure a Ziti Network using one or more chains of trust back to the provided trust anchors. The sections below will describe where these trust anchors can be configured. Ziti Network components are required to present a certificate to other Ziti Network components during the connection establishment. This certificate will need to be valid per the configured trust anchor store being connected to. Ziti Controller The Ziti Controller has three distinct sections related to PKI: identity , edge.api.identity , edge.enrollment.signingCert . The edge.api.identity configuration section is optional and is provided to allow the external REST endpoint to present a certificate that is different than the one configured in the identity section. Connections to the Ziti Controller are considered valid if the certificate presented during connection is signed by a trust anchor declared within the identity.ca configuration or if the certificate presented is signed by the certificate specified in the edge.enrollment.signingCert . PKI Configuration The identity section of the Ziti Controller configuration is used by the Ziti Controller when connections are established to or from other components of a Ziti Network. There are four sections in the identity block: cert , server_cert , key , ca . ca : A file representing a group of certificates with one or more certificate chains terminating at a trust anchor. When a Ziti Network component connects to the Ziti Controller and offers a certificate for validation the incoming connection is checked to see if it signed by a trust anchor specified in this file. key : Also referred to as the private key . It is generated first and used to produce the certificates specified in the cert and server_cert fields of the Ziti Controller configuration file. cert : The certificate presented to other Ziti Network components during connection establishment. server_cert : The certificate returned by the Ziti Controller when other Ziti Network components attempt to communicate to the Ziti Controller over the IP and port specified in the ctrl.listener or mgmt.listener fields of the Ziti Controller configuration file. If an edge section is present in the configuration file and no edge.api.identity section exists this certificate is also returned to incoming connections to the edge.api.advertise endpoint. Edge Router An Edge Router has one section related to PKI: identity . It is important to note that an Edge Router will manage its own PKI. Allowing the Edge Router to manage its own PKI is almost certainly desired. The only setting that an operator may wish to provide is the key field of the identity. This field is treated differently than the other values specified. If the key specified does not exist a new key will be generated. If the key provided exists the Edge Router will use it and the other fields will be regenerated and overwritten as necessary. The certificate generated will be signed by the Ziti Controller using the certificate specified in edge.enrollment.signingCert . PKI Configuration The identity section of the Edge Router configuration is used by the Edge Router when connections are established to or from the other components of a Ziti Network. There are four sections in the identity block: cert , server_cert , key , ca . ca : A file representing a group of certificates with one or more certificate chains terminating at a trust anchor. When a Ziti Network component connects to the Edge Router and offers a certificate for validation the incoming connection is checked to see if it signed by a trust anchor specified in this file. key : Also referred to as the private key . It is generated first and used to produce the certificates specified in the cert and server_cert fields of the Edge Router configuration file. cert : The certificate presented to other Ziti Network components during connection establishment. server_cert : The certificate returned by the Edge Router when other Ziti Network components attempt to communicate to the Edge Router over the IP and port specified in the ctrl.listener or mgmt.listener fields of the Edge Router configuration file. Third Party CA (optional) A third party CA is one which is maintained and managed entirely outside of the Ziti Network. This is an important feature for organizations wishing to administer and maintain the certificates used by the different pieces of the Ziti Network. A Ziti Network is capable of using third party PKIs as the trust mechanism for enrollment and authentication of clients for a Ziti Network. With the PKI being managed externalliy a Ziti Network is never in posession of the private key. This means the Ziti Network cannot maintain nor distribute certificates necessary for creating secure connections. The Ziti Network is only capable of verifying if the certificate presented was signed by the externally managed PKI. Maintaining a PKI outside of the Ziti Network is a more complex configuration. If a PKI is already established and maintained externally setting up a Ziti Network with a third party CA may be desired. Registering the CA A Ziti Network will not trust any third party CA implicitly. Before a third party CA can be used for enrollment and authentication of clients in a Ziti Network it must be registered with the Ziti Controller to ensure certificates signed by the third party CA can be trusted. Registering a third party CA is done by using the REST endpoint /cas from the Ziti Controller. To register a third party CA the following information is required to be posted to the endpoint: name : the desired name of the CA isEnrollmentEnabled : a boolean value indicating if the CA can be used for enrollment. Defaults to true. Set to false to prevent further enrollments using this CA isAuthEnabled : a boolean value indicating if the CA can be used for authentication. Defaults to true. Set to false to prevent all authentication from endpoints signed by this certificate Assuming the create request was well formed and successful, the response from this invocation will contain a field representing the id of the third party CA at data.id . The id of the third party CA will be needed when validating the third party CA. Validating the CA After being submitted to the Ziti Controller, the third party CA will have the isCsrValidated field set to false indicating it is not yet ready for use. A second step is needed to ensure the third party CA is setup properly as a CA. This step ensures the third party CA provided is capable of fullfilling CSR requests. Clients attempting to connect to a Ziti Network using the third party CA will be rejected. To validate the third party CA a CSR must be generated and fulfilled by the third party CA to generate a certificate with the common name (CN) field set to a value assigned by the Ziti Controller. The Ziti Controller /cas REST endpoint can be interrogated to retrieve the details for a specific third party CA. The field necessary to validate the third party CA is data.verificationToken and is obtained at this endpoint. A certificate is then created and signed by the third party CA with the common name field set to the verificationToken. To finish verifying the third party CA, the certificate created with the verificationToken is posted back to the Ziti Controller at /cas/${id}/verify . The id is also obtained during the creation process. After posting the certificate with the verificationToken as the common name the third party CA will change from isVerified=false to isVerified=true . PKI Troubleshooting Configuring a Ziti Network's PKI can be confusing. Validating a single side of a mutual TLS connection is straightforward it becomes tedious to ensure all the certificates and cas in use are valid when you have a fully configured Ziti Network. It's the goal of this page to make diagnosing PKI issues eaiser. This guide will also use the paths you will find in the Ziti Edge - Developer Edition. Change paths accordingly. Prerequisites The following steps are bash-based functions and use the openssl , jq and ruby commands. If you don't have bash, openssl and ruby - this page is not for you! Do your best to follow along with the scripts and guidance herein or just make sure bash, openssl, ruby, and jq are installed. All of which are widely available on linux/MacOS/Windows. The ruby and jq commands are not strictly required. They are used to make it easy for you to copy/paste these commands. The ruby command is used to translate yaml into json while the jq command is used to pull the specific values out of the given files. You can certainly do the same manually (without ruby and jq ) if you choose. Define the verifyCertAgainstPool Function In your bash prompt copy and paste these two functions: function yaml2json() { ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF))' $* } function verifyCertAgainstPool() { if [[ \"\" == \"$1\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi if [[ \"\" == \"$2\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi echo \" Verifying that this certificate:\" echo \" - $1\" echo \" is valid for this ca pool:\" echo \" - $2\" echo \"\" openssl verify -partial_chain -CAfile \"$2\" \"$1\" if [ $? -eq 0 ]; then echo \"\" echo \"============ SUCCESS! ============\" else echo \"\" echo \"============ FAILED TO VALIDATE ============\" fi } Validating the PKI Every connection in a Ziti Network is mutally authenticated via X509 certificates. It is easiest to first identify the two components trying to communicate to isolate and minimize the configuration and files that need to be inspected. Below you will find sections relevant to each of the pieces of Ziti which connect. Each section will refer to a bash variable that is expected to be established before running the command. This variable is intended to make it easier for you to simply copy/paste the command and determine if the configuration is valid or not. Using the provided bash function above - you will see one of two results: Success verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem /path/to/cert-to-test.cert: OK ============ SUCCESS! ============ Failure verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem C = US, ST = NC, L = Charlotte, O = NetFoundry, OU = Ziti, CN = 87f8cee9-b288-49f1-ab90-b664af29e17a error 20 at 0 depth lookup: unable to get local issuer certificate error /path/to/cert-to-test.cert: verification failed ============ FAILED TO VALIDATE ============ Ziti Edge Router to Controller Variables to Establish Manually These two variables represent the Ziti Edge Router configuration file and the Controller configuration file. controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste These commands extract the files specified in the configuration and store them into the assigned variables. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) edge_router_ca=$(yaml2json $edge_router_config_file | jq -j .identity.ca) Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool $edge_router_cert $signing_cert verifyCertAgainstPool $controller_cert $edge_router_ca Ziti Client to Controller - API Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml Variables - Copy/Paste These commands will extract the cert and ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.cert $identity_file | cut -d \":\" -f2 > /tmp/identity.cert jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca These commands extract the files specified in the configuration and store them into the assigned variables. controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .edge.api.identity.server_cert) if [[ \"null\" == \"$controller_api_server_cert\" ]]; then controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .identity.server_cert); fi Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool /tmp/identity.cert $signing_cert verifyCertAgainstPool $controller_api_server_cert /tmp/identity.ca Ziti Client to Ziti Edge Router - Data Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste This command will extract the ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca This command extracts the file specified in the configuration and stores it into the assigned variable. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) Commands to Verify PKI Configuration The following command should report SUCCESS. verifyCertAgainstPool $edge_router_cert /tmp/identity.ca"
  },
  "ziti/manage/pki-troubleshooting.html": {
    "href": "ziti/manage/pki-troubleshooting.html",
    "title": "PKI Troubleshooting | Ziti",
    "keywords": "PKI Troubleshooting Configuring a Ziti Network's PKI can be confusing. Validating a single side of a mutual TLS connection is straightforward it becomes tedious to ensure all the certificates and cas in use are valid when you have a fully configured Ziti Network. It's the goal of this page to make diagnosing PKI issues eaiser. This guide will also use the paths you will find in the Ziti Edge - Developer Edition. Change paths accordingly. Prerequisites The following steps are bash-based functions and use the openssl , jq and ruby commands. If you don't have bash, openssl and ruby - this page is not for you! Do your best to follow along with the scripts and guidance herein or just make sure bash, openssl, ruby, and jq are installed. All of which are widely available on linux/MacOS/Windows. The ruby and jq commands are not strictly required. They are used to make it easy for you to copy/paste these commands. The ruby command is used to translate yaml into json while the jq command is used to pull the specific values out of the given files. You can certainly do the same manually (without ruby and jq ) if you choose. Define the verifyCertAgainstPool Function In your bash prompt copy and paste these two functions: function yaml2json() { ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF))' $* } function verifyCertAgainstPool() { if [[ \"\" == \"$1\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi if [[ \"\" == \"$2\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi echo \" Verifying that this certificate:\" echo \" - $1\" echo \" is valid for this ca pool:\" echo \" - $2\" echo \"\" openssl verify -partial_chain -CAfile \"$2\" \"$1\" if [ $? -eq 0 ]; then echo \"\" echo \"============ SUCCESS! ============\" else echo \"\" echo \"============ FAILED TO VALIDATE ============\" fi } Validating the PKI Every connection in a Ziti Network is mutally authenticated via X509 certificates. It is easiest to first identify the two components trying to communicate to isolate and minimize the configuration and files that need to be inspected. Below you will find sections relevant to each of the pieces of Ziti which connect. Each section will refer to a bash variable that is expected to be established before running the command. This variable is intended to make it easier for you to simply copy/paste the command and determine if the configuration is valid or not. Using the provided bash function above - you will see one of two results: Success verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem /path/to/cert-to-test.cert: OK ============ SUCCESS! ============ Failure verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem C = US, ST = NC, L = Charlotte, O = NetFoundry, OU = Ziti, CN = 87f8cee9-b288-49f1-ab90-b664af29e17a error 20 at 0 depth lookup: unable to get local issuer certificate error /path/to/cert-to-test.cert: verification failed ============ FAILED TO VALIDATE ============ Ziti Edge Router to Controller Variables to Establish Manually These two variables represent the Ziti Edge Router configuration file and the Controller configuration file. controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste These commands extract the files specified in the configuration and store them into the assigned variables. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) edge_router_ca=$(yaml2json $edge_router_config_file | jq -j .identity.ca) Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool $edge_router_cert $signing_cert verifyCertAgainstPool $controller_cert $edge_router_ca Ziti Client to Controller - API Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml Variables - Copy/Paste These commands will extract the cert and ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.cert $identity_file | cut -d \":\" -f2 > /tmp/identity.cert jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca These commands extract the files specified in the configuration and store them into the assigned variables. controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .edge.api.identity.server_cert) if [[ \"null\" == \"$controller_api_server_cert\" ]]; then controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .identity.server_cert); fi Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool /tmp/identity.cert $signing_cert verifyCertAgainstPool $controller_api_server_cert /tmp/identity.ca Ziti Client to Ziti Edge Router - Data Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste This command will extract the ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca This command extracts the file specified in the configuration and stores it into the assigned variable. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) Commands to Verify PKI Configuration The following command should report SUCCESS. verifyCertAgainstPool $edge_router_cert /tmp/identity.ca"
  },
  "ziti/manage/router-overview.html": {
    "href": "ziti/manage/router-overview.html",
    "title": "Ziti Router | Ziti",
    "keywords": "Ziti Router A Ziti Router is a process that is installed on a host which allows it to participate in a Ziti network. There are two types of routers: edge routers and fabric routers. At this time the edge router is available for use with a Ziti Edge - Developer Edition ( AWS / Azure ). Support for fabric routers is planned soon. Read more about edge routers here ."
  },
  "ziti/manage/troubleshooting.html": {
    "href": "ziti/manage/troubleshooting.html",
    "title": "Troubleshooting | Ziti",
    "keywords": "Troubleshooting This is where troubleshooting information will be added. Right now the biggest issue people have had is during initial setup of a Ziti Network and with PKI configuration. As additional troubleshooting needs become apparent this page will be updated. PKI Troubleshooting Configuring a Ziti Network's PKI can be confusing. Validating a single side of a mutual TLS connection is straightforward it becomes tedious to ensure all the certificates and cas in use are valid when you have a fully configured Ziti Network. It's the goal of this page to make diagnosing PKI issues eaiser. This guide will also use the paths you will find in the Ziti Edge - Developer Edition. Change paths accordingly. Prerequisites The following steps are bash-based functions and use the openssl , jq and ruby commands. If you don't have bash, openssl and ruby - this page is not for you! Do your best to follow along with the scripts and guidance herein or just make sure bash, openssl, ruby, and jq are installed. All of which are widely available on linux/MacOS/Windows. The ruby and jq commands are not strictly required. They are used to make it easy for you to copy/paste these commands. The ruby command is used to translate yaml into json while the jq command is used to pull the specific values out of the given files. You can certainly do the same manually (without ruby and jq ) if you choose. Define the verifyCertAgainstPool Function In your bash prompt copy and paste these two functions: function yaml2json() { ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF))' $* } function verifyCertAgainstPool() { if [[ \"\" == \"$1\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi if [[ \"\" == \"$2\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi echo \" Verifying that this certificate:\" echo \" - $1\" echo \" is valid for this ca pool:\" echo \" - $2\" echo \"\" openssl verify -partial_chain -CAfile \"$2\" \"$1\" if [ $? -eq 0 ]; then echo \"\" echo \"============ SUCCESS! ============\" else echo \"\" echo \"============ FAILED TO VALIDATE ============\" fi } Validating the PKI Every connection in a Ziti Network is mutally authenticated via X509 certificates. It is easiest to first identify the two components trying to communicate to isolate and minimize the configuration and files that need to be inspected. Below you will find sections relevant to each of the pieces of Ziti which connect. Each section will refer to a bash variable that is expected to be established before running the command. This variable is intended to make it easier for you to simply copy/paste the command and determine if the configuration is valid or not. Using the provided bash function above - you will see one of two results: Success verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem /path/to/cert-to-test.cert: OK ============ SUCCESS! ============ Failure verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem C = US, ST = NC, L = Charlotte, O = NetFoundry, OU = Ziti, CN = 87f8cee9-b288-49f1-ab90-b664af29e17a error 20 at 0 depth lookup: unable to get local issuer certificate error /path/to/cert-to-test.cert: verification failed ============ FAILED TO VALIDATE ============ Ziti Edge Router to Controller Variables to Establish Manually These two variables represent the Ziti Edge Router configuration file and the Controller configuration file. controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste These commands extract the files specified in the configuration and store them into the assigned variables. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) edge_router_ca=$(yaml2json $edge_router_config_file | jq -j .identity.ca) Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool $edge_router_cert $signing_cert verifyCertAgainstPool $controller_cert $edge_router_ca Ziti Client to Controller - API Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml Variables - Copy/Paste These commands will extract the cert and ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.cert $identity_file | cut -d \":\" -f2 > /tmp/identity.cert jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca These commands extract the files specified in the configuration and store them into the assigned variables. controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .edge.api.identity.server_cert) if [[ \"null\" == \"$controller_api_server_cert\" ]]; then controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .identity.server_cert); fi Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool /tmp/identity.cert $signing_cert verifyCertAgainstPool $controller_api_server_cert /tmp/identity.ca Ziti Client to Ziti Edge Router - Data Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste This command will extract the ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca This command extracts the file specified in the configuration and stores it into the assigned variable. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) Commands to Verify PKI Configuration The following command should report SUCCESS. verifyCertAgainstPool $edge_router_cert /tmp/identity.ca"
  },
  "ziti/manage/tunneler.html": {
    "href": "ziti/manage/tunneler.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "ziti/overview.html": {
    "href": "ziti/overview.html",
    "title": "Overview | Ziti",
    "keywords": "Overview Why Ziti? Ziti represents the next generation of secure, open-source networking for your applications. Ziti has several components. The Ziti fabric provides a scalable, plugable, networking mesh with built in smart routing The Ziti edge components provide a secure, Zero Trust entry point into your network The Ziti SDKs allow you to integrate Ziti directly into your applications The Ziti tunnelers and proxies allow existing applications and networks to take advantage of a Ziti deployment Security Features Zero Trust and Application Segmentation Dark Services and Routers End to end encryption Performance and Reliability A scalable mesh fabric with smart routing Support for load balancing services for both horizontal scale and failover setups Developer Focus Open source code, available with the Apache 2.0 license Fully programable REST management APIs SDKs for a variety of programming languages Application specific configuration store allowing centralized management of configuration allowing you to add structured configuration specific to your application An extensible fabric, allowing you to add your own load balancing algorithms interconnect protocols ingress and egress protocols metrics collections frameworks control and management plane messaging and semantics Easy Management A flexible and expressive policy model for managing access to services and edge routers A web based admin console Pre-built tunnelers and proxies for a variety of operating systems, including mobile Let's break some of these buzzwords down. Zero Trust/Application Segmentation Many networking security solutions act like a wall around an internal network. Once you are through the wall, you have access to everything inside. Zero trust solutions enforce not just access to a network, but access to individual applications within that network. Every client in a Ziti system must have an identity with provisioned certificates. The certificates are used to establish secure communications channels as well as for authentication and authorization of the associated identity. Whenever the client attempts to access a network application, Ziti will first ensure that the identity has access to the application. If access is revoked, open network connections will be closed. This model enables Ziti systems to provide access to multiple applications while ensuring that clients only get access to those applications to which they have been granted access. In addition to requiring cert based authentication for clients, Ziti uses certificates to authorize communication between Ziti components. Dark Services and Routers There are various levels of accessibility a network application/service can have. Many network services are available to the world. The service then relies on authentication and authorization policies to prevent unwanted access. Firewalls can be used to limit access to specific IP or ranges. This increases security at the cost of flexibility. Adding users can be complicated and users may not be able to easily switch devices or access the service remotely. Services can be put behind a VPN or made only accessible to an internal network, but there are some downsides to this approach. If you can access the VPN or internal network for any reason, all services in that VPN become more vulnerable to you. VPNs are not usually appropriate for external customers or users. For end users, VPNs add an extra step that needs to be done each time they want to access the service. Services can be made dark, meaning they do not have any ports open for anyone to even try and connect to. Making something dark can be done in a few ways, but the way it's generally handled in Ziti is that services reach out and establish one or more connections to the Ziti network fabric. Clients coming into the fabric can then reach the service through these connections after being authenticated and authorized. Ziti routers, which make up the fabric, can also be dark. Routers locoated in private networks will usually be made dark. These routers will reach out of the private network to talk to the controller and to make connections to join the network fabric mesh. This allows the services and routers in your private networks to make only outbound connections, so no holes have to opened for inbound traffic. Services can be completely dark if they are implemented with a Ziti SDK. If this is not possible a Ziti tunneler or proxy can be colocated with the service. The service then only needs to allow connections from the local machine or network, depending on how close you colocate the proxy to the service. End to End Encryption If you take advantage of Ziti's developer SDKs and embed Ziti in your client and server applications, your traffic can be configured to be seamlessly encrypted from the client application to server application. If you prefer to use tunnelers or proxy applications, the traffic can be ecnrypted for you from machine to machine or private network to private network. Various combinations of the above are also supported. End-to-end encryption means that even if systems between the client and server are compromised, your traffic cannot be decrypted or tampered with. Getting started with Ziti If you are looking to jump right in feet first you can follow along with one of our up-and-running quickstart guides . The quickstart will leverage Amazon Web Services (AWS) and will have you launch an AMI which will get you up and running in no time. This environment is perfect for evaluators to get to know Ziti and the capabilities it offers. The environement was not designed for large scale deployment or for long-term usage. If you are looking for a managed service to help you run a truly global, scalable network browse over to our website at http://netfoundry.io to learn more. Contributing The Ziti project welcomes contributions including, but not limited to, code, documentation and bug reports. All Ziti code is found on Github under the OpenZiti organization. ziti : top level project which builds all Ziti executables edge : edge components and model which includes identity, polices and config fabric : fabric project which includes core controller and router foundation : project which contains library code used across multiple projects SDKs ziti-sdk-c : C SDK ziti-sdk-csharp : C# SDK ziti-sdk-jvm : SDK for JVM based languages ziti-sdk-swift : Swift SDK ziti-sdk-nodejs : NodeJS SDK sdk-golang : Go SDK ziti-doc : Documention (which you are currently reading) A Discourse forum is available Ziti was developed and open sourced by Netfoundry, Inc . Netfoundry continues to fund and contribute to Ziti. Overview of a Ziti Network The Ziti Network (Ziti) is composed of the following building blocks: Ziti Controller, Ziti Router, Ziti Edge Router, Ziti Edge Clients. These components are used in conjunction to provide secure connectivity between two points such as a client to a server. This type of network is considered an overlay network because it provides secure connectivity on top – or “overlaying” – existing networking infrastructure. Here's an overview of a network: ZITI CONTROLLER The NetFoundry Ziti Controller is the central function of the NetFoundry Ziti Network. The Ziti Controller provides the configuration plane. It is responsible for configuring Ziti services as well as being the central point for managing the identities used by users, devices and the nodes making up the Ziti Network. Lastly but critically, the Ziti Controller is responsible for authentication and authorization for every connection in the Ziti network. The Ziti Controller must be configured with public key infrastructure (pki). The configured pki is used to create secure, mutually authenticated TLS (mTLS) network connections between any two pieces of the Ziti Network. The Ziti Controller does not provide its own pki but for the Ziti Controller to sign certificate requests (CSR) the Ziti Controller will need to be configured with a key and certificate used for signing. (Optionally, the Ziti CLI can be used to generate a pki if needed) The Ziti Controller also supports using a third-party pki should the operator of the Ziti Network have an existing pki they wish to reuse. Utilizing a third-party CA pushes the burden of obtaining and distributing properly signed certificates to the operator of the Ziti network but for sophisticated customers this might make overall management of the network easier. The Ziti Controller uses an out of process database (Postgres) to store the information needed to manage the network. ZITI FABRIC ROUTER Ziti Fabric Routers are the fundamental building blocks of the Ziti Network. These routers are responsible for securely and reliably delivering traffic from one Ziti Network node to the traffic’s destination. Ziti Fabric Routers are linked together to form a mesh network. This mesh is constantly being monitored for latency and the fastest paths are used when routing traffic to the destination. The monitoring also allows for active failover to ensure a reliable network connection even in the case of a node failure. ZITI EDGE ROUTER Another fundamental building block of the Ziti Network is the Ziti Edge Router. The Ziti Edge Router is the entry point for Edge Clients connecting to the Ziti Network. The Ziti Edge Router is a specialized Ziti Router incorporating the functionality of a Ziti Router to enable it to route traffic over the Ziti network as a Ziti Router would to a given destination. The Ziti Edge Router in combination with the Ziti Controller is responsible for authenticating and authorizing Ziti Edge Clients. ZITI EDGE CLIENTS Connecting to the Ziti Network requires a Ziti Edge Client. Edge Clients are designed to work with both brownfield and greenfield applications. If the solution being developed includes developing new software NetFoundry offers SDKs targeting various languages and runtimes to provide fast, reliable and secure connectivity. These SDKs provide the capabilities needed to securely connect to the Ziti Network and are designed to be easily incorporated into the target application. When adding secure connectivity to an already existing solution NetFoundry offers specialized Edge Clients called tunnelers which provide seamless, secure connectivity and do not require changes to the target application. USING ZITI Once the Ziti Network is established and deployed the next step is to configure the software-powered network. The three main concepts necessary to configure a Ziti Network are: Identities, Services, and Policies. SERVICES A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A Ziti Service is defined by a strong, extensible identity, rather than by an expression of an underlay concept. This means that services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti Service is defined by a name and/or a certificate, rather than by a DNS name or an IP address (underlay concepts). Services also declare a node where traffic that exits the Ziti Network needs to be sent do before exiting. It’s possible for the node traffic enters to be the same it exits and it’s possible for traffic needing to traverse the Ziti Network Routers to reach the correct node. Simply specifying the node is all the end-user need do, the Ziti Network handles the rest. IDENTITIES Identities represent individual endpoints in the Ziti Network which can establish connectivity. All connections made within the Ziti Network are mutually authenticated using X509 Certificates. Every Identity is mapped to a given certificate’s signature. Ziti Edge Clients present this certificate when initiating connections to the Ziti Network. The presented certificate is used by the Ziti Network to authorize the client and enumerate the services the Identity is authorized to use. POLICIES Policies control how Identities, Services and Edge Routers are allowed to interact. In order to use a service the identity must be granted access to the service. Also, since all access to a service goes through one more edge routers, both the service and the identity must be granted to access to the same edge router or edge routers. ROLE ATTRIBUTES Entities such as identities, services and edge routers can be added to policies explicity, either by id or name. Entities can also be tagged with role attributes. Role attributes are simple strings like sales , Boston , us-employees or support . Their meaning is decided by the administrator. Policies can include entities by specifying a set of role attributes to match. SERVICE POLICIES Service Policies encapsulate the mapping between identities and services in a software-powered network. In the simplest terms, Service Policies are a group of services and a group of identities. The act of adding a service to a Service Policy will grant the identities in that Service Policy access to the given service. Similarly, adding an identity to a Service Policy will grant that identity access to the services mapped in that Service Policy. Service policies controls both which identities may dial a service (use the service) and which identities may bind a service (provide or host the service). Each Service Policy may either grant dial or bind access, but not both. EDGE ROUTER POLICIES Edge Router Policies manage the mapping between identities and edge routers. Edge Router Policies are a group of edge routers and a group of identities. Adding an edge router to an Edge Router Policy will grant the identities in that Edge Router Policy access to the given edge router. Similarly, adding an identity to an Edge Router Policy will grant that identity access to the edge routers mapped in that Edge Router Policy. SERVICE EDGE ROUTER POLICIES Service Edge Router Policies manage the mapping between services and edge routers. Service Edge Router Policies are a group of edge routers and a group of services. Adding an edge router to a Service Edge Router Policy will grant the services in that Service Edge Router Policy access to the given edge router. Similarly, adding a service to a Service Edge Router Policy will grant that service access to the edge routers mapped in that Service Edge Router Policy."
  },
  "ziti/policies/create-edge-router-policy-cli.html": {
    "href": "ziti/policies/create-edge-router-policy-cli.html",
    "title": "| Ziti",
    "keywords": "To create an Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create an edge router policy named 'my-policy' which allows all identities to use all edge-routers ziti edge controller create edge-router-policy my-policy --identity-roles '#all' --edge-router-roles '#all'"
  },
  "ziti/policies/create-edge-router-policy-ui.html": {
    "href": "ziti/policies/create-edge-router-policy-ui.html",
    "title": "| Ziti",
    "keywords": "On the left side nav bar, click \"Ziti Policies\" It should already be selected, but if not, on the top nav bar, click \"Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy, such as \"My Edge Router Policy\" Enter the edge routers you want to include in the policy Specific edge routers can be referenced by ID or name using @ . For example, an edge router called us-east-4 can be referenced using @us-east-4 . Edge routers can be referenced by role attribute using # . For example, any edge router which has the us-seast role attribute will be included if #us-east is included in the edge routers roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save"
  },
  "ziti/policies/create-service-edge-router-policy-cli.html": {
    "href": "ziti/policies/create-service-edge-router-policy-cli.html",
    "title": "| Ziti",
    "keywords": "To create a Service Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service edge router policy which allows all services to use all edge routers ziti edge controller create service-edger-router-policy 'my-policy' --service-roles '#all' --edge-router-roles '#all'"
  },
  "ziti/policies/create-service-edge-router-policy-ui.html": {
    "href": "ziti/policies/create-service-edge-router-policy-ui.html",
    "title": "| Ziti",
    "keywords": "On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Edge Router Policy Choose a name for the Service Edge Router Policy, such as \"My Service Edge Router Policy\" Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save"
  },
  "ziti/policies/create-service-policy-cli.html": {
    "href": "ziti/policies/create-service-policy-cli.html",
    "title": "| Ziti",
    "keywords": "To create a Service Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service policy named 'my-policy' which allows all identities to dial/connect to all services ziti edge controller create service-policy my-policy Dial --identity-roles '#all' --service-roles '#all'"
  },
  "ziti/policies/create-service-policy-ui.html": {
    "href": "ziti/policies/create-service-policy-ui.html",
    "title": "| Ziti",
    "keywords": "On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Policy Choose a name for the Service Policy, such as \"My Service Policy\" Select \"Dial\" or \"Bind\" in the Type dropdown Dial policies allow identities to use or connect to the service Bind policies allow identities to host or provide the service Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save"
  },
  "ziti/policies/creating-edge-router-policies.html": {
    "href": "ziti/policies/creating-edge-router-policies.html",
    "title": "Creating an Edge Router Policy | Ziti",
    "keywords": "Creating an Edge Router Policy New Edge Router Policy via UI New Edge Router Policy via CLI On the left side nav bar, click \"Ziti Policies\" It should already be selected, but if not, on the top nav bar, click \"Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy, such as \"My Edge Router Policy\" Enter the edge routers you want to include in the policy Specific edge routers can be referenced by ID or name using @ . For example, an edge router called us-east-4 can be referenced using @us-east-4 . Edge routers can be referenced by role attribute using # . For example, any edge router which has the us-seast role attribute will be included if #us-east is included in the edge routers roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create an Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create an edge router policy named 'my-policy' which allows all identities to use all edge-routers ziti edge controller create edge-router-policy my-policy --identity-roles '#all' --edge-router-roles '#all'"
  },
  "ziti/policies/creating-service-edge-router-policies.html": {
    "href": "ziti/policies/creating-service-edge-router-policies.html",
    "title": "Creating a Service Policy | Ziti",
    "keywords": "Creating a Service Policy New Service Edge Router Policy via UI New Service Edge Router Policy via CLI On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Edge Router Policy Choose a name for the Service Edge Router Policy, such as \"My Service Edge Router Policy\" Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create a Service Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service edge router policy which allows all services to use all edge routers ziti edge controller create service-edger-router-policy 'my-policy' --service-roles '#all' --edge-router-roles '#all'"
  },
  "ziti/policies/creating-service-policies.html": {
    "href": "ziti/policies/creating-service-policies.html",
    "title": "Creating a Service Policy | Ziti",
    "keywords": "Creating a Service Policy New Service Policy via UI New Service Policy via CLI On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Policy Choose a name for the Service Policy, such as \"My Service Policy\" Select \"Dial\" or \"Bind\" in the Type dropdown Dial policies allow identities to use or connect to the service Bind policies allow identities to host or provide the service Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create a Service Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service policy named 'my-policy' which allows all identities to dial/connect to all services ziti edge controller create service-policy my-policy Dial --identity-roles '#all' --service-roles '#all'"
  },
  "ziti/policies/overview.html": {
    "href": "ziti/policies/overview.html",
    "title": "Policies | Ziti",
    "keywords": "Policies Ziti policies control which identities can access or host which services via which edge routers. There are three kinds of policies, and we'll walk through what kind of access each policy type grants, as well as walk through some use cases. Each policy type relates two of the following entity types: identities, services and edge routers. Service Policies Service policies are entities within the Ziti Controller which provide identities authorization to services. There are two kinds of service policies: Dial policies, which control who can use a service Bind policies, which control who can provide a service They are separate because in most cases a given identity will not both use and provide any given service, so it's important to be able to distinguish between the two privileges. Service policies are how access to application can be segmented. Each service (and corresponding application) can be accessed only by the identities which are given access to it. An identity can have access to any number of services, and it is straightforward to add or remove identities from service policies. With roles and role attributes (described below), it's easy to group entities and minimize manual maintenance of groups. Having at least one Service Policy is vital because without any service policies the Ziti network will have no identities authorized to send traffic over the Ziti network. Edge Router Policies Edge router policies are entities within the Ziti Controller which provide identities access to edge routers. In order to access or provide a service the identity must first access the Ziti network fabric. Edge routers are the points through which SDK based applications can get that access. Not every identity should necessarily be allowed to use every edge router. Identities or groups of identities may have dedicated edge routers for a number of reasons. For resource isolation due to SLAs For resource isolation because they are hosting a service Edge routers may be colocated with a set of identities A group of identities may need to use a particular version of an edge router Having at least one Edge Router Policy is necessary because without at least one, no identities will be able to send traffic over the Ziti network because traffic must enter the network via an edge router. Service Edge Router Policies Service edge router policies are entities within the Ziti Controller which provide services access to edge routers. They are similar to edge router policies except they determine via which edge routers a service can be used or provided. There are a few reasons you might want to have pools of edge routers dedicated particular services or service groups. Resource isolation due to SLAs Geographic/political boundaries. Some services may need to be accessible only from specific areas to comply with local laws Having at least one Service Edge Router Policy is vital because without at least one, no services will be able to accept traffic over the Ziti network because traffic must enter the network via an edge router. Roles and Role Attributes In order for policies to work they need a way to specify which entities to include in the policy. All Ziti policies work the same way. The entities included in policies (identities, serviced and edge routers) can all be assigned role attributes For example: an identity could be given the attributes sales , eu if that identity belongs to a sales person from the European Union Each policy has two list of roles, one for each entity type that the policy is relating Service policies have identityRoles and serviceRoles Edge router policies have identityRoles and edgeRouterRoles Service edge router policies have edgeRouterRoles and serviceRoles Each list can contain role attributes, which are prefixed by hash tags, and ids, which are prefixed with at-symbols. For example: a service policy might have identityRoles = [#sales, #north-america, @81cc68d0-700a-491f-8e98-4b43a0b30a9f] serviceRoles = [#office, @738006f2-e33e-4964-945f-7431000d229f] Note that external tools such as the CLI and the ZAC will likely use names instead of IDs. So the roles might instead look like identityRoles = [#sales, #north-america, @jsmith-laptop] serviceRoles = [#office, @crm-suite] Each policy also has a semantic. The semantic dictates how multiple role attributes will be interpreted. [#sales, #eu] could mean every identity which has #sales and #eu , or it could mean every identity which has #sales or #eu The allOf semantic will include only entities have all the listed role attributes The anyOf semantic will include all entities that have any of the listed role attributes No matter the semantic, any entities which are listed by @id will be included in the policy There is a special role attribute #all which will include all entities of a given type. This is useful for simpler setups which may not be segmenting edge routers, as well as for development and testing. Policy Interaction Important Note: When an identity is using a service, the identity and service must have at least one on-line edge router in common in order for a connection to be made. When an identity is trying to establish a session to use or host a service the Ziti controller will verify that they access via service policy. Once the session is established, the controller will return a list of edge routers that the identity can use to connect to that service. The list will be all edge routers which both the identity and service have access to. It is possible that an identity may have access to a service and access to edge routers, but none of those edge routers can be used to access that particular service. Policy Advisor To help diagnose issues there is a policy advisor API which the CLI has a wrapper for. $ ziti edge controller policy-advisor services -q OKAY : simple-client (1) -> simple (1) Common Routers: (1/1) Dial: Y Bind: N OKAY : simple-server (1) -> simple (1) Common Routers: (1/1) Dial: N Bind: Y $ ziti edge controller policy-advisor services ssh simple-client -q ERROR: simple-client (1) -> ssh (1) Common Routers: (1/1) Dial: N Bind: N - No access to service. Adjust service policies. The policy advisor can look at all services or identities, or a specific service and identity, and see if there are any common problems, such as: Does an identity not have access to any services? Does a service have no one who can access it? Do a service and identity have no edge routers in common? Do a service and identity have edge routers in common, but they are all off-line? Managing Policies Service Policies Creating a Service Policy New Service Policy via UI New Service Policy via CLI On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Policy Choose a name for the Service Policy, such as \"My Service Policy\" Select \"Dial\" or \"Bind\" in the Type dropdown Dial policies allow identities to use or connect to the service Bind policies allow identities to host or provide the service Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create a Service Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service policy named 'my-policy' which allows all identities to dial/connect to all services ziti edge controller create service-policy my-policy Dial --identity-roles '#all' --service-roles '#all' Edge Router Policies Creating an Edge Router Policy New Edge Router Policy via UI New Edge Router Policy via CLI On the left side nav bar, click \"Ziti Policies\" It should already be selected, but if not, on the top nav bar, click \"Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy, such as \"My Edge Router Policy\" Enter the edge routers you want to include in the policy Specific edge routers can be referenced by ID or name using @ . For example, an edge router called us-east-4 can be referenced using @us-east-4 . Edge routers can be referenced by role attribute using # . For example, any edge router which has the us-seast role attribute will be included if #us-east is included in the edge routers roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create an Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create an edge router policy named 'my-policy' which allows all identities to use all edge-routers ziti edge controller create edge-router-policy my-policy --identity-roles '#all' --edge-router-roles '#all' Service Edge Router Policies Creating a Service Policy New Service Edge Router Policy via UI New Service Edge Router Policy via CLI On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Edge Router Policy Choose a name for the Service Edge Router Policy, such as \"My Service Edge Router Policy\" Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create a Service Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service edge router policy which allows all services to use all edge routers ziti edge controller create service-edger-router-policy 'my-policy' --service-roles '#all' --edge-router-roles '#all'"
  },
  "ziti/quickstart.html": {
    "href": "ziti/quickstart.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "ziti/quickstarts/hsm/softhsm.html": {
    "href": "ziti/quickstarts/hsm/softhsm.html",
    "title": "SoftHSMv2 | Ziti",
    "keywords": "SoftHSMv2 Overview SoftHSMv2 is a purely software-based implementation of PKCS#11. Because it is software it is not as secure as a physical HSM but it is very useful to explore the world of PKCS#11 and how it can be used with a Ziti-enabled client. In this quickstart you will see the commands used to work with SoftHSMv2 and ziti. Since this is a quickstart limited context will be provided for each step. When appropriate there will be a small amount of context included to aid in understanding of what is happening and why. Warning This quickstart intended audience is for more technically savvy indiviuals. You will need to be familar with the command line interface of your operating system. Prerequistites SoftHSMv2 is downloaded and installed in a known location OpenSC is installed and pkcs11-tool is either on the PATH or at a known location ziti, ziti-tunnel, ziti-enroller are all on the path. Let's Do This - SoftHSMv2 Here's the list of steps we'll accomplish in this quickstart: Establish a bunch of environment variables to make it easy to copy/paste the other commands. You'll want to look at these environment variables . They need to be setup properly. If you have problems with this guide it is almost certainly because you have an environment variable setup incorrectly. Double check them. Make a directory and generate a configuration file for SoftHSM Use the Ziti CLI to: create two identities - one demonstrating an RSA key, one EC enroll the identities create a test service create test router/service policies Use the pkcs11-tool provided by OpenSC to interact with SoftHSM to: initialize the SoftHSM driver create a key Use the ziti-enroller to enroll the identities using SoftHSM Use the ziti-tunnel in proxy mode to verify things are working and traffic is flowing over the Ziti Network Establish Environment Variables Open a command line and establish the following environment varibles. Linux/MacOS Windows # the name of the ziti controller you're logging into export ZITI_CTRL=local-edge-controller # the location of the certificate(s) to use to validate the controller export ZITI_CTRL_CERT=/path/to/controller.cert export ZITI_USER=myUserName export ZITI_PWD=myPassword # a name for the configuration export HSM_NAME=softhsm_demo # the path to the root of the softhsm config files export HSM_ROOT=/home/cd/.softhsm # path to the softhsm2 library export PKCS11_MODULE=/usr/local/lib/softhsm/libsofthsm2.so # the id of the key - you probably want to leave these alone unless you know better export HSM_ID1=01 export HSM_ID2=02 # the pins used when accessing the pkcs11 api export HSM_SOPIN=1111 export HSM_PIN=2222 export RSA_ID=${HSM_NAME}${HSM_ID1}_rsa export EC_ID=${HSM_NAME}${HSM_ID2}_ec # location for the config file and tokens to be placed export HSM_DEST=${HSM_ROOT}/${HSM_NAME} export HSM_LABEL=${HSM_NAME}-label export SOFTHSM2_CONF=${HSM_DEST}/softhsm.config export HSM_TOKENS_DIR=\"${HSM_DEST}/tokens/\" # make an alias for ease alias p='pkcs11-tool --module $PKCS11_MODULE' Ensure you use the correct dll. If you use an x86 dll with x64 binaries you'll get an error. REM the name of the ziti controller you're logging into SET ZITI_CTRL=local-edge-controller REM the location of the certificate(s) to use to validate the controller SET ZITI_CTRL_CERT=c:\\path\\to\\controller.cert SET ZITI_USER=myUserName SET ZITI_PWD=myPassword REM a name for the configuration SET HSM_NAME=softhsm_demo REM the path to the root of the softhsm config files SET HSM_ROOT=c:\\path\\to\\softhsm REM path to the softhsm2 library SET PKCS11_MODULE=%HSM_ROOT%\\lib\\softhsm2.dll --- or --- SET PKCS11_MODULE=%HSM_ROOT%\\lib\\softhsm2-x64.dll REM the id of the key - you probably want to leave these alone unless you know better SET HSM_ID1=01 SET HSM_ID2=02 SET RSA_ID=%HSM_NAME%%HSM_ID1%_rsa SET EC_ID=%HSM_NAME%%HSM_ID2%_ec REM the pins used when accessing the pkcs11 api SET HSM_SOPIN=1111 SET HSM_PIN=2222 SET HSM_DEST=%HSM_ROOT%\\%HSM_NAME% SET HSM_LABEL=%HSM_NAME%-label SET SOFTHSM2_CONF=%HSM_DEST%\\softhsm.config SET HSM_TOKENS_DIR=%HSM_DEST%\\tokens\\ REM make an alias for ease doskey p=\"c:\\Program Files\\OpenSC Project\\OpenSC\\tools\\pkcs11-tool.exe\" --module %PKCS11_MODULE% $* Make Directories and Generate Config Files Linux/MacOS Windows cd ${HSM_ROOT} rm -rf ${HSM_NAME} mkdir -p ${HSM_TOKENS_DIR} cd ${HSM_NAME} # Create a text file at ${SOFTHSM2_CONF} with these contents but make sure you replace the tokendir entry with ${HSM_TOKENS_DIR} cat > ${SOFTHSM2_CONF} <<HERE # SoftHSM v2 configuration file directories.tokendir = ${HSM_TOKENS_DIR} objectstore.backend = file # ERROR, WARNING, INFO, DEBUG log.level = INFO # If CKF_REMOVABLE_DEVICE flag should be set slots.removable = false # Enable and disable PKCS#11 mechanisms using slots.mechanisms. slots.mechanisms = ALL HERE cd /d %HSM_ROOT% rmdir /s /q %HSM_NAME% mkdir %HSM_TOKENS_DIR% cd /d %HSM_NAME% # Create a text file at %SOFTHSM2_CONF% with these contents but make sure you replace the tokendir entry with %HSM_TOKENS_DIR% echo ^ # SoftHSM v2 configuration file ^ directories.tokendir = %HSM_TOKENS_DIR% ^ objectstore.backend = file ^ # ERROR, WARNING, INFO, DEBUG ^ log.level = INFO ^ # If CKF_REMOVABLE_DEVICE flag should be set ^ slots.removable = false ^ # Enable and disable PKCS#11 mechanisms using slots.mechanisms. ^ slots.mechanisms = ALL > %SOFTHSM2_CONF% Use the Ziti CLI Linux/MacOS Windows ziti edge controller login $ZITI_CTRL:1280 -u $ZITI_USER -p $ZITI_PWD -c $ZITI_CTRL_CERT # create a new identity and output the jwt to a known location ziti edge controller create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" # create a second new identity and output the jwt to a known location ziti edge controller create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\" ziti edge controller login %ZITI_CTRL%:1280 -u %ZITI_USER% -p %ZITI_PWD% -c %ZITI_CTRL_CERT% REM create a new identity and output the jwt to a known location ziti edge controller create identity device \"%RSA_ID%\" -o \"%HSM_DEST%\\%RSA_ID%.jwt\" REM create a second new identity and output the jwt to a known location ziti edge controller create identity device \"%EC_ID%\" -o \"%HSM_DEST%\\%EC_ID%.jwt\" Use pkcs11-tool to Setup SoftHSMv2 Linux/MacOS Windows p --init-token --label \"ziti-test-token\" --so-pin $HSM_SOPIN # create a couple of keys - one rsa and one ec p -p $HSM_PIN -k --key-type rsa:2048 --id \"${HSM_ID1}\" --label ziti-rsa-key --usage-sign --usage-decrypt p -p $HSM_PIN -k --key-type EC:prime256v1 --id ${HSM_ID2} --label ziti-ecdsa-key --usage-sign --usage-decrypt p --init-token --label \"ziti-test-token\" --so-pin %HSM_SOPIN% p --init-pin --pin \"%HSM_PIN%\" --so-pin %HSM_SOPIN% REM create a couple of keys - one rsa and one ec p -p \"%HSM_PIN%\" -k --key-type rsa:2048 --id \"%HSM_ID1%\" --label ziti-rsa-key --usage-sign --usage-decrypt p -p \"%HSM_PIN%\" -k --key-type EC:prime256v1 --id \"%HSM_ID2%\" --label ziti-ecdsa-key --usage-sign --usage-decrypt Use ziti-enroller to Enroll the Identities Linux/MacOS Windows ziti-enroller -j \"${HSM_DEST}/${RSA_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID1}&pin=${HSM_PIN}\" -v ziti-enroller -j \"${HSM_DEST}/${EC_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID2}&pin=${HSM_PIN}\" -v ziti-enroller -j \"%HSM_DEST%\\%RSA_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID1%&pin=%HSM_PIN%\" -v ziti-enroller -j \"%HSM_DEST%\\%EC_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID2%&pin=%HSM_PIN%\" -v Use ziti-tunnel to Verify Things Work Linux/MacOS Windows # if you only have a single edge router this command will work without the need for copy/paste EDGE_ROUTER_ID=$(ziti edge controller list edge-routers | cut -d \" \" -f2) # IF the above command doesn't work - run this command and get the id from the first edge-router. # ziti edge controller list edge-routers # then use the id returned from the above command and put it into a variable for use in a momment # EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} # remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 ziti edge controller delete config wttrconfig ziti edge controller create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will # send a request to wttr.in to retreive a weather forecast ziti edge controller delete service wttr.ziti ziti edge controller create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig # start one or both proxies ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & # use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network curl -H \"Host: wttr.in\" http://localhost:8000 curl -H \"Host: wttr.in\" http://localhost:9000 REM these two commands can't be copied and pasted - you need to get the result of the first command and use it in the next REM run this command and get the id from the first edge-router. ziti edge controller list edge-routers REM use the id returned from the above command and put it into a variable for use in a momment SET EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} REM remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 ziti edge controller delete config wttrconfig ziti edge controller create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" REM recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will REM send a request to wttr.in to retreive a weather forecast ziti edge controller delete service wttr.ziti ziti edge controller create service wttr.ziti \"%EDGE_ROUTER_ID%\" tcp://wttr.in:80 --configs wttrconfig REM start one or both proxies - use ctrl-break or ctrl-pause to terminate these processes start /b ziti-tunnel proxy -i \"%HSM_DEST%/%RSA_ID%.json\" wttr.ziti:8000 -v start /b ziti-tunnel proxy -i \"%HSM_DEST%/%EC_ID%.json\" wttr.ziti:9000 -v REM use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network curl -H \"Host: wttr.in\" http://localhost:8000 > \"%HSM_DEST%\\example_%RSA_ID%.txt\" curl -H \"Host: wttr.in\" http://localhost:9000 > \"%HSM_DEST%\\example_%EC_ID%.txt\" REM show the results in the console type \"%HSM_DEST%\\example_%RSA_ID%.txt\" type \"%HSM_DEST%\\example_%EC_ID%.txt\" REM ctrl-break or ctrl-pause to kill the tunnelers Putting It All Together Above we've only shown the commands that need to run and not what the output of those commands would look like. Here we'll see all the commands put together along with all the output from the commands. This section is long - you are warned! Also note that this content is subject to change. If the output you see is not identical it's because the software has changed since this information was captured. File an issue if you'd like to see it updated. Sample Output Linux/MacOS Windows The tabs to the right contain example output from running all the commands in sequence. If you want to see what the output would likely look like click one of the tabs to the right. Reminder - it's a lot of commands and a lot of output! :) cd@sg1 ~/.softhsm/softhsm_demo $ # the name of the ziti controller you're logging into cd@sg1 ~/.softhsm/softhsm_demo $ export ZITI_CTRL=local-edge-controller cd@sg1 ~/.softhsm/softhsm_demo $ # the location of the certificate(s) to use to validate the controller cd@sg1 ~/.softhsm/softhsm_demo $ export ZITI_CTRL_CERT=/path/to/controller.cert cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ export ZITI_USER=myUserName cd@sg1 ~/.softhsm/softhsm_demo $ export ZITI_PWD=myPassword cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # a name for the configuration cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_NAME=softhsm_demo cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # the path to the root of the softhsm config files cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_ROOT=/home/cd/.softhsm cd@sg1 ~/.softhsm/softhsm_demo $ # location for the config file and tokens to be placed cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_DEST=${HSM_ROOT}/${HSM_NAME} cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # path to the softhsm2 library cd@sg1 ~/.softhsm/softhsm_demo $ export PKCS11_MODULE=/usr/local/lib/softhsm/libsofthsm2.so cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # the id of the key - you probably want to leave these alone unless you know better cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_ID1=01 cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_ID2=02 cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # the pins used when accessing the pkcs11 api cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_SOPIN=1111 cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_PIN=2222 cd@sg1 ~/.softhsm/softhsm_demo $ export RSA_ID=${HSM_NAME}${HSM_ID1}_rsa cd@sg1 ~/.softhsm/softhsm_demo $ export EC_ID=${HSM_NAME}${HSM_ID2}_ec cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_DEST=${HSM_ROOT}/${HSM_NAME} cd@sg1 ~/.softhsm/softhsm_demo $ export SOFTHSM2_CONF=${HSM_DEST}/softhsm.config cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_LABEL=${HSM_NAME}-label cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_TOKENS_DIR=\"${HSM_DEST}/tokens/\" cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # make an alias for ease cd@sg1 ~/.softhsm/softhsm_demo $ alias p='pkcs11-tool --module $PKCS11_MODULE' cd@sg1 ~/.softhsm/softhsm_demo $ cd ${HSM_ROOT} cd@sg1 ~/.softhsm $ cd@sg1 ~/.softhsm $ rm -rf ${HSM_NAME} mkdir -p ${HSM_TOKENS_DIR} cd ${HSM_NAME} # Create a text file at ${SOFTHSM2_CONF} with these contents but make sure you replace the tokendir entry with ${HSM_TOKENS_DIR} cat > ${SOFTHSM2_CONF} <<HERE # SoftHSM v2 configuration file directories.tokendir = ${HSM_TOKENS_DIR} objectstore.backend = file # ERROR, WARNING, INFO, DEBUG log.level = INFO cd@sg1 ~/.softhsm $ mkdir -p ${HSM_TOKENS_DIR} # If CKF_REMOVABLE_DEVICE flag should be set slots.removable = false cd@sg1 ~/.softhsm $ cd@sg1 ~/.softhsm $ cd ${HSM_NAME} cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # Create a text file at ${SOFTHSM2_CONF} with these contents but make sure you replace the tokendir entry with ${HSM_TOKENS_DIR} cd@sg1 ~/.softhsm/softhsm_demo $ cat > ${SOFTHSM2_CONF} <<HERE > # SoftHSM v2 configuration file > > directories.tokendir = ${HSM_TOKENS_DIR} > objectstore.backend = file > > # ERROR, WARNING, INFO, DEBUG > log.level = INFO > > # If CKF_REMOVABLE_DEVICE flag should be set > slots.removable = false > > # Enable and disable PKCS#11 mechanisms using slots.mechanisms. > slots.mechanisms = ALL > HERE cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge controller login $ZITI_CTRL:1280 -u $ZITI_USER -p $ZITI_PWD -c $ZITI_CTRL_CERT # create a new identity and output the jwt to a known location ziti edge controller create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" # create a second new identity and output the jwt to a known location ziti edge controller create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\"Token: 28da1089-1636-4e6b-b5c7-96edc8d6162f cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # create a new identity and output the jwt to a known location cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge controller create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" dbf953bc-a987-4a89-a93d-0d6dac13150f Enrollment expires at 2020-02-23T13:31:35.306053182Z cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # create a second new identity and output the jwt to a known location cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge controller create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\" cfffe40d-b859-4a5a-ab4f-c9621a57ec85 Enrollment expires at 2020-02-23T13:31:36.676560457Z cd@sg1 ~/.softhsm/softhsm_demo $ p --init-token --label \"ziti-test-token\" --so-pin $HSM_SOPIN # create a couple of keys - one rsa and one ec p -p $HSM_PIN -k --key-type rsa:2048 --id \"${HSM_ID1}\" --label ziti-rsa-key --usage-sign --usage-decrypt p -p $HSM_PIN -k --key-type EC:prime256v1 --id ${HSM_ID2} --label ziti-ecdsa-key --usage-sign --usage-decryptUsing slot 0 with a present token (0x0) Token successfully initialized cd@sg1 ~/.softhsm/softhsm_demo $ p --init-pin --pin $HSM_PIN --so-pin $HSM_SOPIN Using slot 0 with a present token (0x7f834e53) User PIN successfully initialized cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # create a couple of keys - one rsa and one ec cd@sg1 ~/.softhsm/softhsm_demo $ p -p $HSM_PIN -k --key-type rsa:2048 --id \"${HSM_ID1}\" --label ziti-rsa-key --usage-sign --usage-decrypt Using slot 0 with a present token (0x7f834e53) Key pair generated: Private Key Object; RSA label: ziti-rsa-key ID: 01 Usage: decrypt, sign, unwrap Public Key Object; RSA 2048 bits label: ziti-rsa-key ID: 01 Usage: encrypt, verify, wrap cd@sg1 ~/.softhsm/softhsm_demo $ p -p $HSM_PIN -k --key-type EC:prime256v1 --id ${HSM_ID2} --label ziti-ecdsa-key --usage-sign --usage-decrypt Using slot 0 with a present token (0x7f834e53) Key pair generated: Private Key Object; EC label: ziti-ecdsa-key ID: 02 Usage: decrypt, sign, unwrap Public Key Object; EC EC_POINT 256 bits EC_POINT: 0441046f9ae0bbc3cbe62e6bbad50ad673add3ba1ee5a07f5391893df956c53d67c62b727ca1004fe9b44027e8e1f1605a602946257b1b1d20ba00342cec85c13a0462 EC_PARAMS: 06082a8648ce3d030107 label: ziti-ecdsa-key ID: 02 Usage: encrypt, verify, wrap cd@sg1 ~/.softhsm/softhsm_demo $ ziti-enroller -j \"${HSM_DEST}/${RSA_ID}.jwt\" -k \"pkcs11:///${PKCS11_MODULE}?id=${HSM_ID1}&pin=${HSM_PIN}\" -v DEBU[0000] jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjQ2NDY5NSwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6IjIzOTNjNDgwLTc0NGMtNDc3OS05NjU3LWNhOTdlMzUzOWQ0ZiIsInN1YiI6ImRiZjk1M2JjLWE5ODctNGE4OS1hOTNkLTBkNmRhYzEzMTUwZiJ9.OucLqJYgvGO0zov3ADI4oM0i0CASfpD6GUUAck5cBKVJqUN8jsdHe272CwnR7TH1w7uUNr5zPDJnwklVRQ0kzgxqFe9lGqNOxKtYecr-oI50K-J_OShPu_LkJ8dpmUk-OEzc1mq29KsIVu9GLUI43FLYD7SWFZZFsYk6iB8H4PPRrUNZucTcApgNNHljlwl8n-my5N3STqazJf7YUIHOh-OiW8rJFXZYf5gri_B6uDGQo-ZcMOISWCTRjPxe2boHK0ymrUanbe_i9vHbOQRIik7J6xOEA2-Vu-QW9WY4bEvl0_LChdV4YBG09EtWsJndl1AIsD0AP0fCjgD6FifAbpmiZx_YoqOM-KCbN9Vts9_FobNfT0rt9s7RzcHImj22jxEQtSNVbrjnulPwzhBM2PnOKrHJtq8KGgsGlC-aC1pUkiRS-eMHDOshDUFk16p56UXm9QS4d1rPmCQ8yksgEdeurRydmBKCr2tr1v9hC7gSxY1sOBF-b9k7HBGuinomuyeF6CRRMRYMiYz26suZXvP70ufJ5Z2h6hYqvIIGtpk_MxMuVl8r9iylWq3P7oqbDo74g3p3OSFwRUDm5llBuZKJUzQXYE3435NdpHeStKu4K2VYvGGCxpWe950ONrAGzwSYtYdOVvkgGxBreO3RNiQN427XD9yZw66pXXqIRV0 INFO[0000] using engine : pkcs11 DEBU[0000] loading key context=pkcs11 url=\"pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=01&pin=2222\" INFO[0000] using driver: //usr/local/lib/softhsm/libsofthsm2.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (2139311699) context=pkcs11 DEBU[0000] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0000] no cas provided in caPool. using system provided cas DEBU[0000] fetching certificates from server DEBU[0000] loading key context=pkcs11 url=\"pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=01&pin=2222\" INFO[0000] using driver: //usr/local/lib/softhsm/libsofthsm2.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (2139311699) context=pkcs11 DEBU[0000] found signing mechanism context=pkcs11 sign mechanism=0 enrolled successfully. identity file written to: /home/cd/.softhsm/softhsm_demo/softhsm_demo01_rsa.json cd@sg1 ~/.softhsm/softhsm_demo $ ziti-enroller -j \"${HSM_DEST}/${EC_ID}.jwt\" -k \"pkcs11:///${PKCS11_MODULE}?id=${HSM_ID2}&pin=${HSM_PIN}\" -v DEBU[0000] jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjQ2NDY5NiwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6ImJlZTJlY2U3LTE4ZTAtNGQ3Zi04NmRlLTU4NmM5MTAyNDY3YiIsInN1YiI6ImNmZmZlNDBkLWI4NTktNGE1YS1hYjRmLWM5NjIxYTU3ZWM4NSJ9.nRCE-_osr6rdVUcfyR-irvAWitCSK0pm7WaG0hOC0-O22SFs8tYw7uKvbGmNkFoVsUYK4y6A4X77Q6JPNPDIzwWl1TO788B4UiJNh6x5jFEKMawzzPbq-wGq0PLstLsULOryxRtIMdHRYaCrxspC9mIZTrIWe85iPPjirOJ0Pgq0-Li2hZmBtlFOh8zTzYGmXVQtKhA-obIDSa12Nrt6gpgpNl1Ob_EXWWkwC5rcdm4yKpiKx7wYjxBRKc4ZLODmNahe69KiG5XD9A5I5o6YWQDs-pgl3Op44U9Kk94fGSZPcgzkPUC8NaX1eWgYh6RCMs3uSp6TMi8bRisPCOW770K3CxPpCS1fKg9rpyPninFShjRMvsbf999ldWh3YKmLJXvtinQF3szbmCsVaTI4-NxlkhLcdL2Qo6ivLz_kddNfzmDFcOEcLerR0D_Ugt0mPi0RidgkX0J00uXqd1SqYyI3b68KyVd5U3hIoL8NRQ1gAluky0jSe-xj5vfTgxYiJNZlUqCA4DvGdXl98NiWu40eHEz5ksKePbB_LVCmcMW3mPNdQjmDw4fdKvfZs0FdqgOcBGzbfQznpt3UV1pgL7Kdl6EfZppP1FNjqaxHyiEqkdINY0X5k33CDV4IVuS0ZDbOuQHInfG2ggLLS_vykC37w5iJe19ECSMWd_JzgQc INFO[0000] using engine : pkcs11 DEBU[0000] loading key context=pkcs11 url=\"pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=02&pin=2222\" INFO[0000] using driver: //usr/local/lib/softhsm/libsofthsm2.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (2139311699) context=pkcs11 DEBU[0000] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0000] EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> context=pkcs11 WARN[0000] failed to get mechanism info [1044] context=pkcs11 error=\"pkcs11: 0x70: CKR_MECHANISM_INVALID\" DEBU[0000] no cas provided in caPool. using system provided cas DEBU[0000] fetching certificates from server DEBU[0000] loading key context=pkcs11 url=\"pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=02&pin=2222\" INFO[0000] using driver: //usr/local/lib/softhsm/libsofthsm2.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (2139311699) context=pkcs11 DEBU[0000] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0000] EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> context=pkcs11 WARN[0000] failed to get mechanism info [1044] context=pkcs11 error=\"pkcs11: 0x70: CKR_MECHANISM_INVALID\" enrolled successfully. identity file written to: /home/cd/.softhsm/softhsm_demo/softhsm_demo02_ec.json cd@sg1 ~/.softhsm/softhsm_demo $ # run this command and get the id from the first edge-router. cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge controller list edge-routers id: c34734a4-d5de-430b-a5dc-7fa05363b28d name: local-edge-router role attributes: {} cd@sg1 ~/.softhsm/softhsm_demo $ EDGE_ROUTER_ID=c34734a4-d5de-430b-a5dc-7fa05363b28d cd@sg1 ~/.softhsm/softhsm_demo $ # remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge controller delete config wttrconfig ziti edge controller create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will # send a request to wttr.in to retreive a weather forecast ziti edge controller delete service wttr.ziti ziti edge controller create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig # start one or both proxies ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge controller create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" 384166bd-0781-4189-ae66-6789cc1952b2 cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will cd@sg1 ~/.softhsm/softhsm_demo $ # send a request to wttr.in to retreive a weather forecast cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge controller delete service wttr.ziti cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge controller create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig eb5c5fe8-5781-4760-9962-90ab708027f2 cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # start one or both proxies cd@sg1 ~/.softhsm/softhsm_demo $ ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & [1] 14821 cd@sg1 ~/.softhsm/softhsm_demo $ ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & [2] 14822 cd@sg1 ~/.softhsm/softhsm_demo $ [ 0.005] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.007] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.006] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=02&pin=2222]} loading key [ 0.007] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: //usr/local/lib/softhsm/libsofthsm2.so [ 0.008] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=01&pin=2222]} loading key [ 0.008] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: //usr/local/lib/softhsm/libsofthsm2.so [ 0.019] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (2139311699) [ 0.020] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (2139311699) [ 0.023] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.024] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.023] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.loadECDSApub [pkcs11]: EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> [ 0.023] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.getECDSAmechanism [pkcs11]: {error=[pkcs11: 0x70: CKR_MECHANISM_INVALID]} failed to get mechanism info [1044] [ 0.025] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.024] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.060] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[de50dbc8-a00b-49aa-8fcc-285be8babdb4] id=[25692bf8-6cb1-4133-8b86-575a8ea65f09]} Got api session: {25692bf8-6cb1-4133-8b86-575a8ea65f09 de50dbc8-a00b-49aa-8fcc-285be8babdb4} [ 0.060] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token de50dbc8-a00b-49aa-8fcc-285be8babdb4 [ 0.069] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[45eae1d0-8ad0-4428-9900-c328ed9e3d23] id=[b8654830-b9e9-4450-9116-072ab4e8cca5]} Got api session: {b8654830-b9e9-4450-9116-072ab4e8cca5 45eae1d0-8ad0-4428-9900-c328ed9e3d23} [ 0.069] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 45eae1d0-8ad0-4428-9900-c328ed9e3d23 [ 0.106] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token de50dbc8-a00b-49aa-8fcc-285be8babdb4 [ 0.113] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 45eae1d0-8ad0-4428-9900-c328ed9e3d23 [ 0.160] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 0.160] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 0.160] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 0.160] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 0.160] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[eb5c5fe8-5781-4760-9962-90ab708027f2]} requesting session [ 0.170] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 0.170] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 0.170] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[eb5c5fe8-5781-4760-9962-90ab708027f2]} requesting session [ 0.200] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[a5291ddc-a86e-48c9-975e-662bc3bcb0d7]} acquired network session [ 0.200] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:8000]} service is listening [ 0.221] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[d4330d93-a6e1-4e48-91e1-cb26520f09d2]} acquired network session [ 0.222] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 0.222] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 0.222] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:9000]} service is listening jobs [1]- Running ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & [2]+ Running ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & cd@sg1 ~/.softhsm/softhsm_demo $ curl -H \"Host: wttr.in\" http://localhost:8000 [ 8.289] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started [ 8.302] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 8.302] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 8.304] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 8.304] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 8.304] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{D8nP}]: started [ 8.305] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{D8nP}]: started [ 8.306] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 8.306] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 8.544] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{D8nP}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 8.544] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 8.544] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:60053] src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel started [ 8.545] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {chSeq=[-1] edgeSeq=[1] connId=[1] type=[EdgeDataType]} writing 71 bytes [ 8.547] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8907 bytes [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes Weather report: Laurelton, United States Mist _ - _ - _ - 35..39 °F _ - _ - _ ↑ 5 mph _ - _ - _ - 3 mi 0.2 in ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Thu 13 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ .-. Light drizzle │ .-. Light drizzle │ _`/\"\".-. Moderate or he…│ _`/\"\".-. Patchy light s…│ │ ( ). 39..41 °F │ ( ). 41..46 °F │ ,\\_( ). 33..39 °F │ ,\\_( ). 30..+35 °F │ │ (___(__) ↗ 3-5 mph │ (___(__) → 8-10 mph │ /(___(__) → 7-9 mph │ /(___(__) → 6-8 mph │ │ ‘ ‘ ‘ ‘ 3 mi │ ‘ ‘ ‘ ‘ 1 mi │ * * * * 5 mi │ * * * 4 mi │ │ ‘ ‘ ‘ ‘ 0.2 in | 66% │ ‘ ‘ ‘ ‘ 0.0 in | 64% │ * * * * 0.0 in | 29% │ * * * 0.0 in | 57% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Fri 14 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ Overcast │ Cloudy │ _`/\"\".-. Patchy snow po…│ \\ / Partly cloudy │ │ .--. 8..21 °F │ .--. 12..23 °F │ ,\\_( ). 10..21 °F │ _ /\"\".-. 1..14 °F │ │ .-( ). ↘ 9-12 mph │ .-( ). ↘ 10-11 mph │ /(___(__) ↘ 11-14 mph │ \\_( ). ↓ 9-15 mph │ │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ ‘ * ‘ * 6 mi │ /(___(__) 5 mi │ │ 0.0 in | 0% │ 0.0 in | 0% │ * ‘ * ‘ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Sat 15 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Sunny │ \\ / Sunny │ Overcast │ Overcast │ │ .-. 14..17 °F │ .-. 19..24 °F │ .--. 21..30 °F │ .--. 17..26 °F │ │ ― ( ) ― → 2 mph │ ― ( ) ― ↑ 3-4 mph │ .-( ). ↑ 9-13 mph │ .-( ). ↑ 8-14 mph │ │ `-’ 6 mi │ `-’ 6 mi │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ Follow @igor_chubin for wttr.in updates [ 9.968] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:60053] src-local=[127.0.0.1:8000]} stopping pipe [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end cd@sg1 ~/.softhsm/softhsm_demo $ [ 10.969] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 10.969] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 10.969] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:8000] dst-remote=[127.0.0.1:60053]} stopping pipe [ 10.969] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {dst-remote=[wttr.ziti] src-remote=[127.0.0.1:60053] src-local=[127.0.0.1:8000] dst-local=[:1]} tunnel closed: 71 bytes sent; 8907 bytes received curl -H \"Host: wttr.in\" http://localhost:9000 [ 14.253] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started [ 14.265] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 14.265] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 14.266] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 14.266] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 14.266] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 14.266] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{DGp7}]: started [ 14.266] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 14.266] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{DGp7}]: started [ 14.405] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{DGp7}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 14.405] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 14.405] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:60058]} tunnel started [ 14.405] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 14.405] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {connId=[1] type=[EdgeDataType] chSeq=[-1] edgeSeq=[1]} writing 71 bytes [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8907 bytes [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes Weather report: Laurelton, United States Mist _ - _ - _ - 35..39 °F _ - _ - _ ↑ 5 mph _ - _ - _ - 3 mi 0.2 in ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Thu 13 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ .-. Light drizzle │ .-. Light drizzle │ _`/\"\".-. Moderate or he…│ _`/\"\".-. Patchy light s…│ │ ( ). 39..41 °F │ ( ). 41..46 °F │ ,\\_( ). 33..39 °F │ ,\\_( ). 30..+35 °F │ │ (___(__) ↗ 3-5 mph │ (___(__) → 8-10 mph │ /(___(__) → 7-9 mph │ /(___(__) → 6-8 mph │ │ ‘ ‘ ‘ ‘ 3 mi │ ‘ ‘ ‘ ‘ 1 mi │ * * * * 5 mi │ * * * 4 mi │ │ ‘ ‘ ‘ ‘ 0.2 in | 66% │ ‘ ‘ ‘ ‘ 0.0 in | 64% │ * * * * 0.0 in | 29% │ * * * 0.0 in | 57% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Fri 14 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ Overcast │ Cloudy │ _`/\"\".-. Patchy snow po…│ \\ / Partly cloudy │ │ .--. 8..21 °F │ .--. 12..23 °F │ ,\\_( ). 10..21 °F │ _ /\"\".-. 1..14 °F │ │ .-( ). ↘ 9-12 mph │ .-( ). ↘ 10-11 mph │ /(___(__) ↘ 11-14 mph │ \\_( ). ↓ 9-15 mph │ │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ ‘ * ‘ * 6 mi │ /(___(__) 5 mi │ │ 0.0 in | 0% │ 0.0 in | 0% │ * ‘ * ‘ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Sat 15 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Sunny │ \\ / Sunny │ Overcast │ Overcast │ │ .-. 14..17 °F │ .-. 19..24 °F │ .--. 21..30 °F │ .--. 17..26 °F │ │ ― ( ) ― → 2 mph │ ― ( ) ― ↑ 3-4 mph │ .-( ). ↑ 9-13 mph │ .-( ). ↑ 8-14 mph │ │ `-’ 6 mi │ `-’ 6 mi │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ Follow @igor_chubin for wttr.in updates [ 14.605] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:60058]} stopping pipe [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end cd@sg1 ~/.softhsm/softhsm_demo $ [ 15.606] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 15.606] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 15.606] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-local=[127.0.0.1:9000] dst-remote=[127.0.0.1:60058] src-remote=[wttr.ziti] src-local=[:1]} stopping pipe [ 15.606] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:60058] src-local=[127.0.0.1:9000]} tunnel closed: 71 bytes sent; 8907 bytes received jobs [1]- Running ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & [2]+ Running ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & cd@sg1 ~/.softhsm/softhsm_demo $ killall ziti-tunnel [ 21.732] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 21.731] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 21.732] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 21.731] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 21.732] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 [ 21.731] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 21.731] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 21.732] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 21.731] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 [ 21.732] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 21.731] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 21.732] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 21.731] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor [ 21.732] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor [1]- Done ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v [2]+ Done ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v cd@sg1 ~/.softhsm/softhsm_demo $ jobs cd@sg1 ~/.softhsm/softhsm_demo c:\\path\\to\\softhsm\\softhsm_demo>REM the name of the ziti controller you're logging into c:\\path\\to\\softhsm\\softhsm_demo>SET ZITI_CTRL=local-edge-controller c:\\path\\to\\softhsm\\softhsm_demo>REM the location of the certificate(s) to use to validate the controller c:\\path\\to\\softhsm\\softhsm_demo>SET ZITI_CTRL_CERT=c:\\path\\to\\controller.cert c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>SET ZITI_USER=myUserName c:\\path\\to\\softhsm\\softhsm_demo>SET ZITI_PWD=myPassword c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM a name for the configuration c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_NAME=softhsm_demo c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM the path to the root of the softhsm config files c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_ROOT=c:\\path\\to\\softhsm c:\\path\\to\\softhsm\\softhsm_demo>REM path to the softhsm2 library c:\\path\\to\\softhsm\\softhsm_demo>SET PKCS11_MODULE=%HSM_ROOT%\\lib\\softhsm2.dll c:\\path\\to\\softhsm\\softhsm_demo>--- or --- '---' is not recognized as an internal or external command, operable program or batch file. c:\\path\\to\\softhsm\\softhsm_demo>SET PKCS11_MODULE=%HSM_ROOT%\\lib\\softhsm2-x64.dll c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM the id of the key - you probably want to leave these alone unless you know better c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_ID1=01 c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_ID2=02 c:\\path\\to\\softhsm\\softhsm_demo>SET RSA_ID=%HSM_NAME%%HSM_ID1%_rsa c:\\path\\to\\softhsm\\softhsm_demo>SET EC_ID=%HSM_NAME%%HSM_ID2%_ec c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM the pins used when accessing the pkcs11 api c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_SOPIN=1111 c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_PIN=2222 c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_DEST=%HSM_ROOT%\\%HSM_NAME% c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_LABEL=%HSM_NAME%-label c:\\path\\to\\softhsm\\softhsm_demo>SET SOFTHSM2_CONF=%HSM_DEST%\\softhsm.config c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_TOKENS_DIR=%HSM_DEST%\\tokens\\ c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM make an alias for ease c:\\path\\to\\softhsm\\softhsm_demo>doskey p=\"c:\\Program Files\\OpenSC Project\\OpenSC\\tools\\pkcs11-tool.exe\" --module %PKCS11_MODULE% $* c:\\path\\to\\softhsm\\softhsm_demo>cd /d %HSM_ROOT% c:\\path\\to\\softhsm> c:\\path\\to\\softhsm>rmdir /s /q %HSM_NAME% c:\\path\\to\\softhsm>mkdir %HSM_TOKENS_DIR% c:\\path\\to\\softhsm> c:\\path\\to\\softhsm>cd /d %HSM_NAME% c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo># Create a text file at %SOFTHSM2_CONF% with these contents but make sure you replace the tokendir entry with %HSM_TOKENS_DIR% '#' is not recognized as an internal or external command, operable program or batch file. c:\\path\\to\\softhsm\\softhsm_demo>echo ^ More? # SoftHSM v2 configuration file ^ More? More? directories.tokendir = %HSM_TOKENS_DIR% ^ More? More? objectstore.backend = file ^ More? More? # ERROR, WARNING, INFO, DEBUG ^ More? More? log.level = INFO ^ More? More? # If CKF_REMOVABLE_DEVICE flag should be set ^ More? More? slots.removable = false ^ More? More? # Enable and disable PKCS#11 mechanisms using slots.mechanisms. ^ More? More? slots.mechanisms = ALL > %SOFTHSM2_CONF% c:\\path\\to\\softhsm\\softhsm_demo>ziti edge controller login %ZITI_CTRL%:1280 -u %ZITI_USER% -p %ZITI_PWD% -c %ZITI_CTRL_CERT% Token: c6f4d504-6095-4118-8f13-3c787821963f c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM create a new identity and output the jwt to a known location c:\\path\\to\\softhsm\\softhsm_demo>ziti edge controller create identity device \"%RSA_ID%\" -o \"%HSM_DEST%\\%RSA_ID%.jwt\" a625ee46-b799-4e9f-a92c-59a579cb9756 Enrollment expires at 2020-02-23T14:22:08.902166003Z c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM create a second new identity and output the jwt to a known location c:\\path\\to\\softhsm\\softhsm_demo>ziti edge controller create identity device \"%EC_ID%\" -o \"%HSM_DEST%\\%EC_ID%.jwt\" 08889f51-1639-4cd0-9c18-ffcc5e315f3e Enrollment expires at 2020-02-23T14:22:09.634832703Z c:\\path\\to\\softhsm\\softhsm_demo>p --init-token --label \"ziti-test-token\" --so-pin %HSM_SOPIN% Using slot 0 with a present token (0x0) Token successfully initialized c:\\path\\to\\softhsm\\softhsm_demo>p --init-pin --pin \"%HSM_PIN%\" --so-pin %HSM_SOPIN% Using slot 0 with a present token (0x1af2a063) User PIN successfully initialized c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM create a couple of keys - one rsa and one ec c:\\path\\to\\softhsm\\softhsm_demo>p -p \"%HSM_PIN%\" -k --key-type rsa:2048 --id \"%HSM_ID1%\" --label ziti-rsa-key --usage-sign --usage-decrypt Using slot 0 with a present token (0x1af2a063) Key pair generated: Private Key Object; RSA label: ziti-rsa-key ID: 01 Usage: decrypt, sign, unwrap Access: sensitive, always sensitive, never extractable, local Public Key Object; RSA 2048 bits label: ziti-rsa-key ID: 01 Usage: encrypt, verify, wrap Access: local c:\\path\\to\\softhsm\\softhsm_demo>p -p \"%HSM_PIN%\" -k --key-type EC:prime256v1 --id \"%HSM_ID2%\" --label ziti-ecdsa-key --usage-sign --usage-decrypt Using slot 0 with a present token (0x1af2a063) Key pair generated: Private Key Object; EC label: ziti-ecdsa-key ID: 02 Usage: decrypt, sign, unwrap Access: sensitive, always sensitive, never extractable, local Public Key Object; EC EC_POINT 256 bits EC_POINT: 04410419240eaf1e7628c94dbb3ab46f0b4c5b3fe8bab8227b67ed9bdea6d107547c16ac401437f674c73986697cc2c0e4ae0416775ee8ec0b65f1fe6c935acdc4b35a EC_PARAMS: 06082a8648ce3d030107 label: ziti-ecdsa-key ID: 02 Usage: encrypt, verify, wrap Access: local c:\\path\\to\\softhsm\\softhsm_demo>ziti-enroller -j \"%HSM_DEST%\\%RSA_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID1%&pin=%HSM_PIN%\" -v time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjQ2NzcyOCwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6IjQwZjE5Y2VhLWFjYWYtNDQyMy1iNzhjLWI2NjU4MDA0NGI2MSIsInN1YiI6ImE2MjVlZTQ2LWI3OTktNGU5Zi1hOTJjLTU5YTU3OWNiOTc1NiJ9.LkziWbgKeJtZ6f5dd169K32Gq86-6ly13v7iHn7Zj_ITFudxXzLa2dl3JonBRg6hNW8ghiPNZ7JpcSkRiaN8npKUHAnsZfr1kPE-NR-eJmUTqM88UhznQJOKyAZzA-dLxRfsRgmU9ESLVsAQEE4wefPz8AlsXWGYK9oWx-X0SEwu4TgjCWP1jEd7pQJXw5ZXIBYLZMG0buIFaKgskH-inpK7BF2LZc9ENr6nj4W4X_tm7kbzGdQ-ofzlhJMBHFz2w_qQXDqXiYWf59Wrszd9-3y0rbvykmc9L8G3B1YlICKyD6mhaPt4fLquZEOwsyeOgH9BLJhX9I33nfYZe_mQf4jzhw5U13K1VKaL-JGwfXntwrKMUJhB62NDMLNALMDqc4hK3BKp1wdZT5YL2Y91J2lLa50mg0OG9ASvkmh7dW3FhDFntl9UnSuPmVJExfMJJCXwe0DgbLcg0TugUuioJ9iCrAZ2tTsLoXDIqLj4zqDhe2nCXdTGgqGpa2ftqNWsUxJmZM2V8ll8Mb2tcuNu0WHcpZ1nH9iXuNHWRsLyowIZB0NJoIvYRlHzlPiSjJxZlNdMSh2jm6tZ7_sAyw_cIAU20yJ3KSGE2PT9bCgkISiYEZ2V5Q3cyGIi0OMP7IqZ5vomqHhkF41C4LIH7A4NKCWMztTwt-WOIndGX5yB1GA\" time=\"2020-02-13T09:22:18-05:00\" level=info msg=\"using engine : pkcs11\\n\" time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=01&pin=2222\" time=\"2020-02-13T09:22:18-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\softhsm\\\\lib\\\\softhsm2-x64.dll\" context=pkcs11 time=\"2020-02-13T09:22:18-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (452108387)\" context=pkcs11 time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"no cas provided in caPool. using system provided cas\" time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"fetching certificates from server\" time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=01&pin=2222\" time=\"2020-02-13T09:22:18-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\softhsm\\\\lib\\\\softhsm2-x64.dll\" context=pkcs11 time=\"2020-02-13T09:22:18-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (452108387)\" context=pkcs11 time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 enrolled successfully. identity file written to: c:\\path\\to\\softhsm\\softhsm_demo\\softhsm_demo01_rsa.json c:\\path\\to\\softhsm\\softhsm_demo>ziti-enroller -j \"%HSM_DEST%\\%EC_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID2%&pin=%HSM_PIN%\" -v time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjQ2NzcyOSwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6ImU0NDhlMGVjLTk4Y2ItNDBjMC05MmE4LWE2YjMyZDJlY2UwMCIsInN1YiI6IjA4ODg5ZjUxLTE2MzktNGNkMC05YzE4LWZmY2M1ZTMxNWYzZSJ9.HHlGcNPh1E83SG3ncCzIPLpav4fRZ44eAeq9Igr24CHT3TCJXXooFNVY5LYtTJ3ydsE6RVPn3UCrP_72CK4Y8Bc-OHDxtPsl0wQwH90tYIz68d2Br0D8kBjjLnYNfsQS0w4t9GEdnNLD8WfjIF8V1croBksrA0jyDiZFak67tKwohzftmm7bNNibA2KvNFVSa_ZaD1lT-SR5xEHaTkR4LpBhPSN9HeR6TAj0c0LsFgFAm_4LrX14r3eufCxxj0TIEHPvxqa_dMJq3TuUFQQPvSIStnXKd9i4gTnFhFdxeZ4J4R94IT6UdzAVD1lIBA9tta7XrMgKpG7Yl8OX60rh3je4S73WAff4kZg6gFpL2RckHuCGdn4AoAXPJoFqBerQ3xybAVNW913fxtw942juVBhjb4Ex2LzZylkRrQmJ3xV5s3-MuW8-1-2N1lK5u1JK_sulrCx5trrvFb99z2INnNh0baVFq_7-3KozVsE0RNiXGc5dAjhNFWJWXT9H6PhIzzJ-0l84ZQaloxon1b70LnoVPC8g2z-Psvv8-Pc2JIlg5K4DLIXsagD4n4S1Fh8aqAyduF5Sc7ddVQ20-8Fz8iIZXNEGvNa9KwuHVzrk3UZJ3cB7Q1oWDshHPcMd7B4AtyV4z9U4qUP7syyAYkGYrMT_F26uNmIb0s2eW6xDf68\" time=\"2020-02-13T09:22:19-05:00\" level=info msg=\"using engine : pkcs11\\n\" time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=02&pin=2222\" time=\"2020-02-13T09:22:19-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\softhsm\\\\lib\\\\softhsm2-x64.dll\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (452108387)\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil>\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=warning msg=\"failed to get mechanism info [1044]\" context=pkcs11 error=\"pkcs11: 0x70: CKR_MECHANISM_INVALID\" time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"no cas provided in caPool. using system provided cas\" time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"fetching certificates from server\" time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=02&pin=2222\" time=\"2020-02-13T09:22:19-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\softhsm\\\\lib\\\\softhsm2-x64.dll\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (452108387)\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil>\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=warning msg=\"failed to get mechanism info [1044]\" context=pkcs11 error=\"pkcs11: 0x70: CKR_MECHANISM_INVALID\" enrolled successfully. identity file written to: c:\\path\\to\\softhsm\\softhsm_demo\\softhsm_demo02_ec.json c:\\path\\to\\softhsm\\softhsm_demo>REM run this command and get the id from the first edge-router. c:\\path\\to\\softhsm\\softhsm_demo>ziti edge controller list edge-routers id: 727f0074-9011-4b79-955b-a6a9e3bb67b1 name: local-edge-router role attributes: {} c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM use the id returned from the above command and put it into a variable for use in a momment c:\\path\\to\\softhsm\\softhsm_demo>SET EDGE_ROUTER_ID=727f0074-9011-4b79-955b-a6a9e3bb67b1 c:\\path\\to\\softhsm\\softhsm_demo>REM remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 c:\\path\\to\\softhsm\\softhsm_demo>ziti edge controller delete config wttrconfig c:\\path\\to\\softhsm\\softhsm_demo>ziti edge controller create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" 7e73d98c-e44f-4360-9a48-6d1c812f0a75 c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will c:\\path\\to\\softhsm\\softhsm_demo>REM send a request to wttr.in to retreive a weather forecast c:\\path\\to\\softhsm\\softhsm_demo>ziti edge controller delete service wttr.ziti c:\\path\\to\\softhsm\\softhsm_demo>ziti edge controller create service wttr.ziti \"%EDGE_ROUTER_ID%\" tcp://wttr.in:80 --configs wttrconfig 04ccec0c-3329-4f8f-8942-9dbd378bb15e c:\\path\\to\\softhsm\\softhsm_demo>REM start one or both proxies - use ctrl-break or ctrl-pause to terminate these processes c:\\path\\to\\softhsm\\softhsm_demo>start /b ziti-tunnel proxy -i \"%HSM_DEST%/%RSA_ID%.json\" wttr.ziti:8000 -v c:\\path\\to\\softhsm\\softhsm_demo>[ 0.026] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.027] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=01&pin=2222]} loading key [ 0.028] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: c:\\path\\to\\softhsm\\lib\\softhsm2-x64.dll [ 0.036] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (452108387) [ 0.043] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.044] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.079] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {id=[087afe19-9c8b-40f4-88c9-962d9e04f1b8] token=[28c9472d-8540-413d-9f8e-532139dfbdcb]} Got api session: {087afe19-9c8b-40f4-88c9-962d9e04f1b8 28c9472d-8540-413d-9f8e-532139dfbdcb} [ 0.080] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 28c9472d-8540-413d-9f8e-532139dfbdcb [ 0.124] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 28c9472d-8540-413d-9f8e-532139dfbdcb [ 0.166] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 0.166] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 0.167] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 0.169] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 0.169] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[04ccec0c-3329-4f8f-8942-9dbd378bb15e]} requesting session [ 0.203] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[4b9096a5-4bef-4296-813d-252aebe7ebe6]} acquired network session [ 0.203] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:8000]} service is listening start /b ziti-tunnel proxy -i \"%HSM_DEST%/%EC_ID%.json\" wttr.ziti:9000 -v c:\\path\\to\\softhsm\\softhsm_demo>[ 0.017] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.017] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=02&pin=2222]} loading key [ 0.018] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: c:\\path\\to\\softhsm\\lib\\softhsm2-x64.dll [ 0.026] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (452108387) [ 0.034] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.034] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.loadECDSApub [pkcs11]: EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> [ 0.035] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.getECDSAmechanism [pkcs11]: {error=[pkcs11: 0x70: CKR_MECHANISM_INVALID]} failed to get mechanism info [1044] [ 0.037] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.074] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[68289015-5910-464f-8c1f-4870c28cfbb1] id=[32d29510-6285-4cff-80b3-a9630ffef388]} Got api session: {32d29510-6285-4cff-80b3-a9630ffef388 68289015-5910-464f-8c1f-4870c28cfbb1} [ 0.074] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 68289015-5910-464f-8c1f-4870c28cfbb1 [ 0.123] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 68289015-5910-464f-8c1f-4870c28cfbb1 [ 0.162] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 0.163] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 0.164] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[04ccec0c-3329-4f8f-8942-9dbd378bb15e]} requesting session [ 0.204] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[d09009a6-a2b2-405b-8125-8f9c021ff8de]} acquired network session [ 0.204] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 0.206] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 0.207] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {addr=[0.0.0.0:9000] service=[wttr.ziti]} service is listening c:\\path\\to\\softhsm\\softhsm_demo>curl -H \"Host: wttr.in\" http://localhost:8000 > \"%HSM_DEST%\\example_%RSA_ID%.txt\" [ 14.743] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Spee[ 14.758] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates d[ 14.758] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 14.759] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 14.759] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 14.760] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{PpLP}]: started [ 14.760] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 14.761] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 14.761] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{PpLP}]: started 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0[ 14.874] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{PpLP}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 14.874] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 14.875] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:62125] src-local=[127.0.0.1:8000]} tunnel started [ 14.878] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {edgeSeq=[1] connId=[1] type=[EdgeDataType] chSeq=[-1]} writing 71 bytes [ 14.879] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 15.057] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {connId=[1] seq=[1]} handling received EdgeDataType [ 15.057] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8964 bytes [ 15.058] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes 100 8799 100 8799 0 0 28111 0 --:--:-- --:--:-- --:--:-- 28111 [ 15.067] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[127.0.0.1:62125] src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti]} stopping pipe [ 15.067] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 15.069] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 15.069] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 15.070] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end c:\\path\\to\\softhsm\\softhsm_demo>[ 16.070] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 16.070] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 16.071] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-remote=[127.0.0.1:62125] src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:8000]} stopping pipe [ 16.072] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {dst-remote=[wttr.ziti] src-remote=[127.0.0.1:62125] src-local=[127.0.0.1:8000] dst-local=[:1]} tunnel closed: 71 bytes sent; 8964 bytes received c:\\path\\to\\softhsm\\softhsm_demo> curl -H \"Host: wttr.in\" http://localhost:9000 > \"%HSM_DEST%\\example_%EC_ID%.txt\" [ 18.776] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started % Total % Received % Xferd Average Speed Time Time Time Current [ 18.785] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 18.785] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 18.786] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 18.786] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 18.787] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 18.787] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{15kP}]: started [ 18.789] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 18.789] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{15kP}]: started Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0[ 18.902] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{15kP}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 18.903] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 18.904] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:62130] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel started [ 18.905] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {type=[EdgeDataType] chSeq=[-1] edgeSeq=[1] connId=[1]} writing 71 bytes [ 18.906] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0[ 19.334] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 19.335] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8964 bytes [ 19.336] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes 100 8799 100 8799 0 0 15628 0 --:--:-- --:--:-- --:--:-- 15628 [ 19.344] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[127.0.0.1:62130] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} stopping pipe [ 19.344] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 19.345] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 19.347] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 19.349] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>[ 20.345] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 20.345] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 20.347] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:62130] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel closed: 71 bytes sent; 8964 bytes received [ 20.349] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-local=[127.0.0.1:9000] dst-remote=[127.0.0.1:62130] src-remote=[wttr.ziti] src-local=[:1]} stopping pipe tpye \"%HSM_DEST%\\example_%RSA_ID%.txt\" 'tpye' is not recognized as an internal or external command, operable program or batch file. c:\\path\\to\\softhsm\\softhsm_demo>type \"%HSM_DEST%\\example_%RSA_ID%.txt\" Weather report: Laurelton, United States Mist _ - _ - _ - 35..39 °F _ - _ - _ ↑ 5 mph _ - _ - _ - 3 mi 0.0 in ┌─────────────┐ ┌────────────────��─────────────┬───────────────────────┤ Thu 13 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ .-. Light rain │ .-. Light rain │ _`/\"\".-. Moderate or he…│ \\ / Partly cloudy │ │ ( ). 35..37 °F │ ( ). 39..41 °F │ ,\\_( ). 32..39 °F │ _ /\"\".-. 26..+33 °F │ │ (___(__) ↑ 4-6 mph │ (___(__) ↗ 5-6 mph │ /(___(__) → 8-10 mph │ \\_( ). → 9-14 mph │ │ ‘ ‘ ‘ ‘ 5 mi │ ‘ ‘ ‘ ‘ 5 mi │ * * * * 5 mi │ /(___(__) 4 mi │ │ ‘ ‘ ‘ ‘ 0.1 in | 79% │ ‘ ‘ ‘ ‘ 0.0 in | 80% │ * * * * 0.0 in | 25% │ 0.0 in | 51% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Fri 14 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼─────────────────────────────��┼──────────────────────────────┤ │ \\ / Partly cloudy │ \\ / Sunny │ \\ / Partly cloudy │ \\ / Clear │ │ _ /\"\".-. 3..17 °F │ .-. 6..19 °F │ _ /\"\".-. 8..19 °F │ .-. 5..14 °F │ │ \\_( ). ↘ 11-13 mph │ ― ( ) ― ↘ 11-13 mph │ \\_( ). ↗ 9-12 mph │ ― ( ) ― ↓ 7-11 mph │ │ /(___(__) 6 mi │ `-’ 6 mi │ /(___(__) 6 mi │ `-’ 6 mi │ │ 0.0 in | 0% │ / \\ 0.0 in | 0% │ 0.0 in | 0% │ / \\ 0.0 in | 0% │ └───────────────────��──────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Sat 15 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├────────────���─────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Sunny │ \\ / Sunny │ \\ / Partly cloudy │ \\ / Partly cloudy │ │ .-. 12..17 °F │ .-. 17..24 °F │ _ /\"\".-. 21..30 °F │ _ /\"\".-. 15..24 °F │ │ ― ( ) ― ↑ 3-4 mph │ ― ( ) ― ↑ 6-7 mph │ \\_( ). ↑ 8-13 mph │ \\_( ). ↑ 7-14 mph │ │ `-’ 6 mi │ `-’ 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ Follow @igor_chubin for wttr.in updates c:\\path\\to\\softhsm\\softhsm_demo>type \"%HSM_DEST%\\example_%EC_ID%.txt\" Weather report: Laurelton, United States Mist _ - _ - _ - 35..39 °F _ - _ - _ ↑ 5 mph _ - _ - _ - 3 mi 0.0 in ┌─────────────┐ ┌────────────────��─────────────┬───────────────────────┤ Thu 13 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ .-. Light rain │ .-. Light rain │ _`/\"\".-. Moderate or he…│ \\ / Partly cloudy │ │ ( ). 35..37 °F │ ( ). 39..41 °F │ ,\\_( ). 32..39 °F │ _ /\"\".-. 26..+33 °F │ │ (___(__) ↑ 4-6 mph │ (___(__) ↗ 5-6 mph │ /(___(__) → 8-10 mph │ \\_( ). → 9-14 mph │ │ ‘ ‘ ‘ ‘ 5 mi │ ‘ ‘ ‘ ‘ 5 mi │ * * * * 5 mi │ /(___(__) 4 mi │ │ ‘ ‘ ‘ ‘ 0.1 in | 79% │ ‘ ‘ ‘ ‘ 0.0 in | 80% │ * * * * 0.0 in | 25% │ 0.0 in | 51% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Fri 14 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼─────────────────────────────��┼──────────────────────────────┤ │ \\ / Partly cloudy │ \\ / Sunny │ \\ / Partly cloudy │ \\ / Clear │ │ _ /\"\".-. 3..17 °F │ .-. 6..19 °F │ _ /\"\".-. 8..19 °F │ .-. 5..14 °F │ │ \\_( ). ↘ 11-13 mph │ ― ( ) ― ↘ 11-13 mph │ \\_( ). ↗ 9-12 mph │ ― ( ) ― ↓ 7-11 mph │ │ /(___(__) 6 mi │ `-’ 6 mi │ /(___(__) 6 mi │ `-’ 6 mi │ │ 0.0 in | 0% │ / \\ 0.0 in | 0% │ 0.0 in | 0% │ / \\ 0.0 in | 0% │ └───────────────────��──────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Sat 15 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├────────────���─────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Sunny │ \\ / Sunny │ \\ / Partly cloudy │ \\ / Partly cloudy │ │ .-. 12..17 °F │ .-. 17..24 °F │ _ /\"\".-. 21..30 °F │ _ /\"\".-. 15..24 °F │ │ ― ( ) ― ↑ 3-4 mph │ ― ( ) ― ↑ 6-7 mph │ \\_( ). ↑ 8-13 mph │ \\_( ). ↑ 7-14 mph │ │ `-’ 6 mi │ `-’ 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ Follow @igor_chubin for wttr.in updates c:\\path\\to\\softhsm\\softhsm_demo>"
  },
  "ziti/quickstarts/hsm/yubikey.html": {
    "href": "ziti/quickstarts/hsm/yubikey.html",
    "title": "YubiKey by Yubico | Ziti",
    "keywords": "YubiKey by Yubico Yubico is a manufacturer of HSM deviceis. A popular line of HSM produced by Yubico is the YubiKey. This quickstart guide will use specific device from Yubico - the YubiKey 5 nfc . Overview The YubiKey 5 nfc is a multi-purpose device with a few different security-minded uses. One of the applications on the device is an application called PIV or \"Personal Identity Verification\". PIV is a standard published by NIST and describes the kinds of credentials which make up the standard. PIV credentials have certificates and key pairs, pin numbers, biometrics like fingerprints and pictures, and other unique identifiers. When put together into a PIV credential, it provides the capability to implement multi-factor authentication for networks, applications and buildings. In this quickstart you will see the commands and tools needed to use a YubiKey 5 nfc with a Ziti Network. This document is intended to serve as a quickstart. That means limited context will be provided for each step. When appropriate there will be a small amount of context or a comment included to aid in understanding of what is happening and why. Most if not all of these commands are easily searched for using your search engine of choice. Warning This quickstart intended audience is for more technically savvy indiviuals. You will need to be familar with the command line interface of your operating system. Prerequistites YubiKey 5 nfc - clearly you'll need one in order to use this quickstart! OpenSC is installed and pkcs11-tool is either on the PATH or at a known location. Not required however this quickstart uses the pkcs11-tool to illustrate that the device is PKCS#11 compliant. HSM manufacturers will generally provide a similar tool and often expand it's usage. See more below. yubico-piv-tool - YubiKey privides a similar tool to the pkcs11-tool . This tool is needed to be installed because it contains the pkcs#11 module (driver) for the HSM. As this is a tool specific to Yubico we've chosen to not use this in the following commands. Ensure the YubiKey is factory reset. To avoid any compliations with existing information in the YubiKey ensure the device is factory reset using the YubiKey Manager . In order to successfully use the YubiKey the libraries provided by the yubico-piv-tool MUST either be on the path or in a common location that is known to the OS. On linux this is likely done by the YubiKey software installation but on Windows you'll need to take any additional actions highlighted in the Windows-specific sections. Linux Only: If you're using linux - you'll need to follow the build instructions provided by Yubico. Before you can do anything with the Yubikey you'll need to make sure the libykcs11.so exists on your system. When creating this quickstart the library was built to ./yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so . Ubuntu was used to test this guide. An attempt was also made with linux mint however the attempt failed when trying to compile the Yubikey software and was aborted. It would likely have worked if enough effort was put into discovering why that linux variant had issues pulling and compiling the necessary software. If you see strange errors when following this guide and are not using Ubuntu it may be related. ziti, ziti-tunnel, ziti-enroller are all on the path. Let's Use the YubiKey! Here's the list of steps we'll accomplish in this quickstart: Establish a bunch of environment variables to make it easy to copy/paste the other commands. You'll want to look at these environment variables . They need to be setup properly. If you have problems with this guide it is almost certainly because you have an environment variable setup incorrectly. Double check them. Make a directory and generate a configuration files for Ziti Use the Ziti CLI to: create two identities - one demonstrating an RSA key, one EC enroll the identities create a test service create test router/service policies Use the pkcs11-tool provided by OpenSC to interact with the YubiKey to: initialize the PIV app create a key Use the ziti-enroller to enroll the identities using the YubiKey Use the ziti-tunnel in proxy mode to verify things are working and traffic is flowing over the Ziti Network Warning Do NOT use id 2 or 02 for any keys you add. Id 02 corresponds to the YubiKey's \"Management Key\". You will not be able to write a key into this location. The error you will see will indicate: CKR_USER_NOT_LOGGED_IN . Establish Environment Variables Open a command line and establish the following environment varibles. Note that for the YubiKey we do not use id 02 as it appears to be reserved by the YubiKey. The default SOPIN and PIN are used as well. When using the YubiKey Manager software the \"SO PIN\" corresponds to the \"Management Key\" while \"pin\" is the same both here and in the YubiKey Manager. Linux/MacOS Windows # the name of the ziti controller you're logging into export ZITI_CTRL=local-edge-controller # the location of the certificate(s) to use to validate the controller export ZITI_CTRL_CERT=/path/to/controller.cert export ZITI_USER=myUserName export ZITI_PWD=myPassword # a name for the configuration export HSM_NAME=yubikey_demo # path to the yubikey pkcs11 libraries export HSM_ROOT=/path/to/yubico-piv-tool-2.0.0 export PKCS11_MODULE=${HSM_ROOT}/ykcs11/.libs/libykcs11.so # the id of the key - you probably want to leave these alone unless you know better export HSM_ID1=01 export HSM_ID2=03 # the pins used when accessing the pkcs11 api export HSM_SOPIN=010203040506070801020304050607080102030405060708 export HSM_PIN=123456 export RSA_ID=${HSM_NAME}${HSM_ID1}_rsa export EC_ID=${HSM_NAME}${HSM_ID2}_ec # location for the config files to be placed export HSM_DEST=${HSM_ROOT}/${HSM_NAME} export HSM_LABEL=${HSM_NAME}-label # make an alias for ease alias p='pkcs11-tool --module $PKCS11_MODULE' Warning Ensure you use the correct dll. If you use an x86 dll with x64 binaries you'll get an error. Warning With Windows - make sure you update the path to include the folder of libykcs11-1.dll as additional libraries are needed by the pkcs11 driver! REM the name of the ziti controller you're logging into SET ZITI_CTRL=local-edge-controller REM the location of the certificate(s) to use to validate the controller SET ZITI_CTRL_CERT=c:\\path\\to\\controller.cert SET ZITI_USER=myUserName SET ZITI_PWD=myPassword REM a name for the configuration SET HSM_NAME=yubikey_windemo REM the path to the root of the yubikey piv tool SET HSM_ROOT=c:\\path\\to\\yubico-piv-tool-2.0.0 REM path to the pkcs11 library SET PATH=%PATH%;%HSM_ROOT%\\bin SET PKCS11_MODULE=%HSM_ROOT%\\bin\\libykcs11-1.dll REM the id of the key - you probably want to leave these alone unless you know better SET HSM_ID1=01 SET HSM_ID2=03 SET RSA_ID=%HSM_NAME%%HSM_ID1%_rsa SET EC_ID=%HSM_NAME%%HSM_ID2%_ec REM the pins used when accessing the pkcs11 api SET HSM_SOPIN=010203040506070801020304050607080102030405060708 SET HSM_PIN=123456 SET HSM_DEST=%HSM_ROOT%\\%HSM_NAME% SET HSM_LABEL=%HSM_NAME%-label SET HSM_TOKENS_DIR=%HSM_DEST%\\tokens\\ REM make an alias for ease doskey p=\"c:\\Program Files\\OpenSC Project\\OpenSC\\tools\\pkcs11-tool.exe\" --module %PKCS11_MODULE% $* Make Directories for Config Files Linux/MacOS Windows cd ${HSM_ROOT} rm -rf ${HSM_NAME} mkdir -p ${HSM_NAME} cd ${HSM_NAME} cd /d %HSM_ROOT% rmdir /s /q %HSM_NAME% mkdir %HSM_NAME% cd /d %HSM_NAME% Use the Ziti CLI Linux/MacOS Windows ziti edge controller login $ZITI_CTRL:1280 -u $ZITI_USER -p $ZITI_PWD -c $ZITI_CTRL_CERT # create a new identity and output the jwt to a known location ziti edge controller create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" # create a second new identity and output the jwt to a known location ziti edge controller create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\" ziti edge controller login %ZITI_CTRL%:1280 -u %ZITI_USER% -p %ZITI_PWD% -c %ZITI_CTRL_CERT% REM create a new identity and output the jwt to a known location ziti edge controller create identity device \"%RSA_ID%\" -o \"%HSM_DEST%\\%RSA_ID%.jwt\" REM create a second new identity and output the jwt to a known location ziti edge controller create identity device \"%EC_ID%\" -o \"%HSM_DEST%\\%EC_ID%.jwt\" Use pkcs11-tool to Setup the YubiKey Linux/MacOS Windows p --init-token --label \"ziti-test-token\" --so-pin $HSM_SOPIN # create a couple of keys - one rsa and one ec p -k --key-type rsa:2048 --usage-sign --usage-decrypt --login --id $HSM_ID1 --login-type so --so-pin $HSM_SOPIN --label defaultkey p -k --key-type EC:prime256v1 --usage-sign --usage-decrypt --login --id $HSM_ID2 --login-type so --so-pin $HSM_SOPIN --label defaultkey p --init-token --label \"ziti-test-token\" --so-pin %HSM_SOPIN% REM create a couple of keys - one rsa and one ec p -k --key-type rsa:2048 --usage-sign --usage-decrypt --login --id %HSM_ID1% --login-type so --so-pin %HSM_SOPIN% --label defaultkey p -k --key-type EC:prime256v1 --usage-sign --usage-decrypt --login --id %HSM_ID2% --login-type so --so-pin %HSM_SOPIN% --label defaultkey Use ziti-enroller to Enroll the Identities Linux/MacOS Windows ziti-enroller -j \"${HSM_DEST}/${RSA_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID1}&pin=${HSM_PIN}\" -v ziti-enroller -j \"${HSM_DEST}/${EC_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID2}&pin=${HSM_PIN}\" -v ziti-enroller -j \"%HSM_DEST%\\%RSA_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID1%&pin=%HSM_PIN%\" -v ziti-enroller -j \"%HSM_DEST%\\%EC_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID2%&pin=%HSM_PIN%\" -v Use ziti-tunnel to Verify Things Work Linux/MacOS Windows # if you only have a single edge router this command will work without the need for copy/paste EDGE_ROUTER_ID=$(ziti edge controller list edge-routers | cut -d \" \" -f2) # IF the above command doesn't work - run this command and get the id from the first edge-router. # ziti edge controller list edge-routers # then use the id returned from the above command and put it into a variable for use in a momment # EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} # remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 ziti edge controller delete config wttrconfig ziti edge controller create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will # send a request to wttr.in to retreive a weather forecast ziti edge controller delete service wttr.ziti ziti edge controller create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig # start one or both proxies ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & # use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network curl -H \"Host: wttr.in\" http://localhost:8000 curl -H \"Host: wttr.in\" http://localhost:9000 REM these two commands can't be copied and pasted - you need to get the result of the first command and use it in the next REM run this command and get the id from the first edge-router. ziti edge controller list edge-routers REM use the id returned from the above command and put it into a variable for use in a momment SET EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} REM remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 ziti edge controller delete config wttrconfig ziti edge controller create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" REM recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will REM send a request to wttr.in to retreive a weather forecast ziti edge controller delete service wttr.ziti ziti edge controller create service wttr.ziti \"%EDGE_ROUTER_ID%\" tcp://wttr.in:80 --configs wttrconfig REM start one or both proxies - use ctrl-break or ctrl-pause to terminate these processes start /b ziti-tunnel proxy -i \"%HSM_DEST%/%RSA_ID%.json\" wttr.ziti:8000 -v start /b ziti-tunnel proxy -i \"%HSM_DEST%/%EC_ID%.json\" wttr.ziti:9000 -v REM use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network curl -H \"Host: wttr.in\" http://localhost:8000 > \"%HSM_DEST%\\example_%RSA_ID%.txt\" curl -H \"Host: wttr.in\" http://localhost:9000 > \"%HSM_DEST%\\example_%EC_ID%.txt\" REM set the codepage for the cmd prompt so that the output looks nice chcp 65001 REM show the results in the console type \"%HSM_DEST%\\example_%RSA_ID%.txt\" type \"%HSM_DEST%\\example_%EC_ID%.txt\" REM ctrl-break or ctrl-pause to kill the tunnelers Putting It All Together Above we've only shown the commands that need to run and not what the output of those commands would look like. Here we'll see all the commands put together along with all the output from the commands. This section is long - you are warned! Also note that this content is subject to change. If the output you see is not identical it's because the software has changed since this information was captured. File an issue if you'd like to see it updated. Sample Output Linux/MacOS Windows The tabs to the right contain example output from running all the commands in sequence. If you want to see what the output would likely look like click one of the tabs to the right. Reminder - it's a lot of commands and a lot of output! :) -- coming soon-- cd@cd-ubuntuvm: # the name of the ziti controller you're logging into cd@cd-ubuntuvm: export ZITI_CTRL=local-edge-controller cd@cd-ubuntuvm: # the location of the certificate(s) to use to validate the controller cd@cd-ubuntuvm: export ZITI_CTRL_CERT=/path/to/controller.cert cd@cd-ubuntuvm: cd@cd-ubuntuvm: export ZITI_USER=myUserName cd@cd-ubuntuvm: export ZITI_PWD=myPassword cd@cd-ubuntuvm: cd@cd-ubuntuvm: # a name for the configuration cd@cd-ubuntuvm: export HSM_NAME=yubikey_demo cd@cd-ubuntuvm: cd@cd-ubuntuvm: # path to the yubikey pkcs11 libraries cd@cd-ubuntuvm: export HSM_ROOT=/path/to/yubico-piv-tool-2.0.0 cd@cd-ubuntuvm: export PKCS11_MODULE=${HSM_ROOT}/ykcs11/.libs/libykcs11.so cd@cd-ubuntuvm: cd@cd-ubuntuvm: # the id of the key - you probably want to leave these alone unless you know better cd@cd-ubuntuvm: export HSM_ID1=01 cd@cd-ubuntuvm: export HSM_ID2=03 cd@cd-ubuntuvm: cd@cd-ubuntuvm: # the pins used when accessing the pkcs11 api cd@cd-ubuntuvm: export HSM_SOPIN=010203040506070801020304050607080102030405060708 cd@cd-ubuntuvm: export HSM_PIN=123456 cd@cd-ubuntuvm: export RSA_ID=${HSM_NAME}${HSM_ID1}_rsa cd@cd-ubuntuvm: export EC_ID=${HSM_NAME}${HSM_ID2}_ec cd@cd-ubuntuvm: cd@cd-ubuntuvm: # location for the config files to be placed cd@cd-ubuntuvm: export HSM_DEST=${HSM_ROOT}/${HSM_NAME} cd@cd-ubuntuvm: export HSM_LABEL=${HSM_NAME}-label cd@cd-ubuntuvm: cd@cd-ubuntuvm: # make an alias for ease cd@cd-ubuntuvm: alias p='pkcs11-tool --module $PKCS11_MODULE' cd@cd-ubuntuvm: cd ${HSM_ROOT} rm -rf ${HSM_NAME} cd@cd-ubuntuvm: cd@cd-ubuntuvm: rm -rf ${HSM_NAME} mkdir -p ${HSM_NAME} cd@cd-ubuntuvm: mkdir -p ${HSM_NAME} cd@cd-ubuntuvm: cd@cd-ubuntuvm: cd ${HSM_NAME} cd@cd-ubuntuvm: ziti edge controller login $ZITI_CTRL:1280 -u $ZITI_USER -p $ZITI_PWD -c $ZITI_CTRL_CERT # create a new identity and output the jwt to a known location ziti edge controller create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" # create a second new identity and output the jwt to a known location ziti edge controller create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\"Token: 7083e601-cc2f-4636-94c0-959174e76264 cd@cd-ubuntuvm: cd@cd-ubuntuvm: # create a new identity and output the jwt to a known location cd@cd-ubuntuvm: ziti edge controller create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" 76877717-9bce-4f34-ae7a-2ce313b8267a Enrollment expires at 2020-02-24T14:56:19.961322754Z cd@cd-ubuntuvm: cd@cd-ubuntuvm: # create a second new identity and output the jwt to a known location cd@cd-ubuntuvm: ziti edge controller create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\" bdd18e58-e474-4ed3-98eb-c68ed96377be Enrollment expires at 2020-02-24T14:56:21.673599433Z cd@cd-ubuntuvm: p --init-token --label \"ziti-test-token\" --so-pin $HSM_SOPIN p -k --key-type rsa:2048 --usage-sign --usage-decrypt --login --id $HSM_ID1 --login-type so --so-pin $HSM_SOPIN --label defaultkey p -k --key-type EC:prime256v1 --usage-sign --usage-decrypt --login --id $HSM_ID2 --login-type so --so-pin $HSM_SOPIN --label defaultkeyUsing slot 0 with a present token (0x0) Token successfully initialized cd@cd-ubuntuvm: cd@cd-ubuntuvm: # create a couple of keys - one rsa and one ec cd@cd-ubuntuvm: p -k --key-type rsa:2048 --usage-sign --usage-decrypt --login --id $HSM_ID1 --login-type so --so-pin $HSM_SOPIN --label defaultkey Using slot 0 with a present token (0x0) Key pair generated: Private Key Object; RSA label: Private key for PIV Authentication ID: 01 Usage: decrypt, sign Public Key Object; RSA 2048 bits label: Public key for PIV Authentication ID: 01 Usage: encrypt, verify cd@cd-ubuntuvm: p -k --key-type EC:prime256v1 --usage-sign --usage-decrypt --login --id $HSM_ID2 --login-type so --so-pin $HSM_SOPIN --label defaultkey Using slot 0 with a present token (0x0) Key pair generated: Private Key Object; EC label: Private key for Key Management ID: 03 Usage: decrypt, sign Public Key Object; EC EC_POINT 256 bits EC_POINT: 044104ee01d2c979d4050a2f6e357b2cbe518c3adf816cb08c5b3116318b9cc92328213bb923ea1a3ce9bc46093ffec03912b1e7eda679287fd65419e47d337ca0bb8c EC_PARAMS: 06082a8648ce3d030107 label: Public key for Key Management ID: 03 Usage: encrypt, verify cd@cd-ubuntuvm: ziti-enroller -j \"${HSM_DEST}/${RSA_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID1}&pin=${HSM_PIN}\" -v DEBU[0000] jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjU1NjE3OSwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6Ijk5NjVlZmQzLTliMjItNDk3ZS04NDdiLTM1NWI3MjE1NTZjMyIsInN1YiI6Ijc2ODc3NzE3LTliY2UtNGYzNC1hZTdhLTJjZTMxM2I4MjY3YSJ9.ohrYUZQK5xum-70AYARu8hYYxhvA9Cm2rEln6jVp8VDvMLRuIQi9bXNO1e2NQtkZLGzo3akg4Brx_QxM-9SIRKdBDYzgaN_otpV6y9XAQjVlarVvtA1bBA9OfQU1SyVGNkkaA2l660cY5gfsGb5TqBQt6wQ7KvMfzZvPhXFdQAMoXW-O2OaRh3jJGPne29-Hoz_thObv5PMTVlCGpzO6tKKfPnoV9p8HchjLHMMybEZO_xITyY_6UmkOPpeSJHdjWxJdkXu0xT8wC9PzAXK2xYYwgmW4yA8ygz2RJP6gXYd5maD-f1jgh87ELeN5dG2ksuy5Fh3_kyFAGg1X7dSnfmXSA0fWH-YPK54aSJe2fcCIt41O9pnqwepPT_7nCB4wSxVhuIugUBh_wYeJzXKI8tVnyv8nLyWhYqMwKRqTtiJM7EtxpBUPD6E35x3d4bw_fkVJ5z36NOIaGRmqhltPIsYMaFDwIE-nUU714Ra-cf8xN9lHuNoi_4Ehf8sR2YwLTsk7mJ9TKZkhLIj2KgwjL2KNCoM9n6MQtJJMq3Ae6H_xVxi2-DA_9zkbusdNi2j11OoIAtBGJQ4ONC5ekRsp_bTbb9GAxF-fO8oAQeFUXWyCpywRV8gT3G4huAlcofZTDnMtcyVvTJbvs8zYRtBM9jCKpUOmHuzb4FefgU-6kP0 INFO[0000] using engine : pkcs11 DEBU[0000] loading key context=pkcs11 url=\"pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=01&pin=123456\" INFO[0000] using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (0) context=pkcs11 DEBU[0001] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0001] no cas provided in caPool. using system provided cas DEBU[0001] fetching certificates from server DEBU[0001] loading key context=pkcs11 url=\"pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=01&pin=123456\" INFO[0001] using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so context=pkcs11 WARN[0002] slot not specified, using first slot reported by the driver (0) context=pkcs11 DEBU[0002] found signing mechanism context=pkcs11 sign mechanism=0 enrolled successfully. identity file written to: /path/to/yubico-piv-tool-2.0.0/yubikey_demo/yubikey_demo01_rsa.jsoncd@cd-ubuntuvm: ziti-enroller -j \"${HSM_DEST}/${EC_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID2}&pin=${HSM_PIN}\" -v DEBU[0000] jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjU1NjE4MSwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6IjQwYTg1NmMxLWFiZmItNDQ4ZS1hN2E3LWE3YjZkMzVmYWU4OSIsInN1YiI6ImJkZDE4ZTU4LWU0NzQtNGVkMy05OGViLWM2OGVkOTYzNzdiZSJ9.o5hGXqZXWUuj-zkg-Xd335AbZUe9zNtvQmhE4cNFZNw40eRXNTBeFntLWjWv7-41AtsHbPwmQgWQfDdHS8JuLbhLS-8ZNSL3ZThBwnTiKtgYQvg_aArcu1FbPiw3jdiiHqXu0JoIToCEFX4kMjAJIZlzRi05J0d5w6Wvvjy3V7SqT_8viLla6l3PXsa1_xnHCc89HebuKB_qYds-XO2JvXTOFP0A3dSe6UgierjrTPvRxLMbf8TIfSOFtAc6bbSy17H8S0XrNiL-1bA9Ja9KKpB_ynGTygpM3h1vXda0niJN-_TpPdTX9kFEXOn-DpvAGKW8X6ggPlnpF7Rmfx9AEarA9ft-nRjx4Z4vyoAlukSc7LfnjAqTg9CCsN0-hKB1d1PnAOuWfHP5IZ2w1zibcUvdRQMoW2Twk_P75MP8rjr19VtZu5bDweZjP10-eHt3_QYeujaylBfb7VkJuRtSyh6IeWAb-IlIaJx7hzjGqssqNPn0vqVdf43Sc0h-PJcVTOkNPpcBIbxHPL5IVyujCWUSj4NUSgVh72uQIKjxC-WrkT8i-hEnGbJRYUL2NDcS190yt21AJAAkDPBTiFA_LR0aR7lEPzQV-lsjJzjmta7V460OKATsU8oo82_S8dVv8oYndk2kRboVsCWvR7_6H95CEnmRjAfI0Emxwkg1raA INFO[0000] using engine : pkcs11 DEBU[0000] loading key context=pkcs11 url=\"pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=03&pin=123456\" INFO[0000] using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (0) context=pkcs11 DEBU[0001] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0001] EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> context=pkcs11 DEBU[0001] no cas provided in caPool. using system provided cas DEBU[0001] fetching certificates from server DEBU[0001] loading key context=pkcs11 url=\"pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=03&pin=123456\" INFO[0001] using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so context=pkcs11 WARN[0001] slot not specified, using first slot reported by the driver (0) context=pkcs11 DEBU[0001] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0001] EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> context=pkcs11 enrolled successfully. identity file written to: /path/to/yubico-piv-tool-2.0.0/yubikey_demo/yubikey_demo03_ec.jsoncd@cd-ubuntuvm: cd@cd-ubuntuvm: # if you only have a single edge router this command will work without the need for copy/paste cd@cd-ubuntuvm: EDGE_ROUTER_ID=$(ziti edge controller list edge-routers | cut -d \" \" -f2) # IF the above command doesn't work - run this command and get the id from the first edge-router. # ziti edge controller list edge-routers # then use the id returned from the above command and put it into a variable for use in a momment # EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} # remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 ziti edge controller delete config wttrconfig ziti edge controller create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will cd@cd-ubuntuvm: cd@cd-ubuntuvm: # IF the above command doesn't work - run this command and get the id from the first edge-router. cd@cd-ubuntuvm: # ziti edge controller list edge-routers cd@cd-ubuntuvm: cd@cd-ubuntuvm: # then use the id returned from the above command and put it into a variable for use in a momment cd@cd-ubuntuvm: # EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} cd@cd-ubuntuvm: cd@cd-ubuntuvm: # remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 cd@cd-ubuntuvm: ziti edge controller delete config wttrconfig ziti edge controller delete service wttr.ziti ziti edge controller create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig # start one or both proxies ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & cd@cd-ubuntuvm: ziti edge controller create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" 4ff768fa-0e7e-4b4d-ab4e-5c5aec5bd28d cd@cd-ubuntuvm: cd@cd-ubuntuvm: # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will cd@cd-ubuntuvm: # send a request to wttr.in to retreive a weather forecast cd@cd-ubuntuvm: ziti edge controller delete service wttr.ziti cd@cd-ubuntuvm: ziti edge controller create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig 1827c649-9ba6-4f5a-b122-a8cb9d4e4893 cd@cd-ubuntuvm: cd@cd-ubuntuvm: # start one or both proxies cd@cd-ubuntuvm: ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & [1] 5969 cd@cd-ubuntuvm: ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & [2] 5970 cd@cd-ubuntuvm: [ 0.001] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.001] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.002] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=03&pin=123456]} loading key [ 0.002] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so [ 0.004] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=01&pin=123456]} loading key [ 0.004] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so [ 0.085] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (0) [ 1.793] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 1.793] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.loadECDSApub [pkcs11]: EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> [ 1.793] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 1.912] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[426a9b25-5f9c-4d3d-9319-30096cb584fc] id=[30b4cc4a-1e71-4e34-971c-bd5bead0477b]} Got api session: {30b4cc4a-1e71-4e34-971c-bd5bead0477b 426a9b25-5f9c-4d3d-9319-30096cb584fc} [ 1.912] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 426a9b25-5f9c-4d3d-9319-30096cb584fc [ 1.956] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 426a9b25-5f9c-4d3d-9319-30096cb584fc [ 2.000] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 2.000] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 2.000] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[1827c649-9ba6-4f5a-b122-a8cb9d4e4893]} requesting session [ 2.033] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {id=[ee783e84-c888-4912-ba1b-b79334590d3e] service=[wttr.ziti]} acquired network session [ 2.034] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 2.034] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 2.034] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:9000]} service is listening [ 2.038] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (0) [ 3.863] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 3.864] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 4.099] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[a2d721d4-4b4a-466f-b310-b7eabd539e75] id=[deaf5b97-e467-431a-9f16-4546e4ef42fc]} Got api session: {deaf5b97-e467-431a-9f16-4546e4ef42fc a2d721d4-4b4a-466f-b310-b7eabd539e75} [ 4.099] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token a2d721d4-4b4a-466f-b310-b7eabd539e75 [ 4.146] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token a2d721d4-4b4a-466f-b310-b7eabd539e75 [ 4.189] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 4.189] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 4.189] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 4.189] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 4.189] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[1827c649-9ba6-4f5a-b122-a8cb9d4e4893]} requesting session [ 4.222] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[a53212ef-404e-4528-9d36-02852db9c595]} acquired network session [ 4.222] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:8000]} service is listening cd@cd-ubuntuvm: cd@cd-ubuntuvm: # use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network cd@cd-ubuntuvm: curl -H \"Host: wttr.in\" http://localhost:8000 [ 12.111] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started [ 12.315] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 12.315] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 12.316] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 12.316] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 12.316] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 12.316] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 12.316] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{oEzq}]: started [ 12.316] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{oEzq}]: started [ 12.557] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{oEzq}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 12.557] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 12.557] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:41838] src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel started [ 12.558] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {connId=[1] type=[EdgeDataType] chSeq=[-1] edgeSeq=[1]} writing 71 bytes [ 12.558] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 12.735] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 12.735] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8852 bytes [ 12.735] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes Weather report: Laurelton, United States Overcast .--. 14..24 °F .-( ). ↘ 13 mph (___.__)__) 9 mi 0.0 in ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Fri 14 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Partly cloudy │ \\ / Sunny │ \\ / Clear │ \\ / Clear │ │ _ /\"\".-. 6..19 °F │ .-. 8..21 °F │ .-. 8..19 °F │ .-. 3..14 °F │ │ \\_( ). ↘ 11-13 mph │ ― ( ) ― ↘ 11-13 mph │ ― ( ) ― ↗ 11-13 mph │ ― ( ) ― ↓ 8-13 mph │ │ /(___(__) 5 mi │ `-’ 6 mi │ `-’ 6 mi │ `-’ 6 mi │ │ 0.0 in | 0% │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Sat 15 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Sunny │ \\ / Partly cloudy │ \\ / Partly cloudy │ \\ / Partly cloudy │ │ .-. 14..17 °F │ _ /\"\".-. 17..24 °F │ _ /\"\".-. 21..30 °F │ _ /\"\".-. 17..24 °F │ │ ― ( ) ― ↖ 3 mph │ \\_( ). ↑ 6-8 mph │ \\_( ). ↑ 9-14 mph │ \\_( ). ↑ 8-14 mph │ │ `-’ 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ │ / \\ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Sun 16 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Partly cloudy │ \\ / Partly cloudy │ Overcast │ Overcast │ │ _ /\"\".-. 24..30 °F │ _ /\"\".-. 35..39 °F │ .--. 37..39 °F │ .--. 32..33 °F │ │ \\_( ). ↗ 4-7 mph │ \\_( ). ↗ 7-8 mph │ .-( ). → 6-9 mph │ .-( ). ↗ 3-8 mph │ │ /(___(__) 6 mi │ /(___(__) 6 mi │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ Follow @igor_chubin for wttr.in updates [ 12.735] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-remote=[wttr.ziti] src-remote=[127.0.0.1:41838] src-local=[127.0.0.1:8000] dst-local=[:1]} stopping pipe [ 12.735] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 12.735] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 12.736] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 12.736] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end cd@cd-ubuntuvm: [ 13.736] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 13.736] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 13.736] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-remote=[127.0.0.1:41838] src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:8000]} stopping pipe [ 13.736] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:41838] src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel closed: 71 bytes sent; 8852 bytes received cd@cd-ubuntuvm: cd@cd-ubuntuvm: curl -H \"Host: wttr.in\" http://localhost:9000 [ 17.991] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started [ 18.099] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 18.099] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 18.100] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 18.100] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 18.100] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 18.100] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 18.100] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{Jn2J}]: started [ 18.100] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{Jn2J}]: started [ 18.211] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{Jn2J}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 18.211] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 18.211] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {dst-remote=[wttr.ziti] src-remote=[127.0.0.1:57980] src-local=[127.0.0.1:9000] dst-local=[:1]} tunnel started [ 18.211] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {connId=[1] type=[EdgeDataType] chSeq=[-1] edgeSeq=[1]} writing 71 bytes [ 18.211] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8852 bytes [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes Weather report: Laurelton, United States Overcast .--. 14..24 °F .-( ). ↘ 13 mph (___.__)__) 9 mi 0.0 in ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Fri 14 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Partly cloudy │ \\ / Sunny │ \\ / Clear │ \\ / Clear │ │ _ /\"\".-. 6..19 °F │ .-. 8..21 °F │ .-. 8..19 °F │ .-. 3..14 °F │ │ \\_( ). ↘ 11-13 mph │ ― ( ) ― ↘ 11-13 mph │ ― ( ) ― ↗ 11-13 mph │ ― ( ) ― ↓ 8-13 mph │ │ /(___(__) 5 mi │ `-’ 6 mi │ `-’ 6 mi │ `-’ 6 mi │ │ 0.0 in | 0% │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Sat 15 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Sunny │ \\ / Partly cloudy │ \\ / Partly cloudy │ \\ / Partly cloudy │ │ .-. 14..17 °F │ _ /\"\".-. 17..24 °F │ _ /\"\".-. 21..30 °F │ _ /\"\".-. 17..24 °F │ │ ― ( ) ― ↖ 3 mph │ \\_( ). ↑ 6-8 mph │ \\_( ). ↑ 9-14 mph │ \\_( ). ↑ 8-14 mph │ │ `-’ 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ │ / \\ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Sun 16 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Partly cloudy │ \\ / Partly cloudy │ Overcast │ Overcast │ │ _ /\"\".-. 24..30 °F │ _ /\"\".-. 35..39 °F │ .--. 37..39 °F │ .--. 32..33 °F │ │ \\_( ). ↗ 4-7 mph │ \\_( ). ↗ 7-8 mph │ .-( ). → 6-9 mph │ .-( ). ↗ 3-8 mph │ │ /(___(__) 6 mi │ /(___(__) 6 mi │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ Follow @igor_chubin for wttr.in updates [ 18.379] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:57980] src-local=[127.0.0.1:9000]} stopping pipe [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end cd@cd-ubuntuvm: [ 19.382] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 19.382] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 19.382] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-remote=[127.0.0.1:57980] src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:9000]} stopping pipe [ 19.383] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:57980] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel closed: 71 bytes sent; 8852 bytes received cd@cd-ubuntuvm: killall ziti-tunnel [ 25.856] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 25.856] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 25.856] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 25.856] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 cd@cd-ubuntuvm: [ 25.856] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 25.856] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 25.856] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 25.856] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM the name of the ziti controller you're logging into c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET ZITI_CTRL=local-edge-controller c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM the location of the certificate(s) to use to validate the controller c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET ZITI_CTRL_CERT=c:\\path\\to\\controller.cert c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET ZITI_USER=myUserName c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET ZITI_PWD=myPassword c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM a name for the configuration c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_NAME=yubikey_windemo c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_ROOT=c:\\path\\to\\yubico-piv-tool-2.0.0 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM path to the pkcs11 library c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET PATH=%PATH%;%HSM_ROOT%\\bin c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET PKCS11_MODULE=%HSM_ROOT%\\bin\\libykcs11-1.dll c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM the id of the key - you probably want to leave these alone unless you know better c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_ID1=01 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_ID2=03 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET RSA_ID=%HSM_NAME%%HSM_ID1%_rsa c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET EC_ID=%HSM_NAME%%HSM_ID2%_ec c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM the pins used when accessing the pkcs11 api c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_SOPIN=010203040506070801020304050607080102030405060708 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_PIN=123456 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_DEST=%HSM_ROOT%\\%HSM_NAME% c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_LABEL=%HSM_NAME%-label c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_TOKENS_DIR=%HSM_DEST%\\tokens\\ c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM make an alias for ease c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>doskey p=\"c:\\Program Files\\OpenSC Project\\OpenSC\\tools\\pkcs11-tool.exe\" --module %PKCS11_MODULE% $* c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>cd /d %HSM_ROOT% c:\\path\\to\\yubico-piv-tool-2.0.0> c:\\path\\to\\yubico-piv-tool-2.0.0>rmdir /s /q %HSM_NAME% c:\\path\\to\\yubico-piv-tool-2.0.0>mkdir %HSM_NAME% c:\\path\\to\\yubico-piv-tool-2.0.0> c:\\path\\to\\yubico-piv-tool-2.0.0>cd /d %HSM_NAME% c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge controller login %ZITI_CTRL%:1280 -u %ZITI_USER% -p %ZITI_PWD% -c %ZITI_CTRL_CERT% Token: 2e4b9d55-fe89-4e35-8101-7d8a5f492b8b c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM create a new identity and output the jwt to a known location c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge controller create identity device \"%RSA_ID%\" -o \"%HSM_DEST%\\%RSA_ID%.jwt\" 43b76397-c65e-43a9-a326-b58f83cacfea Enrollment expires at 2020-02-24T14:47:02.783676578Z c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM create a second new identity and output the jwt to a known location c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge controller create identity device \"%EC_ID%\" -o \"%HSM_DEST%\\%EC_ID%.jwt\" fa116b87-d322-4058-a8c1-d41f21a9e051 Enrollment expires at 2020-02-24T14:47:03.521726623Z c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>p --init-token --label \"ziti-test-token\" --so-pin %HSM_SOPIN% Using slot 0 with a present token (0x0) Token successfully initialized c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM create a couple of keys - one rsa and one ec c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>p -k --key-type rsa:2048 --usage-sign --usage-decrypt --login --id %HSM_ID1% --login-type so --so-pin %HSM_SOPIN% --label defaultkey Using slot 0 with a present token (0x0) Key pair generated: Private Key Object; RSA label: Private key for PIV Authentication ID: 01 Usage: decrypt, sign Access: sensitive, always sensitive, never extractable, local Public Key Object; RSA 2048 bits label: Public key for PIV Authentication ID: 01 Usage: encrypt, verify Access: local c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>p -k --key-type EC:prime256v1 --usage-sign --usage-decrypt --login --id %HSM_ID2% --login-type so --so-pin %HSM_SOPIN% --label defaultkey Using slot 0 with a present token (0x0) Key pair generated: Private Key Object; EC label: Private key for Key Management ID: 03 Usage: decrypt, sign Access: sensitive, always sensitive, never extractable, local Public Key Object; EC EC_POINT 256 bits EC_POINT: 044104c5f6b528121fbe67e44dc2f966a2df9df97d5e712e40fdf6df74ba8c166d069d0eee65886c115034821b3e3c3c890e910ffe05efc70d281e531ae8073915f579 EC_PARAMS: 06082a8648ce3d030107 label: Public key for Key Management ID: 03 Usage: encrypt, verify Access: local c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti-enroller -j \"%HSM_DEST%\\%RSA_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID1%&pin=%HSM_PIN%\" -v time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjU1NTYyMiwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6ImYwYjIxZjQ4LTk3N2QtNDVlZi04ZDZlLWY5YzllMzlkYTg1YSIsInN1YiI6IjQzYjc2Mzk3LWM2NWUtNDNhOS1hMzI2LWI1OGY4M2NhY2ZlYSJ9.lAfmkZb_3-qPtW4hWaaHsL_7rZiHlN3LKGIrudX4K91idw5C-AdcjT-smbfSlDBqmZElU0iomrmT4TJ3SbGM9yRhrnRZBgsbC76dKO6sbNuCEGLeMJ_pJFGo7ZZC32wLm2HsvCXszwjMXOrr1ndvWUKs3KkUhvmbBEIA4x566McsngeZ5B4ILso4BmL4KJcef-n-PuI14V42n7uzOu_KZomEGSNZ34LCg0cbWcsUmoeV8d3Vgb3xSR16wyyl7tC_pGvH1qPvaWmNUQ9BWk1j730C6RXLHZ3zECOUXqIjYTOaXkoDEpuXceNF5gNm9Cx76UwpKJlSEyD_LFbkULJL4_zmKy9w9JreSUh6cnkPW7ltXluEt-Wy1VckkwOPUCRXCQ_AuxvClhOPUW_Y-PW8Qbooou7eo8v-ZPAuFqx04_DkPdhMPn2h6CyZiqEM5ZqN_ln-Q6BAUgpBHmAFUuPDnCXk0R1l74Yc23z55hrfFreR9-t4BGl6ZBiV9oAa6kz4-8MTkg_osGJOAn3S0T_mFORCES68dppVAF9Lv8kaFkZsJE3pyQeApyYqtIZWZUUiQH4S3ssFfwuoy9KmP9lvSo4Ampl7whygx6B6nf5EiSvkQyvNPSW1L5VQeI3eShQbrUHVnrBMY2BQHa86Wqz6ICdSLQHW1P_Z6yX71HKa06A\" time=\"2020-02-14T09:47:46-05:00\" level=info msg=\"using engine : pkcs11\\n\" time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=01&pin=123456\" time=\"2020-02-14T09:47:46-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\yubico-piv-tool-2.0.0\\\\bin\\\\libykcs11-1.dll\" context=pkcs11 time=\"2020-02-14T09:47:46-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (0)\" context=pkcs11 time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"no cas provided in caPool. using system provided cas\" time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"fetching certificates from server\" time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=01&pin=123456\" time=\"2020-02-14T09:47:46-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\yubico-piv-tool-2.0.0\\\\bin\\\\libykcs11-1.dll\" context=pkcs11 time=\"2020-02-14T09:47:46-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (0)\" context=pkcs11 time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 enrolled successfully. identity file written to: c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo\\yubikey_windemo01_rsa.json c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti-enroller -j \"%HSM_DEST%\\%EC_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID2%&pin=%HSM_PIN%\" -v time=\"2020-02-14T09:47:47-05:00\" level=debug msg=\"jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjU1NTYyMywiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6ImY1NzVkZTI0LTcyYzctNDcxZS1hMzI0LTUyMjE3ZWFlYmExNCIsInN1YiI6ImZhMTE2Yjg3LWQzMjItNDA1OC1hOGMxLWQ0MWYyMWE5ZTA1MSJ9.cMyzS7o4ou2XUN6d3C-fx6i7sleIZO5b_LeqOxBNkAZO6l7JFIAp54ak8TUYD-chsVnSZ-bYPiuO-lbPIR2UrZvN6SshOowiQpAKQPggL2y0UZJAqzRoxfzlkjBZXi5BjRSTGTW3nRd9y40AwR_aAkOr4IztYbREGBYvfTK4QX-NSVvSoGVCiBeKFC6PO_8nuAUxMgL_ODVpPVA1ThO5l6Jzut_N5LgysaxTjp8WWsAIvUIbnIxJ7y_hTvmKFQ9hbLuTLaWZ091AA-469dxzbMzQVe_xDSwpQDGfYgRm02_uRlKUlm_w_sPdytaNb54u0I0-la83r31S8ugyGz3xMD-xLDHVKwxZ7dUArQf3oKzGZNhCc6MMJQBI81jbHaeSCNlpDJugYDDG0bx1E87cU7Nt88h-jaLOwEOqozsG_4myhoFaMRGx-unNP8Lr-zlPtU3AGMTu21AvCq4CCg0HYLdKVjCkQ3m6N29wOrMgF_3G_hdvTLDTeHY2wKnJIBHg3lg106a7J6WtiM9CyS_N_01kCtwFWK49662GQPv6_IVb6eKokhtcA4-2E1F6H8v5BCUljzfjpfQ4EQds7uDtQSL3i3muBLuXkLUW86H98q8XVnQZms_41T2n6MWmo5smOYrs4--rM1R-in3lmKymd8nmmN-L2GuJF5zsRaiq0r4\" time=\"2020-02-14T09:47:47-05:00\" level=info msg=\"using engine : pkcs11\\n\" time=\"2020-02-14T09:47:47-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=03&pin=123456\" time=\"2020-02-14T09:47:47-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\yubico-piv-tool-2.0.0\\\\bin\\\\libykcs11-1.dll\" context=pkcs11 time=\"2020-02-14T09:47:47-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (0)\" context=pkcs11 time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil>\" context=pkcs11 time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"no cas provided in caPool. using system provided cas\" time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"fetching certificates from server\" time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=03&pin=123456\" time=\"2020-02-14T09:47:48-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\yubico-piv-tool-2.0.0\\\\bin\\\\libykcs11-1.dll\" context=pkcs11 time=\"2020-02-14T09:47:48-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (0)\" context=pkcs11 time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil>\" context=pkcs11 enrolled successfully. identity file written to: c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo\\yubikey_windemo03_ec.json c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM these two commands can't be copied and pasted - you need to get the result of the first command and use it in the next c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM run this command and get the id from the first edge-router. c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge controller list edge-routers id: 0c2c2049-3577-479c-aa09-625fa0e15d31 name: local-edge-router role attributes: {} c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM use the id returned from the above command and put it into a variable for use in a momment c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET EDGE_ROUTER_ID=0c2c2049-3577-479c-aa09-625fa0e15d31 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge controller delete config wttrconfig c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge controller create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" b2c7af06-072d-4ff2-9f73-8d1456a16d5a c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM send a request to wttr.in to retreive a weather forecast c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge controller delete service wttr.ziti c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge controller create service wttr.ziti \"%EDGE_ROUTER_ID%\" tcp://wttr.in:80 --configs wttrconfig 5a11bfce-b716-4d7a-944b-ea72e6225549 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM start one or both proxies - use ctrl-break or ctrl-pause to terminate these processes c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>start /b ziti-tunnel proxy -i \"%HSM_DEST%/%RSA_ID%.json\" wttr.ziti:8000 -v c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>start /b ziti-tunnel proxy -i \"%HSM_DEST%/%EC_ID%.json\" wttr.ziti:9000 -v c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM[ 0.013] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.013] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=01&pin=123456]} loading key [ 0.014] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: c:\\path\\to\\yubico-piv-tool-2.0.0\\bin\\libykcs11-1.dll [ 0.012] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.012] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=03&pin=123456]} loading key [ 0.013] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: c:\\path\\to\\yubico-piv-tool-2.0.0\\bin\\libykcs11-1.dll [ 0.025] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (0) [ 0.195] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (0) [ 0.688] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.689] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.699] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.699] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.loadECDSApub [pkcs11]: EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> [ 0.700] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.812] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[3b8bbb76-5984-495e-94cd-9752fe6a4d61] id=[55a4e9aa-eb78-4a19-a685-92aa19fd7177]} Got api session: {55a4e9aa-eb78-4a19-a685-92aa19fd7177 3b8bbb76-5984-495e-94cd-9752fe6a4d61} [ 0.813] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 3b8bbb76-5984-495e-94cd-9752fe6a4d61 [ 0.866] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 3b8bbb76-5984-495e-94cd-9752fe6a4d61 [ 0.920] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 0.936] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 0.939] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[5a11bfce-b716-4d7a-944b-ea72e6225549]} requesting session [ 0.960] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[79e3ef58-d712-4821-9f8b-3e2a947bd7b5] id=[4af36742-61ac-49cc-8935-08a8ab14d6c6]} Got api session: {4af36742-61ac-49cc-8935-08a8ab14d6c6 79e3ef58-d712-4821-9f8b-3e2a947bd7b5} [ 0.975] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 79e3ef58-d712-4821-9f8b-3e2a947bd7b5 [ 0.983] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[9eb75dd2-88df-4b6c-8a1e-f9d1a6e15adc]} acquired network session [ 0.984] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 1.002] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:9000]} service is listening [ 1.003] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 1.023] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 79e3ef58-d712-4821-9f8b-3e2a947bd7b5 [ 1.071] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 1.071] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 1.072] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[5a11bfce-b716-4d7a-944b-ea72e6225549]} requesting session [ 1.102] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[5589a3dc-0301-4563-bf65-cf1143f9db3b]} acquired network session [ 1.102] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 1.103] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 1.104] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:8000]} service is listening use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>curl -H \"Host: wttr.in\" http://localhost:8000 > \"%HSM_DEST%\\example_%RSA_ID%.txt\" [ 7.803] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0[ 7.948] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 7.948] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 7.949] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 7.950] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 7.950] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 7.950] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{nJXo}]: started [ 7.951] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{nJXo}]: started [ 7.951] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 8.082] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{nJXo}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 8.082] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 8.083] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:52952]} tunnel started [ 8.084] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 8.085] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {edgeSeq=[1] connId=[1] type=[EdgeDataType] chSeq=[-1]} writing 71 bytes [ 8.252] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 8.252] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8852 bytes [ 8.255] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes 100 8687 100 8687 0 0 18522 0 --:--:-- --:--:-- --:--:-- 18522 [ 8.269] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:52952] src-local=[127.0.0.1:8000]} stopping pipe [ 8.269] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 8.270] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 8.271] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 8.273] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>curl -H \"Host: wttr.in\" http://localhost:9000 > \"%HSM_DEST%\\example_%EC_ID%.txt\" [ 8.298] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0[ 8.379] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 8.379] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 8.380] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 8.381] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 8.381] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{oWqn}]: started [ 8.383] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{oWqn}]: started [ 8.384] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 8.385] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 8.495] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{oWqn}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 8.495] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 8.495] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:52954] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel started [ 8.496] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {connId=[1] type=[EdgeDataType] chSeq=[-1] edgeSeq=[1]} writing 71 bytes [ 8.496] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 8.665] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 8.666] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8852 bytes [ 8.667] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes 100 8687 100 8687 0 0 23165 0 --:--:-- --:--:-- --:--:-- 24130 [ 8.674] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[127.0.0.1:52954] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} stopping pipe [ 8.674] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 8.675] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 8.675] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 8.676] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>[ 9.271] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 9.271] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 9.271] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:8000] dst-remote=[127.0.0.1:52952]} stopping pipe [ 9.271] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:52952]} tunnel closed: 71 bytes sent; 8852 bytes received [ 9.676] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 9.676] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 9.676] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:9000] dst-remote=[127.0.0.1:52954]} stopping pipe [ 9.677] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:52954] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel closed: 71 bytes sent; 8852 bytes received REM set the codepage for the cmd prompt so that the output looks nice c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>chcp 65001 Active code page: 65001 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM show the results in the console c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>type \"%HSM_DEST%\\example_%RSA_ID%.txt\" Weather report: Laurelton, United States Overcast .--. 14..24 °F .-( ). ↘ 13 mph (___.__)__) 9 mi 0.0 in ┌─────────────┐ ┌─────────────���────────────────┬───────────────────────┤ Fri 14 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├────────────��─────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Partly cloudy │ \\ / Sunny │ \\ / Clear │ \\ / Clear │ │ _ /\"\".-. 6..19 °F │ .-. 8..21 °F │ .-. 8..19 °F │ .-. 3..14 °F │ │ \\_( ). ↘ 11-13 mph │ ― ( ) ― �� 11-13 mph │ ― ( ) ― ↗ 11-13 mph │ ― ( ) ― ↓ 8-13 mph │ │ /(___(__) 5 mi │ `-’ 6 mi │ `-’ 6 mi │ `-’ 6 mi │ │ 0.0 in | 0% │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────���───────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Sat 15 Feb ├───────────────────────┬────────────────────────���─────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Sunny │ \\ / Partly cloudy │ \\ / Partly cloudy │ \\ / Partly cloudy │ │ .-. 14..17 °F │ _ /\"\".-. 17..24 °F │ _ /\"\".-. 21..30 °F │ _ /\"\".-. 17..24 °F │ │ ― ( ) ― ↖ 3 mph │ \\_( ). ↑ 6-8 mph │ \\_( ). ↑ 9-14 mph │ \\_( ). ↑ 8-14 mph │ │ `-’ 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ │ / \\ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────���───────────────────────┤ Sun 16 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├─────────────────────────────��┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Partly cloudy │ \\ / Partly cloudy │ Overcast │ Overcast │ │ _ /\"\".-. 24..30 °F │ _ /\"\".-. 35..39 °F │ .--. 37..39 °F │ .--. 32..33 °F │ │ \\_( ). ↗ 4-7 mph │ \\_( ). ↗ 7-8 mph │ .-( ). → 6-9 mph │ .-( ). ↗ 3-8 mph │ │ /(___(__) 6 mi │ /(___(__) 6 mi │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ Follow @igor_chubin for wttr.in updates c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>type \"%HSM_DEST%\\example_%EC_ID%.txt\" Weather report: Laurelton, United States Overcast .--. 14..24 °F .-( ). ↘ 13 mph (___.__)__) 9 mi 0.0 in ┌─────────────┐ ┌─────────────���────────────────┬───────────────────────┤ Fri 14 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├────────────��─────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Partly cloudy │ \\ / Sunny │ \\ / Clear │ \\ / Clear │ │ _ /\"\".-. 6..19 °F │ .-. 8..21 °F │ .-. 8..19 °F │ .-. 3..14 °F │ │ \\_( ). ↘ 11-13 mph │ ― ( ) ― �� 11-13 mph │ ― ( ) ― ↗ 11-13 mph │ ― ( ) ― ↓ 8-13 mph │ │ /(___(__) 5 mi │ `-’ 6 mi │ `-’ 6 mi │ `-’ 6 mi │ │ 0.0 in | 0% │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ / \\ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────���───────┘ ┌─────────────┐ ┌──────────────────────────────┬───────────────────────┤ Sat 15 Feb ├───────────────────────┬────────────────────────���─────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├──────────────────────────────┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Sunny │ \\ / Partly cloudy │ \\ / Partly cloudy │ \\ / Partly cloudy │ │ .-. 14..17 °F │ _ /\"\".-. 17..24 °F │ _ /\"\".-. 21..30 °F │ _ /\"\".-. 17..24 °F │ │ ― ( ) ― ↖ 3 mph │ \\_( ). ↑ 6-8 mph │ \\_( ). ↑ 9-14 mph │ \\_( ). ↑ 8-14 mph │ │ `-’ 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ /(___(__) 6 mi │ │ / \\ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ ┌─────────────┐ ┌──────────────────────────────���───────────────────────┤ Sun 16 Feb ├───────────────────────┬──────────────────────────────┐ │ Morning │ Noon └──────┬──────┘ Evening │ Night │ ├─────────────────────────────��┼──────────────────────────────┼──────────────────────────────┼──────────────────────────────┤ │ \\ / Partly cloudy │ \\ / Partly cloudy │ Overcast │ Overcast │ │ _ /\"\".-. 24..30 °F │ _ /\"\".-. 35..39 °F │ .--. 37..39 °F │ .--. 32..33 °F │ │ \\_( ). ↗ 4-7 mph │ \\_( ). ↗ 7-8 mph │ .-( ). → 6-9 mph │ .-( ). ↗ 3-8 mph │ │ /(___(__) 6 mi │ /(___(__) 6 mi │ (___.__)__) 6 mi │ (___.__)__) 6 mi │ │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ 0.0 in | 0% │ └──────────────────────────────┴──────────────────────────────┴──────────────────────────────┴──────────────────────────────┘ Follow @igor_chubin for wttr.in updates c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM ctrl-break or ctrl-pause to kill the tunnelers c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> [ 39.022] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal interrupt [ 39.015] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal interrupt c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>[ 39.023] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal interrupt [ 39.017] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal interrupt [ 39.025] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 39.018] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 39.025] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 39.019] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 39.026] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 [ 39.020] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 [ 39.027] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 39.020] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 39.028] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor [ 39.021] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor REM set the codepage for the cmd prompt so that the output looks nice"
  },
  "ziti/quickstarts/hsm-overview.html": {
    "href": "ziti/quickstarts/hsm-overview.html",
    "title": "Hardware Security Modules (HSM) - PKCS11 | Ziti",
    "keywords": "Hardware Security Modules (HSM) - PKCS11 A hardware security module (HSM) is a physical piece of equipment which is designed specifically to protect cryptographic keys and aid with cryptographical processing. HSMs are designed to manage sensitive information and are generally able to be connected and disconnected from a computer trying to use the HSM. Why an HSM Without a doubt the biggest benefit of an HSM is that it is a physical piece of hardware. This means that any cryptographic keys protecting data is stored in the HSM and those keys are able to be removed from any given device which had the HSM attached. Because these keys are not kept as files on a computer but are instead stored inside a physical piece of equipment attached to the computer it is more secure since there are no files for an attacker to find and copy. With an HSM you can be sure that they only computer with the relevant key is the one with the HSM attached to it. Another benefit of HSMs is that they are focused on security. The keys stored inside of many if not all HSMs are designed to not be able to be exported. This means that there's no chance for these keys to be extracted remotely and used outside of the HSM itself, further increasing the security of these important keys. Enabling a Ziti Endpoint Using an HSM Enabling a Ziti endpoint to utilize an HSM is straight forward but does require a bit of technical understanding. We have provided a couple of guides on how to enable an HSM with Ziti. The Ziti SDKs all interact with HSMs which support and provide a PKCS#11 library. PKCS#11 is a specification that outlines the programming interface software can use to interact with cryptographic hardware such as smart cards or HSMs. Quickstarts We have included a couple of quickstarts illustrating two different PKCS#11 drivers to help with understanding. You will want to go to the OpenSC Project as it is what provides the pkcs11-tool which is used to interact with the HSMs. The first quickstart is based on softhsm . This one focuses on software that provides an emulated HSM. This is useful for learning and understandin but it is not an actual HSM. Being software it doesn't have the important benefit of being a physical device but it does have one substantial advantage; it's entirely free. The second quickstart uses an actual physical device - a Yubico Yubikey. The specific key we used is a Yubikey 5 nfc ."
  },
  "ziti/quickstarts/kubernetes/README.html": {
    "href": "ziti/quickstarts/kubernetes/README.html",
    "title": "| Ziti",
    "keywords": "make a link to the ziti quickstart here mklink /j sidecar-tunnel c:\\git\\ziti\\quickstart\\kubernetes-sidecar-tunnel"
  },
  "ziti/quickstarts/network/aws-quickstart.html": {
    "href": "ziti/quickstarts/network/aws-quickstart.html",
    "title": "Ziti Quickstart AWS: Ziti Edge - Developer Edition | Ziti",
    "keywords": "Ziti Quickstart AWS: Ziti Edge - Developer Edition This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant Ziti concepts refer to the overview . From Nothing to Network To get started with Ziti here are the steps you will need to accomplish: Get Ziti Obtain, then change the default password Create an Identity Enroll the Identity Create a Service Create Policies Test the Service Start Ziti Getting Started in AWS This guide will leverage an Amazon Machine Image (AMI) delivered via the AWS Marketplace . Using the image you will have an instance of Ziti to use as you please within minutes. If you are unfamiliar AWS you'll want to take some time to come up to speed. You will need an account, and you'll want to become familiar with the console. Start here and when you feel ready - come back to this guide. Important Note for Starting a Ziti Instance NetFoundry has provided the Ziti Edge - Developer Edition to make it easy for you to deploy a fully functional Ziti-based network. Follow the prompts and launch a new AMI. You will need to make a few key decisions that might affect your Ziti-based network. Important This is IMPORTANT. Make sure you consider and understand any security implications of the choices made when starting the AMI Virtual Private Cloud (VPC): for the instance to be put into. Choosing the VPC will determine what network resources are available to your Ziti network Subnet: The subnet you choose further defines what resources the instance will have access to. If you have a service that is not visible to the public internet and you want to use Ziti to secure that service make sure you put the Ziti instance on the proper subnet Security Group: You will want to put the Ziti instance into a security group that allows access from the public internet on ports: 22, 443, 1280, 3022. port 22 - the default port that ssh uses. This is how you will log into the bare AMI after it is launched. port 443 - a small UI is delivered via a web server that runs on port 443, using self-signed certificates port 1280 - the preselected port the Ziti controller will serve its API over port 3022 - the preselected port for data channels to the Ziti Edge Router Public IP/DNS: Make sure the EC2 instance is assigned a public IP and a public DNS entry Note One can use CloudFormation template to aide in deploying the ZEDE image to VPC. The following link needs to be entered under \"Amazon S3 URL\" option when creating CF Stack https://s3.amazonaws.com/netfoundry-aws-quickstart/production/zede.template As seen in this screen shot. Important Make sure you have the private key corresponding to the public key you choose. Without the private key - you will not be able to authenticate to the bare AMI. Take note of the public ip address assigned to the instance. This ip is used when ssh-ing to the machine and this is the address that you'll use to access the online Web UI. For example if the ip address assigned is 52.165.223.129. You would ssh to the machine via this ip or the DNS name with 'nfadmin' as your username: ssh nfadmin@ec2-52-165-223-129.compute-1.amazonaws.com - or - ssh nfadmin@52.165.223.129 And you would access the Web UI at https://ec2-52-165-223-129.compute-1.amazonaws.com Obtain and Change the Default Password When first launched - the instace will deposit a file into the file system at /home/nfadmin/.config/ziti/ziti-controller/credentials.json. Note Since this is your first Ziti deployment this system is expected to be transient. If the IP address or DNS entry changes (such as a system reboot) the image needs to be reconfigured becuase the certificates will no longer be valid. This file is used to reconfigure the system in this event and it happens automatically on startup. Now, ssh to the newly created machine. Once there you can obtain the username and password for your Ziti Controller by issuing this command: jq -r .password /home/nfadmin/.config/ziti/ziti-controller/credentials.json You can choose to keep this password or change it to something easier to remember. If you change the password, please remember to use a strong password which is not easy to guess. Tip Once the password is changed - update the credentials.json file with the current password if you want the system to automatically update the certificates in the event of the image losing its IP address or DNS entry. Change via UI Change via CLI These AMIs will be provided with a self-signed certificate generated during securely during the bootup process. See changing pki for more information. Log into the UI using the password obtained in the prior step In the lower left corner, click the icon that looks like a person and choose \"Edit Profile\" Enter the current password along with a new/confirmed password and click \"Save\" To change the administrator password using the CLI simply issue these commands: Note You will need to login one time in order to use the ziti cli: #load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert #update the admin user. This command will prompt you to enter the password ziti edge controller update authenticator updb -s Create an Identity All connections to Ziti are mutually authenticated TLS connections. Identites map a given certificate to an identity within the Ziti Controller. Read more about Identities here Creating an identity via the UI or CLI is easy: New Identity via UI New Identity via CLI On the left side click \"Edge Identities\" In the top right corner of the screen click the \"plus\" image to add a new identity Enter the name of the identity you would like to create Choose the type: Device, Service, User (choose User for now) Leave the enrollment type as \"One Time Token\" Click save To create a new identity using the CLI simply issue these commands: #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enroll the New Identity Identities are not truly enabled until they are enrolled. Enrollment is a complex process. NetFoundy has created a tool specifically for this task to ensure safe and secure enrollment of identities. Download the enroller for your operating system. Windows MacOS Linux Download the jwt from the UI by clicking the icon that looks like a certificate (save the file as NewUser.jwt) or if you used the CLI from the output location specified when creating the user. In a command line editor, change to the folder containing the jwt. Enroll the identity by running ziti-enroller --jwt NewUser.jwt The ziti-enroller will output a new json file named NewUser.json . This file is precious and must be protected as it contains the identity of the given user. Create a Service With an identity created it's now time to create a service. Read more about Services here . For this example we are going to choose a simple website that is available on the open internet . This site will return the IP address you are coming from. Click this link now and discover what the your external IP is. New Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Enter \"ethzero-ui\" Enter a host name for the service. Enter \"ethzero.ziti.ui\" Enter port 80 Choose Router \"ziti-gw01\" For Endpoint Service choose: protocol = tcp host = eth0.me port = 80 Select \"demo-c01\" for the cluster Leave Hosting Identities as is Click save To create a new service using the CLI simply issue these two commands: #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create service ethzero-cli \"ethzero.ziti.cli\" \"80\" \"$edgeRouter\" \"tcp:eth0.me:80\" -c \"$cluster\" Create Policies Use policies to allow identities to access services allow identities to use edge routers allow services to use edge routers Read more about Policies here New Policies via UI New Policies via CLI New Service Policy On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Policy Choose a name for the Service Policy. Enter \"my-first-service-policy\" Select \"Dial\" in the Type dropdown Enter #all in the Service Roles input. #all is a special role attribute which matches all entities. Enter #all in the Identity Roles input. #all is a special role attribute which matches all entities. Click save New Edge Router Policy On the left side nav bar, click \"Ziti Policies\" It should already be selected, but if not, on the top nav bar, click \"Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy. Enter \"my-first-edge-router-policy\" Enter #all in the Identity Roles input. #all is a special role attribute which matches all entities. Enter #all in the Router Roles input. #all is a special role attribute which matches all entities. Click save New Service Edge Router Policy On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy. Enter \"my-first-service-edge-router-policy\" Enter #all in the Router Roles input. #all is a special role attribute which matches all entities. Enter #all in the Service Roles input. #all is a special role attribute which matches all entities. Click save [To create some policies using the CLI issue the following commands: # Create a service policy which allows all identities to use all services ziti edge controller create service-policy dial-all Dial --service-roles '#all' --identity-roles '#all' # Create an edge router policy which allows all identities to use all edge routers ziti edge controller create edge-router-policy all --edge-router-roles '#all' --identity-roles '#all' # Create a service edge router policy which allows all services to use all edge routers ziti edge controller create service-edge-router-policy --edge-router-roles '#all' --service-roles '#all' Test It Ok, you're almost ready to test your Ziti setup! Now you need to acquire a pre-built client from NetFoundry. The simplest way to test your setup is to get the ziti-tunnel for your OS. Windows MacOS Linux The ziti-tunnel has a mode which acts as a proxy into the Ziti overlay network. You will need the enrolled identity json file created in the previous step and this will require running a command. Here are the steps to verify your Ziti network and configuration are all working properly: Open a command prompt ensure ziti-tunnel and NewUser.json are in the same directory and cd to this directory run the ziti-tunnel in proxy mode: ziti-tunnel proxy -i NewUser.json ethzero-ui:1111 ziti-tunnel proxy -i NewUser.json ethzero-cli:2222 navigate your web browser to (or use curl) to obtain your IP address by going to http://localhost:1111/ At this point you should see the external IP address of your instance. Delivered to your machine safely and securely over your Ziti network."
  },
  "ziti/quickstarts/network/azure-quickstart.html": {
    "href": "ziti/quickstarts/network/azure-quickstart.html",
    "title": "Ziti Quickstart Azure: Ziti Edge - Developer Edition | Ziti",
    "keywords": "Ziti Quickstart Azure: Ziti Edge - Developer Edition This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant Ziti concepts refer to the overview . From Nothing to Network To get started with Ziti here are the steps you will need to accomplish: Get Ziti Obtain, then change the default password Create an Identity Enroll the Identity Create a Service Create Policies Test the Service Start Ziti Getting Started in Azure This guide will leverage an image delivered via the Azure Marketplace . Using the image you will have an instance of Ziti to use as you please within minutes. If you are unfamiliar Azure you'll want to take some time to come up to speed. You will need an account and you'll want to become familiar with the console. Start here and when you feel ready - come back to this guide. Important Note for Starting a Ziti Virtual Machine When starting your virtual machine instance of the Ziti Edge - Developer Edition via the Azure UI you will need to ensure the following: You have an Azure Resource Group and you are able to make the necessary changes From the Resource Group - click \"Add\" and find the Ziti Edge - Developer Edition Click \"Create\" to start the creation wizard On the \"Basics\" tab fill out the required options. Ensure you use the Username \"nfziti\" and uplaod a public key so you can SSH to the machine after its deployed Configure and choose options for \"Disks\" Configure and choose options for \"Networking\" It is important that a \"Basic\" IP is used. Click \"Create New\" under the Public IP and make a new IP make sure SKU is \"Basic\" and Assignment is \"Dynamic\" On the \"Management\" tab ensure the \"System assigned managed identity\" is set to \"On\" (the default is Off so you need to change this) Advance to and choose options for \"Advanced\" Advance to \"Tags\" - it's recommended you assingn a \"ZEDE\" (stands for Ziti Edge - Developer Edition) tag with a value that will be easy to find such as \"my-ziti\" or similar Create your virtual machine After the virtual machine is created and provisioned navigate back to the virtual machine. In the upper-right portion of the screen under \"DNS Name\" click configure to establish a DNS name. For simplicity choose a name that is guaranteed to be unique such as \"ziti-${ip.address}\". For example if the virtual machine is located in US Central and the IP address is 52.165.223.129 enter \"ziti-52-165-223-129.centralus.cloudapp.azure.com\". Remember this address. This is the address you will use when ssh-ing to the machine and this is the address that you'll use to access the online Web UI. For example building on the DNS name entered above - and if you chose 'nfadmin' as your username you would ssh using this command: ssh nfadmin@ziti-52-165-223-129.centralus.cloudapp.azure.com And you would access the Web UI at https://ziti-52-165-223-129.centralus.cloudapp.azure.com The final step is to add the network contributor role so that the machine can automatically discover network settings. This is used when the machine is rebooted. If the DNS address changes the Ziti Edge - Developer Edition will recreate certificates for the newly created DNS entry. From the Virtual Machine - click \"Access control (IAM)\" Click \"Add\" -> \"Add role assignment\" In the \"Add\" dialog choose: Role: Network Contributor Assign access to: Virtual Machine Subscription: (choose) Select: (choose your ZEDE virtual machine) Once the network contributor role is granted reboot the virtual machine. You are now able to access your \"Ziti Edge - Developer Edition\". Obtain and Change the Default Password When first launched - the instace will deposit a file into the file system at /home/nfadmin/.config/ziti/ziti-controller/credentials.json. Note Since this is your first Ziti deployment this system is expected to be transient. If the IP address or DNS entry changes (such as a system reboot) the image needs to be reconfigured becuase the certificates will no longer be valid. This file is used to reconfigure the system in this event and it happens automatically on startup. Now, ssh to the newly created machine. Once there you can obtain the username and password for your Ziti Controller by issuing this command: jq -r .password /home/nfadmin/.config/ziti/ziti-controller/credentials.json You can choose to keep this password or change it to something easier to remember. If you change the password, please remember to use a strong password which is not easy to guess. Tip Once the password is changed - update the credentials.json file with the current password if you want the system to automatically update the certificates in the event of the image losing its IP address or DNS entry. Change via UI Change via CLI These AMIs will be provided with a self-signed certificate generated during securely during the bootup process. See changing pki for more information. Log into the UI using the password obtained in the prior step In the lower left corner, click the icon that looks like a person and choose \"Edit Profile\" Enter the current password along with a new/confirmed password and click \"Save\" To change the administrator password using the CLI simply issue these commands: Note You will need to login one time in order to use the ziti cli: #load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert #update the admin user. This command will prompt you to enter the password ziti edge controller update authenticator updb -s Create an Identity All connections to Ziti are mutually authenticated TLS connections. Identites map a given certificate to an identity within the Ziti Controller. Read more about Identities here Creating an identity via the UI or CLI is easy: New Identity via UI New Identity via CLI On the left side click \"Edge Identities\" In the top right corner of the screen click the \"plus\" image to add a new identity Enter the name of the identity you would like to create Choose the type: Device, Service, User (choose User for now) Leave the enrollment type as \"One Time Token\" Click save To create a new identity using the CLI simply issue these commands: #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enroll the New Identity Identities are not truly enabled until they are enrolled. Enrollment is a complex process. NetFoundy has created a tool specifically for this task to ensure safe and secure enrollment of identities. Download the enroller for your operating system. Windows MacOS Linux Download the jwt from the UI by clicking the icon that looks like a certificate (save the file as NewUser.jwt) or if you used the CLI from the output location specified when creating the user. In a command line editor, change to the folder containing the jwt. Enroll the identity by running ziti-enroller --jwt NewUser.jwt The ziti-enroller will output a new json file named NewUser.json . This file is precious and must be protected as it contains the identity of the given user. Create a Service With an identity created it's now time to create a service. Read more about Services here . For this example we are going to choose a simple website that is available on the open internet . This site will return the IP address you are coming from. Click this link now and discover what the your external IP is. New Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Enter \"ethzero-ui\" Enter a host name for the service. Enter \"ethzero.ziti.ui\" Enter port 80 Choose Router \"ziti-gw01\" For Endpoint Service choose: protocol = tcp host = eth0.me port = 80 Select \"demo-c01\" for the cluster Leave Hosting Identities as is Click save To create a new service using the CLI simply issue these two commands: #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create service ethzero-cli \"ethzero.ziti.cli\" \"80\" \"$edgeRouter\" \"tcp:eth0.me:80\" -c \"$cluster\" Create Policies Use policies to allow identities to access services allow identities to use edge routers allow services to use edge routers Read more about Policies here New Policies via UI New Policies via CLI New Service Policy On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Policy Choose a name for the Service Policy. Enter \"my-first-service-policy\" Select \"Dial\" in the Type dropdown Enter #all in the Service Roles input. #all is a special role attribute which matches all entities. Enter #all in the Identity Roles input. #all is a special role attribute which matches all entities. Click save New Edge Router Policy On the left side nav bar, click \"Ziti Policies\" It should already be selected, but if not, on the top nav bar, click \"Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy. Enter \"my-first-edge-router-policy\" Enter #all in the Identity Roles input. #all is a special role attribute which matches all entities. Enter #all in the Router Roles input. #all is a special role attribute which matches all entities. Click save New Service Edge Router Policy On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy. Enter \"my-first-service-edge-router-policy\" Enter #all in the Router Roles input. #all is a special role attribute which matches all entities. Enter #all in the Service Roles input. #all is a special role attribute which matches all entities. Click save [To create some policies using the CLI issue the following commands: # Create a service policy which allows all identities to use all services ziti edge controller create service-policy dial-all Dial --service-roles '#all' --identity-roles '#all' # Create an edge router policy which allows all identities to use all edge routers ziti edge controller create edge-router-policy all --edge-router-roles '#all' --identity-roles '#all' # Create a service edge router policy which allows all services to use all edge routers ziti edge controller create service-edge-router-policy --edge-router-roles '#all' --service-roles '#all' Test It Ok, you're almost ready to test your Ziti setup! Now you need to acquire a pre-built client from NetFoundry. The simplest way to test your setup is to get the ziti-tunnel for your OS. Windows MacOS Linux The ziti-tunnel has a mode which acts as a proxy into the Ziti overlay network. You will need the enrolled identity json file created in the previous step and this will require running a command. Here are the steps to verify your Ziti network and configuration are all working properly: Open a command prompt ensure ziti-tunnel and NewUser.json are in the same directory and cd to this directory run the ziti-tunnel in proxy mode: ziti-tunnel proxy -i NewUser.json ethzero-ui:1111 ziti-tunnel proxy -i NewUser.json ethzero-cli:2222 navigate your web browser to (or use curl) to obtain your IP address by going to http://localhost:1111/ At this point you should see the external IP address of your instance. Delivered to your machine safely and securely over your Ziti network."
  },
  "ziti/quickstarts/network/common-quickstart.html": {
    "href": "ziti/quickstarts/network/common-quickstart.html",
    "title": "Obtain and Change the Default Password | Ziti",
    "keywords": "Obtain and Change the Default Password When first launched - the instace will deposit a file into the file system at /home/nfadmin/.config/ziti/ziti-controller/credentials.json. Note Since this is your first Ziti deployment this system is expected to be transient. If the IP address or DNS entry changes (such as a system reboot) the image needs to be reconfigured becuase the certificates will no longer be valid. This file is used to reconfigure the system in this event and it happens automatically on startup. Now, ssh to the newly created machine. Once there you can obtain the username and password for your Ziti Controller by issuing this command: jq -r .password /home/nfadmin/.config/ziti/ziti-controller/credentials.json You can choose to keep this password or change it to something easier to remember. If you change the password, please remember to use a strong password which is not easy to guess. Tip Once the password is changed - update the credentials.json file with the current password if you want the system to automatically update the certificates in the event of the image losing its IP address or DNS entry. Change via UI Change via CLI These AMIs will be provided with a self-signed certificate generated during securely during the bootup process. See changing pki for more information. Log into the UI using the password obtained in the prior step In the lower left corner, click the icon that looks like a person and choose \"Edit Profile\" Enter the current password along with a new/confirmed password and click \"Save\" To change the administrator password using the CLI simply issue these commands: Note You will need to login one time in order to use the ziti cli: #load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert #update the admin user. This command will prompt you to enter the password ziti edge controller update authenticator updb -s Create an Identity All connections to Ziti are mutually authenticated TLS connections. Identites map a given certificate to an identity within the Ziti Controller. Read more about Identities here Creating an identity via the UI or CLI is easy: New Identity via UI New Identity via CLI On the left side click \"Edge Identities\" In the top right corner of the screen click the \"plus\" image to add a new identity Enter the name of the identity you would like to create Choose the type: Device, Service, User (choose User for now) Leave the enrollment type as \"One Time Token\" Click save To create a new identity using the CLI simply issue these commands: #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enroll the New Identity Identities are not truly enabled until they are enrolled. Enrollment is a complex process. NetFoundy has created a tool specifically for this task to ensure safe and secure enrollment of identities. Download the enroller for your operating system. Windows MacOS Linux Download the jwt from the UI by clicking the icon that looks like a certificate (save the file as NewUser.jwt) or if you used the CLI from the output location specified when creating the user. In a command line editor, change to the folder containing the jwt. Enroll the identity by running ziti-enroller --jwt NewUser.jwt The ziti-enroller will output a new json file named NewUser.json . This file is precious and must be protected as it contains the identity of the given user. Create a Service With an identity created it's now time to create a service. Read more about Services here . For this example we are going to choose a simple website that is available on the open internet . This site will return the IP address you are coming from. Click this link now and discover what the your external IP is. New Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Enter \"ethzero-ui\" Enter a host name for the service. Enter \"ethzero.ziti.ui\" Enter port 80 Choose Router \"ziti-gw01\" For Endpoint Service choose: protocol = tcp host = eth0.me port = 80 Select \"demo-c01\" for the cluster Leave Hosting Identities as is Click save To create a new service using the CLI simply issue these two commands: #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create service ethzero-cli \"ethzero.ziti.cli\" \"80\" \"$edgeRouter\" \"tcp:eth0.me:80\" -c \"$cluster\" Create Policies Use policies to allow identities to access services allow identities to use edge routers allow services to use edge routers Read more about Policies here New Policies via UI New Policies via CLI New Service Policy On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Policy Choose a name for the Service Policy. Enter \"my-first-service-policy\" Select \"Dial\" in the Type dropdown Enter #all in the Service Roles input. #all is a special role attribute which matches all entities. Enter #all in the Identity Roles input. #all is a special role attribute which matches all entities. Click save New Edge Router Policy On the left side nav bar, click \"Ziti Policies\" It should already be selected, but if not, on the top nav bar, click \"Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy. Enter \"my-first-edge-router-policy\" Enter #all in the Identity Roles input. #all is a special role attribute which matches all entities. Enter #all in the Router Roles input. #all is a special role attribute which matches all entities. Click save New Service Edge Router Policy On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy. Enter \"my-first-service-edge-router-policy\" Enter #all in the Router Roles input. #all is a special role attribute which matches all entities. Enter #all in the Service Roles input. #all is a special role attribute which matches all entities. Click save [To create some policies using the CLI issue the following commands: # Create a service policy which allows all identities to use all services ziti edge controller create service-policy dial-all Dial --service-roles '#all' --identity-roles '#all' # Create an edge router policy which allows all identities to use all edge routers ziti edge controller create edge-router-policy all --edge-router-roles '#all' --identity-roles '#all' # Create a service edge router policy which allows all services to use all edge routers ziti edge controller create service-edge-router-policy --edge-router-roles '#all' --service-roles '#all' Test It Ok, you're almost ready to test your Ziti setup! Now you need to acquire a pre-built client from NetFoundry. The simplest way to test your setup is to get the ziti-tunnel for your OS. Windows MacOS Linux The ziti-tunnel has a mode which acts as a proxy into the Ziti overlay network. You will need the enrolled identity json file created in the previous step and this will require running a command. Here are the steps to verify your Ziti network and configuration are all working properly: Open a command prompt ensure ziti-tunnel and NewUser.json are in the same directory and cd to this directory run the ziti-tunnel in proxy mode: ziti-tunnel proxy -i NewUser.json ethzero-ui:1111 ziti-tunnel proxy -i NewUser.json ethzero-cli:2222 navigate your web browser to (or use curl) to obtain your IP address by going to http://localhost:1111/ At this point you should see the external IP address of your instance. Delivered to your machine safely and securely over your Ziti network."
  },
  "ziti/quickstarts/networks-overview.html": {
    "href": "ziti/quickstarts/networks-overview.html",
    "title": "Ziti Networks | Ziti",
    "keywords": "Ziti Networks Provisioning a new network from the ground up for use in a developement enviroment is easy with the Ziti Edge - Developer editions NetFoundry has provided. Choose a provider and go from nothing to network quickly and easily! AWS Azure"
  },
  "ziti/quickstarts/quickstart-overview.html": {
    "href": "ziti/quickstarts/quickstart-overview.html",
    "title": "Ziti Quickstarts | Ziti",
    "keywords": "Ziti Quickstarts Here you will find our quickstarts. These pages are designed to get you up and running and working with Ziti with minimal friction. Grab a quickstart and try it out. Once you have completed the quickstart you'll have a foundation for making changes and customizations."
  },
  "ziti/services/create-service-cli.html": {
    "href": "ziti/services/create-service-cli.html",
    "title": "| Ziti",
    "keywords": "# creates a new service named ssh ziti edge controller create service ssh # creates a new service named ssh with a terminator strategy which load-balances using random selection ziti edge controller create service ssh --terminator-strategy random # creates a router based terminator for ssh on router router1 which connects to the local machine ziti edge controller create terminator ssh router1 tcp:localhost:22 # creates a new service named postgresql with a terminator strategy which does failover ziti edge controller create service postgresql --terminator-strategy ha # creates a router based terminator for postgres on router router1 # this is the posgres primary, so precedence is set to required ziti edge controller create terminator postgresql router1 tcp:pg-primary:5432 --precedence required # creates a router based terminator for postgres on router router1 which connects to another machine # this is the posgresql secondary, so precedence is left at default ziti edge controller create terminator postgresql router1 tcp:pg-secondary:5432 # If the primary goes down, the controller will notice that dials are failing and set the # precedence to failed. New sessions will go to the secondary. When the primary is brought # back up, it can be marked as requred again ziti edge controller update terminator <terminator-id> --precedence required"
  },
  "ziti/services/creating.html": {
    "href": "ziti/services/creating.html",
    "title": "Creating a Service | Ziti",
    "keywords": "Creating a Service Here's how you can create a service. New non-hosted Service via UI New hosted Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose Router by name - for example \"ziti-gw01\" if you are using Ziti Edge - Developer Edition For Endpoint Service choose: protocol = tcp host = actual-hostname port = 2222 Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Leave Hosting Identities as is Click save On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-hosted-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose \"Hosted (No Router)\" for the Router Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Select one or more identities in \"Hosting Identities\" representing the identities which host the service Click save To change the administrator password using the CLI simply issue these two commands: # creates a new service named ssh ziti edge controller create service ssh # creates a new service named ssh with a terminator strategy which load-balances using random selection ziti edge controller create service ssh --terminator-strategy random # creates a router based terminator for ssh on router router1 which connects to the local machine ziti edge controller create terminator ssh router1 tcp:localhost:22 # creates a new service named postgresql with a terminator strategy which does failover ziti edge controller create service postgresql --terminator-strategy ha # creates a router based terminator for postgres on router router1 # this is the posgres primary, so precedence is set to required ziti edge controller create terminator postgresql router1 tcp:pg-primary:5432 --precedence required # creates a router based terminator for postgres on router router1 which connects to another machine # this is the posgresql secondary, so precedence is left at default ziti edge controller create terminator postgresql router1 tcp:pg-secondary:5432 # If the primary goes down, the controller will notice that dials are failing and set the # precedence to failed. New sessions will go to the secondary. When the primary is brought # back up, it can be marked as requred again ziti edge controller update terminator <terminator-id> --precedence required"
  },
  "ziti/services/overview.html": {
    "href": "ziti/services/overview.html",
    "title": "Ziti Services | Ziti",
    "keywords": "Ziti Services The primary function of Ziti is providing access to \"services\". A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A service is defined by the following components: Name - the name of the service Termination - Ziti only provides access to a network service, it does not provide the service itself. The service must be able to get network traffic to whatever application or application cluster is actually providing the service, whether that provider has Ziti embedded or has no knowledge of Ziti Configuration - Ziti allows application specific configuration to be stored for services. See Configuration Store Authorization - For a details on controlling access to services, see Policies . Service Name Ziti services must have names that are unique to their Ziti installation. Service names are how clients address services in order to consume them. Services which are provided by applications with Ziti embedded also use the service name to indicate which service is being provided. Services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti service is be defined by a name and this name is registered with the Ziti Controller. Once declared, services can then be addressed directly by name from Ziti-aware clients. This means there are effecitvely a limitless number names available with no need for global DNS registration. The names assigned are unique to a Ziti Network and the application developer has total control over service names. Service Termination In Ziti, service termination refers to how a network traffic going over Ziti reaches the application (or application cluster) which is actually providing a service. There are a few basic ways in which a service can be terminated at an application. There are some trade-offs to consider for each type of termination. Do you want end-to-end zero trust? If yes, that requires that both the client and server have Ziti identities and can connect securely with provisioned certificates. Do you want Ziti provided end-to-end encryption? Developers can always provide their own end-to-end encryption on top of the connectivity that Ziti provides, but not all modes of service termination allow Ziti to encrypt traffic end-to-end for you. How accessible to non-zero-trust clients do you want your server application to be? With the proper configuration applications can be fully 'dark', meaning they do not listen for connections. SDK Embedded Applications The server application can embed the Ziti Edge SDK. The application will have an enrolled identity and provisioned certificates. This has several advantages: Connections between the application and Ziti will be secured using certificates. This enables true zero-trust and end-to-end encrypted connections betwen SDK based clients and SDK based servers. With an identity, the server application can particpate in the Ziti security model. This means you can control which services the application can provide, and revoke access as needed. You can also control which edge routers the application may connect to. The application will be 'dark'. Instead of listening for incoming network connections, the application will make an outgoing, secured connection to one or more Ziti edge routers. It will then receive network requests over these secured connections. The downside to this approach, specifically for existing applications, is that the application must be refactored to use a Ziti Edge SDK. Depending on language and frameworks used, the effort required can range from updating a few lines of code to writing a new SDK from scratch for a language that's not supported yet. Proxied Applications For applications where it doesn't make sense to embed the SDK a Ziti SDK based proxy can provide access to the application. Often the proxy may take the form of a sidecar and be co-located with the application. This minimizes the attack surface. There are a few things to note about this approach. The application will not be completely dark. It must accept connections from wherever the proxy is located. The proxy may be co-located with the application, so the attack surface area may be tiny. However, tiny is still bigger than zero. Similarly, traffic can be encrypted between the client and the proxy, but traffic between the proxy and the application will not be covered under the Ziti end-to-end encryption. It may still be encrypted, if the client and server establish their own encryption at the discretion of the client and server implementors. Via the proxy, the application is still represented by an identity and thus participates in policies. Services which uses proxes for server side termination may require extra configuration, so that the proxing application knows how to connect to the server application. Service configurations are discussed more below. Ziti Router Terminated Services Routers also have the ability to connect to applications providing services. This approach has its own advantages and disadvantages. Like the proxy approach, the application cannot be completely dark. The application must be reachable from the Ziti router. Ziti currently only offers end-to-end encryption between two SDK applications. Sessions terminating at a router cannot be end-to-end encrypted by Ziti. The data may still be end-to-end encrypted by the client and server, but that is up to the client and server implementors. Summary Termination Type End-to-end Zero Trust Managed by Policies Ziti Provided End-to-end encryption Dark Server Application SDK Embedded Yes Yes Yes Yes SDK Based Proxy No, only to proxy Yes (via Proxy) Only to proxy. If desired, full end-to-end must be done externally No. Can be relatively locked down, though Ziti Router No No No. If desired, end-to-end must be done externally No. Can be relatively locked down, though. Terminators Terminators represent a way to connect to a specific server application for a specific service. For SDK based server (whether embedded or proxied), these are created automatically as the application connects and removed when the application disconnects. For router terminated services they must be created manually. When creating a terminator manually, the following must be specified. The router which will connect to the server application The binding. This indicates which Xgress component on the router will handle making the connection. This will generally be transport for tcp based applications and udp for UDP based applications See the ziti-fabric documentation for more information on the Xgress framework The address to connect to. This will be generally take the form <protocol>:<host or ip>:<port> Example: tcp:localhost:5432 Availability and Scaling Services can be made highly available and/or horizontally scalable. There are two kinds of availability that server applications need to concern themselves with. Router HA/Scaling The first is allowing multiple routers to connect to a single application. Multiple Routers This ensures that the application will still be able to service requests even if a router fails or there is network partition separating a router and server application. It also will help ensure that the router layer doesn't become a bottleneck, as more routers can be addeded as necessary to scale out connectivity. Finally, it provides multiple network paths to the application. This gives smart routing more to choose optimal routes from as network conditions change. Application HA/Scaling The second is application availabilty and/or scalability. There will often be multiple instances of a service application running, either for failover or in a load balanced deployment. Failover Deployment Horizontal Scale Deployment Xt All types of availability and scalability involve multiple terminators. What distinguishes an HA failover setup from a load-balanced horizontal scale setup is how new sessions are assigned to terminators. For failover, we want sessions to always go to the same service instance. For horizontal scale, we want to load balance sessions across available instances. The fabric contains a framework called Xt (eXtensible Terminators) which allows defining terminator strategies and defines how terminator strategies and external components integrate with smart routing. The general flow of terminator selection goes as follows: A client requests a new session for a service Smart routing finds all the active terminators for the session (active meaning the terminator's router is connected) Smart routing calculates a cost for each terminator then hands the service's terminator strategy a list of terminators and their costs ranked from lowest to highest The strategy returns the terminator that should be used A new session is created using that path. Strategies will often work by adjusting terminator costs. The selection algorithm the simply returns the lowest cost option presented by smart routing. Costs There are a number of elements which feed the smart routing cost algorithm. Route Cost The cost of the route from the initiating route to the terminator router will be included in the terminator cost. This cost may be influenced by things such as link latencies and user determined link costs. Static Cost Each terminator has a static cost which can be set or updated when the terminator is created. SDK applications can set the terminator cost when they invoke the Listen operation. Precedence Each terminator has a precedence. There are three precedence levels: required , default and failed . Smart routing will always rank terminators with higher precedence levels higher than terminators with lower precedence levers. So required terminators will always be first, default second and failed third. Precedence levels can be used to implement HA. The primary will be marked as required and the secondary as default. When the primary is determined to be down, either by some internal or external set of heuristics, it will be marked as Failed and new sessions will go to the secondary. When the primary recovers it can be bumped back up to Required. Dynamic Cost Each terminator also has a dynamic cost that will move a terminator up and down relative to its precedence. This cost can be driven by stratagies or by external components. A strategy might use number of active of open sessions or dial successes and failures to drive the dynamic cost. Effective Cost Each terminator has an associated precedence and dynamic cost. This can be reduced to a single cost. The cost algorithm ensures terminators at difference precedence levels do not overlap. So a terminator which is marked failed, with dynamic cost 0, will always have a higher calculated cost than a terminator with default precedence and maximum value for dynamic cost. Strategies The fabric currently provides four strategy implementions. smartrouting This is the default strategy. It always uses the lowest cost terminator. It drives costs as follows: Cost is proportional to number of open sessions Dial failures drive the cost up Dial successes drive the cost down, but only as much as they were previously driven up by failures weighted This strategy drives costs in the same way as the smartrouting strategy. However instead of always picking the lowest cost terminator it does a weighted random selection across all terminators of the highest precedence. If a terminator has double the cost of another terminator it should get picked approximately half as often. random This strategy does not change terminator weights. It does simple random selection across all terminators of the highest precedence. ha This strategy assumes that one terminator will have required precedence and there will be a secondary terminator with default precedence. If three consecutive dials to the highest ranked terminator fail in a row it will be marked as failed. This will allow the secondary to take over. If the primary recovers it can be marked as required again via the APIs. Creating a Service Here's how you can create a service. New non-hosted Service via UI New hosted Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose Router by name - for example \"ziti-gw01\" if you are using Ziti Edge - Developer Edition For Endpoint Service choose: protocol = tcp host = actual-hostname port = 2222 Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Leave Hosting Identities as is Click save On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-hosted-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose \"Hosted (No Router)\" for the Router Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Select one or more identities in \"Hosting Identities\" representing the identities which host the service Click save To change the administrator password using the CLI simply issue these two commands: # creates a new service named ssh ziti edge controller create service ssh # creates a new service named ssh with a terminator strategy which load-balances using random selection ziti edge controller create service ssh --terminator-strategy random # creates a router based terminator for ssh on router router1 which connects to the local machine ziti edge controller create terminator ssh router1 tcp:localhost:22 # creates a new service named postgresql with a terminator strategy which does failover ziti edge controller create service postgresql --terminator-strategy ha # creates a router based terminator for postgres on router router1 # this is the posgres primary, so precedence is set to required ziti edge controller create terminator postgresql router1 tcp:pg-primary:5432 --precedence required # creates a router based terminator for postgres on router router1 which connects to another machine # this is the posgresql secondary, so precedence is left at default ziti edge controller create terminator postgresql router1 tcp:pg-secondary:5432 # If the primary goes down, the controller will notice that dials are failing and set the # precedence to failed. New sessions will go to the secondary. When the primary is brought # back up, it can be marked as requred again ziti edge controller update terminator <terminator-id> --precedence required"
  },
  "ziti-android-app/CODE_OF_CONDUCT.html": {
    "href": "ziti-android-app/CODE_OF_CONDUCT.html",
    "title": "Code of Conduct | Ziti",
    "keywords": "Code of Conduct All open source projects managed by NetFoundry share a common code of conduct which all contributors are expected to follow. Please be sure you read, understand and adhere to the thoughts expressed therein. Individuals acting in any way that is considered in violation of the Code of Conduct will receive corrective actions appropriate for the violation. It is possible to act in ways which technically do not violate the Code of Conduct but are clearly against the spirit of the project. These situations will also be considered on a case by case basis and if necessary the Code of Conduct will be revised accordingly and approrpiate notifications will be made to the community and to the violator. Violations Contributors violating the Code of Conduct will receive public notification of the violation. Contined violations or aggregious violations of the Code of Conduct will result in the contributor being removed from the contributors list as well as further contributions being declined."
  },
  "ziti-android-app/CONTRIBUTING.html": {
    "href": "ziti-android-app/CONTRIBUTING.html",
    "title": "Contributing | Ziti",
    "keywords": "Contributing NetFoundry welcomes all and any contributions. All open source projects managed by NetFoundry share a common guide for contributions . If you are eager to contribute to a NetFoundry-managed open source project please read and act accordingly."
  },
  "ziti-android-app/README.html": {
    "href": "ziti-android-app/README.html",
    "title": "Ziti Android Quickstart | Ziti",
    "keywords": "Ziti Android Quickstart This is a simple app that demonstrates the use of Ziti SDK for Android (and Java). Prerequisites Android studio or other Android IDE Android simulator or device to run the app Running the app Create Ziti Network following the guide Create weather service that is used by this app: name = ziti-weather-service hostname = weather.ziti.netfoundry.io port = 80 endpoint host = wttr.in endpoint port = 80 endpoint protocol = tcp Create an identity for the device running this. You'll need one identity per device. You will need to configure access to the service for your new identity. Download enrollment JWT and copy it to the device. Once the app starts it will show notification to let user know that the app has not been enrolled Tapping the notification allows you to select enrollent token If enrollment is successful it shows shows notification on the screen After that the app can be used -- pushing the message button should load current weather for Charlotte on the screen"
  },
  "ziti-cmd/quickstart/docker/README.html": {
    "href": "ziti-cmd/quickstart/docker/README.html",
    "title": "Quick Start Up and Running | Ziti",
    "keywords": "Quick Start Up and Running Build Docker Image Copy Ziti binaries into ziti/quickstart/docker/image/ziti.ignore/ Build image: $ cd ziti/quickstart/docker $ docker-compose build Start Ziti Environment $ docker-compose up -d Clean Up $ docker-compose down; docker volume prune /y; docker volume rm docker_ziti-fs"
  },
  "ziti-cmd/quickstart/kubernetes/sidecar-tunnel/kubernetes-sidecar-tunnel-quickstart.html": {
    "href": "ziti-cmd/quickstart/kubernetes/sidecar-tunnel/kubernetes-sidecar-tunnel-quickstart.html",
    "title": "Kubernetes Sidecar Client | Ziti",
    "keywords": "Kubernetes Sidecar Client This guide shows you how to access a NetFoundry service from a pre-existing (or third party) application that's running in a Kubernetes Pod. To provide access to the service, we will deploy the ziti-tunnel NetFoundry client in a sidecar container. Overview The Ziti Network Quickstart walked you through standing up a Ziti instance and accessing a Ziti service from your workstation with ziti-tunnel . In this guide we'll deploy the same ziti-tunnel client, but instead of running it from the command line we will deploy it in a sidecar container in a Kubernetes Pod. This guide also demonstrates ziti-tunnel 's internal DNS server, which allows us to access NetFoundry services by hostname instead of IP address. Here's some detail on how the various intercept modes work on Linux Solution Overview Prerequisites Complete the Ziti Network Quickstart . This guide uses the Ziti Controller and Ziti Edge Router that are created in the Ziti Quickstart. Admin-level access to a Kubernetes cluster via kubectl . Create an Identity and AppWAN This guide will re-use the \"eth0.ziti.cli\" service that was created in the Ziti Network Quickstart. We will create a new identity for our client, with a new AppWAN that uses the eth0.ziti.cli service. Create the Identity: $ ziti edge controller create identity device tunnel-sidecar -o tunnel-sidecar.jwt Create the AppWAN: $ ziti edge controller create app-wan ziti-tunnel-appwan -i tunnel-sidecar -s eth0.ziti.cli Create a Kubernetes Secret The ziti-tunnel sidecar will access its identity by mounting a Kubernetes secret in the container. We can mount the JWT as a secret like this: $ kubectl create secret generic tunnel-sidecar.jwt --from-file=tunnel-sidecar.jwt Deploy the Pod Deploy a Pod that runs a client application and ziti-tunnel as a sidecar container. For this demonstration, the client application is wget . Our Pod runs wget in a loop so we can see content from our NetFoundry service in the Pod's logs. Save the following yaml to a file named tunnel-sidecar-demo.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: tunnel-sidecar-pv-claim spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi --- apiVersion: apps/v1 kind: Deployment metadata: name: ziti-tunnel-sidecar-demo spec: replicas: 1 selector: matchLabels: app: ziti-tunnel-sidecar-demo strategy: type: Recreate template: metadata: labels: app: ziti-tunnel-sidecar-demo spec: containers: - image: centos name: testclient command: [\"sh\",\"-c\",\"while true; set -x; do curl -sSLf ethzero.ziti.ui 2>&1; set +x; sleep 5; done\"] - image: netfoundry/ziti-tunnel:0.5.8-2554 name: ziti-tunnel env: - name: NF_REG_NAME value: tunnel-sidecar volumeMounts: - name: tunnel-sidecar-jwt mountPath: \"/var/run/secrets/netfoundry.io/enrollment-token\" readOnly: true - name: ziti-tunnel-persistent-storage mountPath: /netfoundry securityContext: capabilities: add: - NET_ADMIN dnsPolicy: \"None\" dnsConfig: nameservers: - 127.0.0.1 - 8.8.8.8 restartPolicy: Always volumes: - name: ziti-tunnel-persistent-storage persistentVolumeClaim: claimName: tunnel-sidecar-pv-claim - name: tunnel-sidecar-jwt secret: secretName: tunnel-sidecar.jwt You'll notice that the ziti-tunnel sidecar container has a few requirements: The name of the identity that is assumed by ziti-tunnel must be passed into the container with the NF_REG_NAME environment variable. The secret that we created above for the enrollment token must be mounted into the container at \"/var/run/secrets/netfoundry.io/enrollment-token\". A persistent volume must be mounted at \"/netfoundry\". This volume is used to save the json file that is created when the one-time enrollment token is used. If this volume is not persistent, you will need to provide a new enrollment token each time the Pod is restarted! Once the yaml is saved, we can deploy the Pod with kubectl $ kubectl apply -f ./tunnel-sidecar-demo.yaml Test the Service First we need to get the name of the Pod that Kubernetes deployed for us: $ kubectl get pods ziti-tunnel-sidecar-demo-749c476989-6wpfn 1/1 Running 0 42s Then we can tail the logs for the \"testclient\" container: $ kubectl logs -f ziti-tunnel-sidecar-demo-749c476989-6wpfn --container testclient 54.67.121.213 54.67.121.213 54.67.121.213 Notice that the wget client is using the DNS name that we provided in the Ziti service definition to make the request."
  }
}